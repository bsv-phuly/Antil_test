{
  "resolvedId": "/home/runner/work/Antil_test/Antil_test/node_modules/radix-vue/dist/index.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { inject as vn, provide as mn, shallowRef as hn, watchEffect as ee, readonly as it, customRef as uo, ref as P, computed as S, watch as U, nextTick as G, getCurrentScope as Ia, onScopeDispose as Aa, effectScope as gn, unref as n, toRef as yn, onBeforeUnmount as co, getCurrentInstance as Se, onMounted as q, Fragment as le, defineComponent as b, toRefs as z, renderSlot as y, onBeforeUpdate as Ra, onUpdated as Ma, toHandlerKey as ka, camelize as bn, onUnmounted as fe, mergeProps as T, h as Ve, cloneVNode as Va, openBlock as h, createBlock as C, withCtx as m, createVNode as k, createCommentVNode as X, withKeys as ie, Teleport as Ye, normalizeProps as L, guardReactiveProps as N, normalizeStyle as re, reactive as Cn, withModifiers as oe, createElementBlock as Q, mergeDefaults as wn, createElementVNode as ut, renderList as po, markRaw as en, withDirectives as fo, vShow as _n, resolveDynamicComponent as we, createTextVNode as ue, toDisplayString as Le, isRef as dt, onBeforeMount as $n, vModelSelect as Fa, useSlots as xn, toRaw as La } from \"vue\";\nimport { useFloating as Ka, autoUpdate as Na, offset as Ha, flip as tn, shift as ja, limitShift as Wa, size as za, arrow as Ua, hide as qa } from \"@floating-ui/vue\";\nfunction H(o, t) {\n  const e = typeof o == \"string\" && !t ? `${o}Context` : t, a = Symbol(e);\n  return [(l) => {\n    const i = vn(a, l);\n    if (i || i === null)\n      return i;\n    throw new Error(\n      `Injection \\`${a.toString()}\\` not found. Component must be used within ${Array.isArray(o) ? `one of the following components: ${o.join(\n        \", \"\n      )}` : `\\`${o}\\``}`\n    );\n  }, (l) => (mn(a, l), l)];\n}\nfunction vo(o, t, e) {\n  const a = e.originalEvent.target, s = new CustomEvent(o, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && a.addEventListener(o, t, { once: !0 }), a.dispatchEvent(s);\n}\nfunction Ga(o, t) {\n  var e;\n  const a = hn();\n  return ee(() => {\n    a.value = o();\n  }, {\n    ...t,\n    flush: (e = t == null ? void 0 : t.flush) != null ? e : \"sync\"\n  }), it(a);\n}\nfunction Ya(o, t) {\n  let e, a, s;\n  const r = P(!0), l = () => {\n    r.value = !0, s();\n  };\n  U(o, l, { flush: \"sync\" });\n  const i = typeof t == \"function\" ? t : t.get, u = typeof t == \"function\" ? void 0 : t.set, d = uo((p, c) => (a = p, s = c, {\n    get() {\n      return r.value && (e = i(), r.value = !1), a(), e;\n    },\n    set(f) {\n      u == null || u(f);\n    }\n  }));\n  return Object.isExtensible(d) && (d.trigger = l), d;\n}\nfunction Ke(o) {\n  return Ia() ? (Aa(o), !0) : !1;\n}\nfunction En(o) {\n  let t = !1, e;\n  const a = gn(!0);\n  return (...s) => (t || (e = a.run(() => o(...s)), t = !0), e);\n}\nfunction Xa(o) {\n  let t = 0, e, a;\n  const s = () => {\n    t -= 1, a && t <= 0 && (a.stop(), e = void 0, a = void 0);\n  };\n  return (...r) => (t += 1, e || (a = gn(!0), e = a.run(() => o(...r))), Ke(s), e);\n}\nfunction ge(o) {\n  return typeof o == \"function\" ? o() : n(o);\n}\nconst _e = typeof window < \"u\" && typeof document < \"u\";\ntypeof WorkerGlobalScope < \"u\" && globalThis instanceof WorkerGlobalScope;\nconst Ja = (o) => typeof o < \"u\", Za = (o) => o != null, Qa = Object.prototype.toString, es = (o) => Qa.call(o) === \"[object Object]\", on = (o, t, e) => Math.min(e, Math.max(t, o)), st = () => {\n}, nn = /* @__PURE__ */ ts();\nfunction ts() {\n  var o, t;\n  return _e && ((o = window == null ? void 0 : window.navigator) == null ? void 0 : o.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\nfunction os(o, t) {\n  function e(...a) {\n    return new Promise((s, r) => {\n      Promise.resolve(o(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(s).catch(r);\n    });\n  }\n  return e;\n}\nfunction ns(o, t = {}) {\n  let e, a, s = st;\n  const r = (i) => {\n    clearTimeout(i), s(), s = st;\n  };\n  return (i) => {\n    const u = ge(o), d = ge(t.maxWait);\n    return e && r(e), u <= 0 || d !== void 0 && d <= 0 ? (a && (r(a), a = null), Promise.resolve(i())) : new Promise((p, c) => {\n      s = t.rejectOnCancel ? c : p, d && !a && (a = setTimeout(() => {\n        e && r(e), a = null, p(i());\n      }, d)), e = setTimeout(() => {\n        a && r(a), a = null, p(i());\n      }, u);\n    });\n  };\n}\nfunction as(o) {\n  return o || Se();\n}\nfunction ss(...o) {\n  if (o.length !== 1)\n    return yn(...o);\n  const t = o[0];\n  return typeof t == \"function\" ? it(uo(() => ({ get: t, set: st }))) : P(t);\n}\nfunction Tt(o, t = 1e4) {\n  return uo((e, a) => {\n    let s = ge(o), r;\n    const l = () => setTimeout(() => {\n      s = ge(o), a();\n    }, ge(t));\n    return Ke(() => {\n      clearTimeout(r);\n    }), {\n      get() {\n        return e(), s;\n      },\n      set(i) {\n        s = i, a(), clearTimeout(r), r = l();\n      }\n    };\n  });\n}\nfunction mo(o, t = 200, e = {}) {\n  return os(\n    ns(t, e),\n    o\n  );\n}\nfunction rs(o, t) {\n  as(t) && co(o, t);\n}\nfunction ho(o, t, e = {}) {\n  const {\n    immediate: a = !0\n  } = e, s = P(!1);\n  let r = null;\n  function l() {\n    r && (clearTimeout(r), r = null);\n  }\n  function i() {\n    s.value = !1, l();\n  }\n  function u(...d) {\n    l(), s.value = !0, r = setTimeout(() => {\n      s.value = !1, r = null, o(...d);\n    }, ge(t));\n  }\n  return a && (s.value = !0, _e && u()), Ke(i), {\n    isPending: it(s),\n    start: u,\n    stop: i\n  };\n}\nfunction ls(o = 1e3, t = {}) {\n  const {\n    controls: e = !1,\n    callback: a\n  } = t, s = ho(\n    a ?? st,\n    o,\n    t\n  ), r = S(() => !s.isPending.value);\n  return e ? {\n    ready: r,\n    ...s\n  } : r;\n}\nfunction is(o, t, e) {\n  const a = U(o, (...s) => (G(() => a()), t(...s)), e);\n  return a;\n}\nfunction pe(o) {\n  var t;\n  const e = ge(o);\n  return (t = e == null ? void 0 : e.$el) != null ? t : e;\n}\nconst Xe = _e ? window : void 0;\nfunction Be(...o) {\n  let t, e, a, s;\n  if (typeof o[0] == \"string\" || Array.isArray(o[0]) ? ([e, a, s] = o, t = Xe) : [t, e, a, s] = o, !t)\n    return st;\n  Array.isArray(e) || (e = [e]), Array.isArray(a) || (a = [a]);\n  const r = [], l = () => {\n    r.forEach((p) => p()), r.length = 0;\n  }, i = (p, c, f, v) => (p.addEventListener(c, f, v), () => p.removeEventListener(c, f, v)), u = U(\n    () => [pe(t), ge(s)],\n    ([p, c]) => {\n      if (l(), !p)\n        return;\n      const f = es(c) ? { ...c } : c;\n      r.push(\n        ...e.flatMap((v) => a.map((g) => i(p, v, g, f)))\n      );\n    },\n    { immediate: !0, flush: \"post\" }\n  ), d = () => {\n    u(), l();\n  };\n  return Ke(d), d;\n}\nfunction us(o) {\n  return typeof o == \"function\" ? o : typeof o == \"string\" ? (t) => t.key === o : Array.isArray(o) ? (t) => o.includes(t.key) : () => !0;\n}\nfunction go(...o) {\n  let t, e, a = {};\n  o.length === 3 ? (t = o[0], e = o[1], a = o[2]) : o.length === 2 ? typeof o[1] == \"object\" ? (t = !0, e = o[0], a = o[1]) : (t = o[0], e = o[1]) : (t = !0, e = o[0]);\n  const {\n    target: s = Xe,\n    eventName: r = \"keydown\",\n    passive: l = !1,\n    dedupe: i = !1\n  } = a, u = us(t);\n  return Be(s, r, (p) => {\n    p.repeat && ge(i) || u(p) && e(p);\n  }, l);\n}\nfunction ds(o = {}) {\n  var t;\n  const {\n    window: e = Xe,\n    deep: a = !0\n  } = o, s = (t = o.document) != null ? t : e == null ? void 0 : e.document, r = () => {\n    var i;\n    let u = s == null ? void 0 : s.activeElement;\n    if (a)\n      for (; u != null && u.shadowRoot; )\n        u = (i = u == null ? void 0 : u.shadowRoot) == null ? void 0 : i.activeElement;\n    return u;\n  }, l = Ya(\n    () => null,\n    () => r()\n  );\n  return e && (Be(e, \"blur\", (i) => {\n    i.relatedTarget === null && l.trigger();\n  }, !0), Be(e, \"focus\", l.trigger, !0)), l;\n}\nfunction Dt() {\n  const o = P(!1), t = Se();\n  return t && q(() => {\n    o.value = !0;\n  }, t), o;\n}\nfunction Pn(o) {\n  const t = Dt();\n  return S(() => (t.value, !!o()));\n}\nfunction cs(o, t = {}) {\n  const {\n    immediate: e = !0,\n    fpsLimit: a = void 0,\n    window: s = Xe\n  } = t, r = P(!1), l = a ? 1e3 / a : null;\n  let i = 0, u = null;\n  function d(f) {\n    if (!r.value || !s)\n      return;\n    i || (i = f);\n    const v = f - i;\n    if (l && v < l) {\n      u = s.requestAnimationFrame(d);\n      return;\n    }\n    i = f, o({ delta: v, timestamp: f }), u = s.requestAnimationFrame(d);\n  }\n  function p() {\n    !r.value && s && (r.value = !0, i = 0, u = s.requestAnimationFrame(d));\n  }\n  function c() {\n    r.value = !1, u != null && s && (s.cancelAnimationFrame(u), u = null);\n  }\n  return e && p(), Ke(c), {\n    isActive: it(r),\n    pause: c,\n    resume: p\n  };\n}\nfunction ps(o) {\n  return JSON.parse(JSON.stringify(o));\n}\nfunction fs(o, t, e = {}) {\n  const { window: a = Xe, ...s } = e;\n  let r;\n  const l = Pn(() => a && \"MutationObserver\" in a), i = () => {\n    r && (r.disconnect(), r = void 0);\n  }, u = S(() => {\n    const f = ge(o), v = (Array.isArray(f) ? f : [f]).map(pe).filter(Za);\n    return new Set(v);\n  }), d = U(\n    () => u.value,\n    (f) => {\n      i(), l.value && a && f.size && (r = new MutationObserver(t), f.forEach((v) => r.observe(v, s)));\n    },\n    { immediate: !0, flush: \"post\" }\n  ), p = () => r == null ? void 0 : r.takeRecords(), c = () => {\n    i(), d();\n  };\n  return Ke(c), {\n    isSupported: l,\n    stop: c,\n    takeRecords: p\n  };\n}\nfunction be(o, t, e = {}) {\n  const { window: a = Xe, ...s } = e;\n  let r;\n  const l = Pn(() => a && \"ResizeObserver\" in a), i = () => {\n    r && (r.disconnect(), r = void 0);\n  }, u = S(() => Array.isArray(o) ? o.map((c) => pe(c)) : [pe(o)]), d = U(\n    u,\n    (c) => {\n      if (i(), l.value && a) {\n        r = new ResizeObserver(t);\n        for (const f of c)\n          f && r.observe(f, s);\n      }\n    },\n    { immediate: !0, flush: \"post\" }\n  ), p = () => {\n    i(), d();\n  };\n  return Ke(p), {\n    isSupported: l,\n    stop: p\n  };\n}\nfunction vs(o, t = {}) {\n  const e = ds(t), a = S(() => pe(o));\n  return { focused: S(() => a.value && e.value ? a.value.contains(e.value) : !1) };\n}\nfunction ms(o, t) {\n  const e = hn(t);\n  return U(\n    ss(o),\n    (a, s) => {\n      e.value = s;\n    },\n    { flush: \"sync\" }\n  ), it(e);\n}\nfunction Y(o, t, e, a = {}) {\n  var s, r, l;\n  const {\n    clone: i = !1,\n    passive: u = !1,\n    eventName: d,\n    deep: p = !1,\n    defaultValue: c,\n    shouldEmit: f\n  } = a, v = Se(), g = e || (v == null ? void 0 : v.emit) || ((s = v == null ? void 0 : v.$emit) == null ? void 0 : s.bind(v)) || ((l = (r = v == null ? void 0 : v.proxy) == null ? void 0 : r.$emit) == null ? void 0 : l.bind(v == null ? void 0 : v.proxy));\n  let w = d;\n  t || (t = \"modelValue\"), w = w || `update:${t.toString()}`;\n  const E = (B) => i ? typeof i == \"function\" ? i(B) : ps(B) : B, _ = () => Ja(o[t]) ? E(o[t]) : c, x = (B) => {\n    f ? f(B) && g(w, B) : g(w, B);\n  };\n  if (u) {\n    const B = _(), O = P(B);\n    let A = !1;\n    return U(\n      () => o[t],\n      (M) => {\n        A || (A = !0, O.value = E(M), G(() => A = !1));\n      }\n    ), U(\n      O,\n      (M) => {\n        !A && (M !== o[t] || p) && x(M);\n      },\n      { deep: p }\n    ), O;\n  } else\n    return S({\n      get() {\n        return _();\n      },\n      set(B) {\n        x(B);\n      }\n    });\n}\nfunction Ot(o) {\n  return o ? o.flatMap((t) => t.type === le ? Ot(t.children) : [t]) : [];\n}\nconst hs = [\"INPUT\", \"TEXTAREA\"];\nfunction Je(o, t, e, a = {}) {\n  if (!t || a.enableIgnoredElement && hs.includes(t.nodeName))\n    return null;\n  const {\n    arrowKeyOptions: s = \"both\",\n    attributeName: r = \"[data-radix-vue-collection-item]\",\n    itemsArray: l = [],\n    loop: i = !0,\n    dir: u = \"ltr\",\n    preventScroll: d = !0,\n    focus: p = !1\n  } = a, [c, f, v, g, w, E] = [\n    o.key === \"ArrowRight\",\n    o.key === \"ArrowLeft\",\n    o.key === \"ArrowUp\",\n    o.key === \"ArrowDown\",\n    o.key === \"Home\",\n    o.key === \"End\"\n  ], _ = v || g, x = c || f;\n  if (!w && !E && (!_ && !x || s === \"vertical\" && x || s === \"horizontal\" && _))\n    return null;\n  const B = e ? Array.from(e.querySelectorAll(r)) : l;\n  if (!B.length)\n    return null;\n  d && o.preventDefault();\n  let O = null;\n  return x || _ ? O = Bn(B, t, {\n    goForward: _ ? g : u === \"ltr\" ? c : f,\n    loop: i\n  }) : w ? O = B.at(0) || null : E && (O = B.at(-1) || null), p && (O == null || O.focus()), O;\n}\nfunction Bn(o, t, { goForward: e, loop: a }, s = o.length) {\n  if (--s === 0)\n    return null;\n  const r = o.indexOf(t), l = e ? r + 1 : r - 1;\n  if (!a && (l < 0 || l >= o.length))\n    return null;\n  const i = (l + o.length) % o.length, u = o[i];\n  return u ? u.hasAttribute(\"disabled\") && u.getAttribute(\"disabled\") !== \"false\" ? Bn(\n    o,\n    u,\n    { goForward: e, loop: a },\n    s\n  ) : u : null;\n}\nfunction Jt(o) {\n  if (o === null || typeof o != \"object\")\n    return !1;\n  const t = Object.getPrototypeOf(o);\n  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in o ? !1 : Symbol.toStringTag in o ? Object.prototype.toString.call(o) === \"[object Module]\" : !0;\n}\nfunction oo(o, t, e = \".\", a) {\n  if (!Jt(t))\n    return oo(o, {}, e, a);\n  const s = Object.assign({}, t);\n  for (const r in o) {\n    if (r === \"__proto__\" || r === \"constructor\")\n      continue;\n    const l = o[r];\n    l != null && (a && a(s, r, l, e) || (Array.isArray(l) && Array.isArray(s[r]) ? s[r] = [...l, ...s[r]] : Jt(l) && Jt(s[r]) ? s[r] = oo(\n      l,\n      s[r],\n      (e ? `${e}.` : \"\") + r.toString(),\n      a\n    ) : s[r] = l));\n  }\n  return s;\n}\nfunction gs(o) {\n  return (...t) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    t.reduce((e, a) => oo(e, a, \"\", o), {})\n  );\n}\nconst ys = gs(), [Sn, bs] = H(\"ConfigProvider\"), eu = /* @__PURE__ */ b({\n  __name: \"ConfigProvider\",\n  props: {\n    dir: { default: \"ltr\" },\n    scrollBody: { type: [Boolean, Object], default: !0 }\n  },\n  setup(o) {\n    const t = o, { dir: e, scrollBody: a } = z(t);\n    return bs({\n      dir: e,\n      scrollBody: a\n    }), (s, r) => y(s.$slots, \"default\");\n  }\n}), Cs = En(() => ({ count: P(0) }));\nfunction te(o) {\n  const { count: t } = Cs();\n  return o || t.value++, o || `radix-${t.value}`;\n}\nconst ws = Xa(() => {\n  const o = P(/* @__PURE__ */ new Map()), t = P(), e = S(() => {\n    for (const l of o.value.values())\n      if (l)\n        return !0;\n    return !1;\n  }), a = Sn({\n    scrollBody: P(!0)\n  });\n  let s = null;\n  const r = () => {\n    document.body.style.paddingRight = \"\", document.body.style.marginRight = \"\", document.body.style.pointerEvents = \"\", document.body.style.removeProperty(\"--scrollbar-width\"), document.body.style.overflow = t.value ?? \"\", nn && (s == null || s()), t.value = void 0;\n  };\n  return U(e, (l, i) => {\n    var c;\n    if (!_e)\n      return;\n    if (!l) {\n      i && r();\n      return;\n    }\n    t.value === void 0 && (t.value = document.body.style.overflow);\n    const u = window.innerWidth - document.documentElement.clientWidth, d = { padding: u, margin: 0 }, p = (c = a.scrollBody) != null && c.value ? typeof a.scrollBody.value == \"object\" ? ys({\n      padding: a.scrollBody.value.padding === !0 ? u : a.scrollBody.value.padding,\n      margin: a.scrollBody.value.margin === !0 ? u : a.scrollBody.value.margin\n    }, d) : d : { padding: 0, margin: 0 };\n    u > 0 && (document.body.style.paddingRight = `${p.padding}px`, document.body.style.marginRight = `${p.margin}px`, document.body.style.setProperty(\"--scrollbar-width\", `${u}px`), document.body.style.overflow = \"hidden\"), nn && (s = Be(\n      document,\n      \"touchmove\",\n      (f) => {\n        var v;\n        f.target === document.documentElement && (f.touches.length > 1 || (v = f.preventDefault) == null || v.call(f));\n      },\n      { passive: !1 }\n    )), G(() => {\n      document.body.style.pointerEvents = \"none\", document.body.style.overflow = \"hidden\";\n    });\n  }, { immediate: !0, flush: \"sync\" }), o;\n});\nfunction ct(o) {\n  const t = te(), e = ws();\n  e.value.set(t, o ?? !1);\n  const a = S({\n    get: () => e.value.get(t) ?? !1,\n    set: (s) => e.value.set(t, s)\n  });\n  return rs(() => {\n    e.value.delete(t);\n  }), a;\n}\nconst _s = \"data-radix-vue-collection-item\";\nfunction ve(o, t = _s) {\n  const e = o ?? Symbol();\n  return { createCollection: (r) => {\n    const l = P([]);\n    function i() {\n      const u = pe(r);\n      return u ? l.value = Array.from(\n        u.querySelectorAll(`[${t}]:not([data-disabled])`)\n      ) : l.value = [];\n    }\n    return Ra(() => {\n      l.value = [];\n    }), q(i), Ma(i), U(() => r == null ? void 0 : r.value, i, { immediate: !0 }), mn(e, l), l;\n  }, injectCollection: () => vn(e, P([])) };\n}\nfunction de(o) {\n  const t = Sn({\n    dir: P(\"ltr\")\n  });\n  return S(() => {\n    var e;\n    return (o == null ? void 0 : o.value) || ((e = t.dir) == null ? void 0 : e.value) || \"ltr\";\n  });\n}\nfunction ce(o) {\n  const t = Se(), e = t == null ? void 0 : t.type.emits, a = {};\n  return e != null && e.length || console.warn(\n    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`\n  ), e == null || e.forEach((s) => {\n    a[ka(bn(s))] = (...r) => o(s, ...r);\n  }), a;\n}\nlet Zt = 0;\nfunction yo() {\n  ee((o) => {\n    if (!_e)\n      return;\n    const t = document.querySelectorAll(\"[data-radix-focus-guard]\");\n    document.body.insertAdjacentElement(\n      \"afterbegin\",\n      t[0] ?? an()\n    ), document.body.insertAdjacentElement(\n      \"beforeend\",\n      t[1] ?? an()\n    ), Zt++, o(() => {\n      Zt === 1 && document.querySelectorAll(\"[data-radix-focus-guard]\").forEach((e) => e.remove()), Zt--;\n    });\n  });\n}\nfunction an() {\n  const o = document.createElement(\"span\");\n  return o.setAttribute(\"data-radix-focus-guard\", \"\"), o.tabIndex = 0, o.style.cssText = \"outline: none; opacity: 0; position: fixed; pointer-events: none\", o;\n}\nfunction Ne(o) {\n  return S(() => {\n    var t;\n    return ge(o) ? !!((t = pe(o)) != null && t.closest(\"form\")) : !0;\n  });\n}\nfunction He(o) {\n  const t = Se(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((s, r) => {\n    const l = (t == null ? void 0 : t.type.props[r]).default;\n    return l !== void 0 && (s[r] = l), s;\n  }, {}), a = yn(o);\n  return S(() => {\n    const s = {}, r = (t == null ? void 0 : t.vnode.props) ?? {};\n    return Object.keys(r).forEach((l) => {\n      s[bn(l)] = r[l];\n    }), Object.keys({ ...e, ...s }).reduce((l, i) => (a.value[i] !== void 0 && (l[i] = a.value[i]), l), {});\n  });\n}\nfunction ae(o, t) {\n  const e = He(o), a = t ? ce(t) : {};\n  return S(() => ({\n    ...e.value,\n    ...a\n  }));\n}\nfunction $() {\n  const o = Se(), t = P(), e = S(() => {\n    var l, i;\n    return [\"#text\", \"#comment\"].includes((l = t.value) == null ? void 0 : l.$el.nodeName) ? (i = t.value) == null ? void 0 : i.$el.nextElementSibling : pe(t);\n  }), a = Object.assign({}, o.exposed), s = {};\n  for (const l in o.props)\n    Object.defineProperty(s, l, {\n      enumerable: !0,\n      configurable: !0,\n      get: () => o.props[l]\n    });\n  if (Object.keys(a).length > 0)\n    for (const l in a)\n      Object.defineProperty(s, l, {\n        enumerable: !0,\n        configurable: !0,\n        get: () => a[l]\n      });\n  Object.defineProperty(s, \"$el\", {\n    enumerable: !0,\n    configurable: !0,\n    get: () => o.vnode.el\n  }), o.exposed = s;\n  function r(l) {\n    t.value = l, !(l instanceof Element || !l) && (Object.defineProperty(s, \"$el\", {\n      enumerable: !0,\n      configurable: !0,\n      get: () => l.$el\n    }), o.exposed = s);\n  }\n  return { forwardRef: r, currentRef: t, currentElement: e };\n}\nvar $s = function(o) {\n  if (typeof document > \"u\")\n    return null;\n  var t = Array.isArray(o) ? o[0] : o;\n  return t.ownerDocument.body;\n}, qe = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), bt = {}, Qt = 0, Tn = function(o) {\n  return o && (o.host || Tn(o.parentNode));\n}, xs = function(o, t) {\n  return t.map(function(e) {\n    if (o.contains(e))\n      return e;\n    var a = Tn(e);\n    return a && o.contains(a) ? a : (console.error(\"aria-hidden\", e, \"in not contained inside\", o, \". Doing nothing\"), null);\n  }).filter(function(e) {\n    return !!e;\n  });\n}, Es = function(o, t, e, a) {\n  var s = xs(t, Array.isArray(o) ? o : [o]);\n  bt[e] || (bt[e] = /* @__PURE__ */ new WeakMap());\n  var r = bt[e], l = [], i = /* @__PURE__ */ new Set(), u = new Set(s), d = function(c) {\n    !c || i.has(c) || (i.add(c), d(c.parentNode));\n  };\n  s.forEach(d);\n  var p = function(c) {\n    !c || u.has(c) || Array.prototype.forEach.call(c.children, function(f) {\n      if (i.has(f))\n        p(f);\n      else {\n        var v = f.getAttribute(a), g = v !== null && v !== \"false\", w = (qe.get(f) || 0) + 1, E = (r.get(f) || 0) + 1;\n        qe.set(f, w), r.set(f, E), l.push(f), w === 1 && g && yt.set(f, !0), E === 1 && f.setAttribute(e, \"true\"), g || f.setAttribute(a, \"true\");\n      }\n    });\n  };\n  return p(t), i.clear(), Qt++, function() {\n    l.forEach(function(c) {\n      var f = qe.get(c) - 1, v = r.get(c) - 1;\n      qe.set(c, f), r.set(c, v), f || (yt.has(c) || c.removeAttribute(a), yt.delete(c)), v || c.removeAttribute(e);\n    }), Qt--, Qt || (qe = /* @__PURE__ */ new WeakMap(), qe = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), bt = {});\n  };\n}, Ps = function(o, t, e) {\n  e === void 0 && (e = \"data-aria-hidden\");\n  var a = Array.from(Array.isArray(o) ? o : [o]), s = t || $s(o);\n  return s ? (a.push.apply(a, Array.from(s.querySelectorAll(\"[aria-live]\"))), Es(a, s, e, \"aria-hidden\")) : function() {\n    return null;\n  };\n};\nfunction pt(o) {\n  let t;\n  U(() => pe(o), (e) => {\n    e ? t = Ps(e) : t && t();\n  }), fe(() => {\n    t && t();\n  });\n}\nfunction Dn(o) {\n  const t = P(), e = S(() => {\n    var s;\n    return ((s = t.value) == null ? void 0 : s.width) ?? 0;\n  }), a = S(() => {\n    var s;\n    return ((s = t.value) == null ? void 0 : s.height) ?? 0;\n  });\n  return q(() => {\n    const s = pe(o);\n    if (s) {\n      t.value = { width: s.offsetWidth, height: s.offsetHeight };\n      const r = new ResizeObserver((l) => {\n        if (!Array.isArray(l) || !l.length)\n          return;\n        const i = l[0];\n        let u, d;\n        if (\"borderBoxSize\" in i) {\n          const p = i.borderBoxSize, c = Array.isArray(p) ? p[0] : p;\n          u = c.inlineSize, d = c.blockSize;\n        } else\n          u = s.offsetWidth, d = s.offsetHeight;\n        t.value = { width: u, height: d };\n      });\n      return r.observe(s, { box: \"border-box\" }), () => r.unobserve(s);\n    } else\n      t.value = void 0;\n  }), {\n    width: e,\n    height: a\n  };\n}\nfunction On(o, t) {\n  const e = P(o);\n  function a(r) {\n    return t[e.value][r] ?? e.value;\n  }\n  return {\n    state: e,\n    dispatch: (r) => {\n      e.value = a(r);\n    }\n  };\n}\nfunction bo(o) {\n  const t = Tt(\"\", 1e3);\n  return {\n    search: t,\n    handleTypeaheadSearch: (s) => {\n      var c, f;\n      t.value = t.value + s;\n      const r = o.value, l = document.activeElement, i = ((f = (c = r.find((v) => v === l)) == null ? void 0 : c.textContent) == null ? void 0 : f.trim()) ?? \"\", u = r.map((v) => {\n        var g;\n        return ((g = v.textContent) == null ? void 0 : g.trim()) ?? \"\";\n      }), d = Bs(u, t.value, i), p = r.find(\n        (v) => {\n          var g;\n          return ((g = v.textContent) == null ? void 0 : g.trim()) === d;\n        }\n      );\n      p && p.focus();\n    },\n    resetTypeahead: () => {\n      t.value = \"\";\n    }\n  };\n}\nfunction Co(o, t) {\n  return o.map((e, a) => o[(t + a) % o.length]);\n}\nfunction Bs(o, t, e) {\n  const s = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, r = e ? o.indexOf(e) : -1;\n  let l = Co(o, Math.max(r, 0));\n  s.length === 1 && (l = l.filter((d) => d !== e));\n  const u = l.find(\n    (d) => d.toLowerCase().startsWith(s.toLowerCase())\n  );\n  return u !== e ? u : void 0;\n}\nfunction tu(o, t) {\n  return {\n    inheritAttrs: !1,\n    name: `${o.__name ?? \"\"}Wrapper`,\n    setup(e, a) {\n      return () => {\n        const s = typeof (t == null ? void 0 : t.props) == \"function\" ? t == null ? void 0 : t.props(a.attrs) : t == null ? void 0 : t.props, { forwardRef: r } = $(), l = T(s, a.attrs);\n        return Ve(o, { ...l, ref: r }, a.slots);\n      };\n    }\n  };\n}\nconst wo = b({\n  name: \"PrimitiveSlot\",\n  inheritAttrs: !1,\n  setup(o, { attrs: t, slots: e }) {\n    return () => {\n      var l, i;\n      if (!e.default)\n        return null;\n      const a = Ot(e.default()), [s, ...r] = a;\n      if (Object.keys(t).length > 0) {\n        (l = s.props) == null || delete l.ref;\n        const u = T(t, s.props ?? {});\n        t.class && ((i = s.props) != null && i.class) && delete s.props.class;\n        const d = Va(s, u);\n        for (const p in u)\n          p.startsWith(\"on\") && (d.props || (d.props = {}), d.props[p] = u[p]);\n        return a.length === 1 ? d : [d, ...r];\n      }\n      return a;\n    };\n  }\n}), D = b({\n  name: \"Primitive\",\n  inheritAttrs: !1,\n  props: {\n    asChild: {\n      type: Boolean,\n      default: !1\n    },\n    as: {\n      type: [String, Object],\n      default: \"div\"\n    }\n  },\n  setup(o, { attrs: t, slots: e }) {\n    return (o.asChild ? \"template\" : o.as) !== \"template\" ? () => Ve(o.as, t, { default: e.default }) : () => Ve(wo, t, { default: e.default });\n  }\n});\nfunction In() {\n  const o = P(), t = S(() => {\n    var e, a;\n    return [\"#text\", \"#comment\"].includes((e = o.value) == null ? void 0 : e.$el.nodeName) ? (a = o.value) == null ? void 0 : a.$el.nextElementSibling : pe(o);\n  });\n  return {\n    primitiveElement: o,\n    currentElement: t\n  };\n}\nconst [An, Ss] = H(\"CollapsibleRoot\"), Ts = /* @__PURE__ */ b({\n  __name: \"CollapsibleRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:open\"],\n  setup(o, { expose: t, emit: e }) {\n    const a = o, r = Y(a, \"open\", e, {\n      defaultValue: a.defaultOpen,\n      passive: a.open === void 0\n    }), l = Y(a, \"disabled\");\n    return Ss({\n      contentId: te(),\n      disabled: l,\n      open: r,\n      onOpenToggle: () => {\n        r.value = !r.value;\n      }\n    }), t({ open: r }), $(), (i, u) => (h(), C(n(D), {\n      as: i.as,\n      \"as-child\": a.asChild,\n      \"data-state\": a.open ? \"open\" : \"closed\",\n      \"data-disabled\": a.disabled ? \"\" : void 0\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\", { open: n(r) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"]));\n  }\n}), Ds = /* @__PURE__ */ b({\n  __name: \"CollapsibleTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = An();\n    return (a, s) => {\n      var r, l;\n      return h(), C(n(D), {\n        type: a.as === \"button\" ? \"button\" : void 0,\n        as: a.as,\n        \"as-child\": t.asChild,\n        \"aria-controls\": n(e).contentId,\n        \"aria-expanded\": n(e).open.value,\n        \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": (r = n(e).disabled) != null && r.value ? \"\" : void 0,\n        disabled: (l = n(e).disabled) == null ? void 0 : l.value,\n        onClick: n(e).onOpenToggle\n      }, {\n        default: m(() => [\n          y(a.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"type\", \"as\", \"as-child\", \"aria-controls\", \"aria-expanded\", \"data-state\", \"data-disabled\", \"disabled\", \"onClick\"]);\n    };\n  }\n});\nfunction Os(o, t) {\n  const e = P({}), a = P(\"none\"), s = o.value ? \"mounted\" : \"unmounted\", { state: r, dispatch: l } = On(s, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  });\n  U(\n    o,\n    async (f, v) => {\n      var w;\n      const g = v !== f;\n      if (await G(), g) {\n        const E = a.value, _ = Ct(t.value);\n        f ? l(\"MOUNT\") : _ === \"none\" || ((w = e.value) == null ? void 0 : w.display) === \"none\" ? l(\"UNMOUNT\") : l(v && E !== _ ? \"ANIMATION_OUT\" : \"UNMOUNT\");\n      }\n    },\n    { immediate: !0 }\n  );\n  const i = (f) => {\n    const v = Ct(t.value), g = v.includes(\n      f.animationName\n    );\n    f.target === t.value && g && l(\"ANIMATION_END\"), f.target === t.value && v === \"none\" && l(\"ANIMATION_END\");\n  }, u = (f) => {\n    f.target === t.value && (a.value = Ct(t.value));\n  }, d = U(\n    t,\n    (f, v) => {\n      f ? (e.value = getComputedStyle(f), f.addEventListener(\"animationstart\", u), f.addEventListener(\"animationcancel\", i), f.addEventListener(\"animationend\", i)) : (l(\"ANIMATION_END\"), v == null || v.removeEventListener(\"animationstart\", u), v == null || v.removeEventListener(\"animationcancel\", i), v == null || v.removeEventListener(\"animationend\", i));\n    },\n    { immediate: !0 }\n  ), p = U(r, () => {\n    const f = Ct(t.value);\n    a.value = r.value === \"mounted\" ? f : \"none\";\n  });\n  return fe(() => {\n    d(), p();\n  }), {\n    isPresent: S(\n      () => [\"mounted\", \"unmountSuspended\"].includes(r.value)\n    )\n  };\n}\nfunction Ct(o) {\n  return o && getComputedStyle(o).animationName || \"none\";\n}\nconst se = b({\n  name: \"Presence\",\n  props: {\n    present: {\n      type: Boolean,\n      required: !0\n    },\n    forceMount: {\n      type: Boolean\n    }\n  },\n  slots: {},\n  setup(o, { slots: t, expose: e }) {\n    var d;\n    const { present: a, forceMount: s } = z(o), r = P(), { isPresent: l } = Os(a, r);\n    e({ present: l });\n    let i = t.default({ present: l });\n    i = Ot(i || []);\n    const u = Se();\n    if (i && (i == null ? void 0 : i.length) > 1) {\n      const p = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : \"component\";\n      throw new Error(\n        [\n          `Detected an invalid children for \\`${p}\\` for  \\`Presence\\` component.`,\n          \"\",\n          \"Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.\",\n          \"You can apply a few solutions:\",\n          [\n            \"Provide a single child element so that `presence` directive attach correctly.\",\n            \"Ensure the first child is an actual element instead of a raw text node or comment node.\"\n          ].map((c) => `  - ${c}`).join(`\n`)\n        ].join(`\n`)\n      );\n    }\n    return () => s.value || a.value || l.value ? Ve(t.default({ present: l })[0], {\n      ref: (p) => {\n        const c = pe(p);\n        return typeof (c == null ? void 0 : c.hasAttribute) > \"u\" || (c != null && c.hasAttribute(\"data-radix-popper-content-wrapper\") ? r.value = c.firstElementChild : r.value = c), c;\n      }\n    }) : null;\n  }\n}), Is = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"CollapsibleContent\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = An(), a = P(), { forwardRef: s, currentElement: r } = $(), l = P(0), i = P(0), u = S(() => e.open.value), d = P(u.value), p = P();\n    return U(\n      () => {\n        var c;\n        return [u.value, (c = a.value) == null ? void 0 : c.present];\n      },\n      async () => {\n        await G();\n        const c = r.value;\n        if (!c)\n          return;\n        p.value = p.value || {\n          transitionDuration: c.style.transitionDuration,\n          animationName: c.style.animationName\n        }, c.style.transitionDuration = \"0s\", c.style.animationName = \"none\";\n        const f = c.getBoundingClientRect();\n        i.value = f.height, l.value = f.width, d.value || (c.style.transitionDuration = p.value.transitionDuration, c.style.animationName = p.value.animationName);\n      },\n      {\n        immediate: !0\n      }\n    ), q(() => {\n      requestAnimationFrame(() => {\n        d.value = !1;\n      });\n    }), (c, f) => (h(), C(n(se), {\n      ref_key: \"presentRef\",\n      ref: a,\n      present: c.forceMount || n(e).open.value,\n      \"force-mount\": !0\n    }, {\n      default: m(() => {\n        var v, g;\n        return [\n          k(n(D), T(c.$attrs, {\n            id: n(e).contentId,\n            ref: n(s),\n            \"as-child\": t.asChild,\n            as: c.as,\n            \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n            \"data-disabled\": (v = n(e).disabled) != null && v.value ? \"\" : void 0,\n            hidden: !((g = a.value) != null && g.present),\n            style: {\n              \"--radix-collapsible-content-height\": `${i.value}px`,\n              \"--radix-collapsible-content-width\": `${l.value}px`\n            }\n          }), {\n            default: m(() => {\n              var w;\n              return [\n                (w = a.value) != null && w.present ? y(c.$slots, \"default\", { key: 0 }) : X(\"\", !0)\n              ];\n            }),\n            _: 3\n          }, 16, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-disabled\", \"hidden\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction As(o, t) {\n  if (o === \"single\") {\n    if (Array.isArray(t)) {\n      console.error(`Invalid prop \\`value\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`single\\`. The \\`value\\` prop must be:\n  - a string\n  - \\`undefined\\`\n\nIf you want to use multiple values, use the \\`AccordionRoot\\` with type \\`multiple\\`.\n\nDefaulting to \\`undefined\\`.`);\n      return;\n    }\n  } else if (o === \"multiple\" && (typeof t == \"string\" || typeof t > \"u\"))\n    return console.error(`Invalid prop \\`value\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`multiple\\`. The \\`value\\` prop must be:\n- an array of strings\n- empty array (\\`[]\\`)\n\nIf you want to use just one value, use the \\`AccordionRoot\\` with type \\`single\\`.\n\nDefaulting to empty array (\\`[]\\`).`), [];\n  return t;\n}\nfunction Rs({ type: o, defaultValue: t }) {\n  if (o === \"multiple\")\n    return Array.isArray(t) ? t : t === void 0 ? [] : (console.error(\n      `Invalid prop \\`defaultValue\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`multiple\\`. The \\`defaultValue\\` prop must be:\n  - an array of strings\n  - empty array (\\`[]\\`)\n\nIf you want to use just one value, use the \\`AccordionRoot\\` with type \\`single\\`.\n\nDefaulting to empty array (\\`[]\\`).`\n    ), []);\n  if (o === \"single\") {\n    if (typeof t == \"string\")\n      return t;\n    if (t === void 0)\n      return;\n    console.error(\n      `Invalid prop \\`defaultValue\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`single\\`. The \\`defaultValue\\` prop must be:\n  - a string\n  - \\`undefined\\`\n\nDefaulting to \\`undefined\\`.`\n    );\n    return;\n  }\n}\nfunction Rn(o, t) {\n  const e = Y(o, \"modelValue\", t, {\n    defaultValue: Rs(o),\n    passive: o.modelValue === void 0\n  });\n  U(\n    () => [o.type, o.modelValue],\n    () => {\n      const s = As(o.type, e.value);\n      e.value !== s && (e.value = s);\n    },\n    { immediate: !0 }\n  );\n  function a(s) {\n    if (o.type === \"single\")\n      e.value = s === e.value ? void 0 : s;\n    else {\n      const r = e.value || [];\n      if (r.includes(s)) {\n        const l = r.findIndex((i) => i === s);\n        r.splice(l, 1);\n      } else\n        r.push(s);\n      e.value = r, t(\"update:modelValue\", e.value);\n    }\n  }\n  return {\n    modelValue: e,\n    changeModelValue: a\n  };\n}\nconst [It, Ms] = H(\"AccordionRoot\"), ou = /* @__PURE__ */ b({\n  __name: \"AccordionRoot\",\n  props: {\n    type: {},\n    modelValue: {},\n    defaultValue: {},\n    collapsible: { type: Boolean, default: !1 },\n    disabled: { type: Boolean, default: !1 },\n    dir: {},\n    orientation: { default: \"vertical\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { dir: s, disabled: r } = z(e), l = de(s), { modelValue: i, changeModelValue: u } = Rn(e, a), { forwardRef: d, currentElement: p } = $();\n    return Ms({\n      disabled: r,\n      direction: l,\n      orientation: e.orientation,\n      parentElement: p,\n      isSingle: S(() => e.type === \"single\"),\n      collapsible: e.collapsible,\n      modelValue: i,\n      changeModelValue: u\n    }), (c, f) => (h(), C(n(D), {\n      ref: n(d),\n      \"as-child\": c.asChild,\n      as: c.as\n    }, {\n      default: m(() => [\n        y(c.$slots, \"default\", { modelValue: n(i) })\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), [_o, ks] = H(\"AccordionItem\"), nu = /* @__PURE__ */ b({\n  __name: \"AccordionItem\",\n  props: {\n    disabled: { type: Boolean },\n    value: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o, { expose: t }) {\n    const e = o, a = It(), s = S(\n      () => a.isSingle.value ? e.value === a.modelValue.value : Array.isArray(a.modelValue.value) && a.modelValue.value.includes(e.value)\n    ), r = S(() => a.disabled.value || e.disabled || a.isSingle.value && s.value && !a.collapsible), l = S(() => r.value ? \"\" : void 0), i = S(\n      () => s.value ? \"open\" : \"closed\"\n      /* Closed */\n    );\n    t({ open: s, dataDisabled: l });\n    const { currentRef: u, currentElement: d } = $();\n    ks({\n      open: s,\n      dataState: i,\n      disabled: r,\n      dataDisabled: l,\n      triggerId: te(),\n      currentRef: u,\n      currentElement: d,\n      value: S(() => e.value)\n    });\n    function p(c) {\n      Je(\n        c,\n        d.value,\n        a.parentElement.value,\n        {\n          arrowKeyOptions: a.orientation,\n          dir: a.direction.value,\n          focus: !0\n        }\n      );\n    }\n    return (c, f) => (h(), C(n(Ts), {\n      \"data-orientation\": n(a).orientation,\n      \"data-disabled\": l.value,\n      \"data-state\": i.value,\n      disabled: r.value,\n      open: s.value,\n      \"as-child\": e.asChild,\n      onKeydown: ie(p, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\"])\n    }, {\n      default: m(() => [\n        y(c.$slots, \"default\", { open: s.value })\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"data-disabled\", \"data-state\", \"disabled\", \"open\", \"as-child\"]));\n  }\n}), au = /* @__PURE__ */ b({\n  __name: \"AccordionContent\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = It(), a = _o();\n    return $(), (s, r) => (h(), C(n(Is), {\n      role: \"region\",\n      open: n(a).open.value,\n      hidden: !n(a).open.value,\n      \"as-child\": t.asChild,\n      \"aria-labelledby\": n(a).triggerId,\n      \"data-state\": n(a).dataState.value,\n      \"data-disabled\": n(a).dataDisabled.value,\n      \"data-orientation\": n(e).orientation,\n      style: { \"--radix-accordion-content-width\": \"var(--radix-collapsible-content-width)\", \"--radix-accordion-content-height\": \"var(--radix-collapsible-content-height)\" }\n    }, {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"hidden\", \"as-child\", \"aria-labelledby\", \"data-state\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), su = /* @__PURE__ */ b({\n  __name: \"AccordionHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h3\" }\n  },\n  setup(o) {\n    const t = o, e = It(), a = _o();\n    return $(), (s, r) => (h(), C(n(D), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-orientation\": n(e).orientation,\n      \"data-state\": n(a).dataState.value,\n      \"data-disabled\": n(a).dataDisabled.value\n    }, {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"data-state\", \"data-disabled\"]));\n  }\n}), ru = /* @__PURE__ */ b({\n  __name: \"AccordionTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = It(), a = _o();\n    function s() {\n      a.disabled.value || e.changeModelValue(a.value.value);\n    }\n    return (r, l) => (h(), C(n(Ds), {\n      id: n(a).triggerId,\n      ref: n(a).currentRef,\n      \"data-radix-vue-collection-item\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"aria-disabled\": n(a).disabled.value || void 0,\n      \"aria-expanded\": n(a).open.value || !1,\n      \"data-disabled\": n(a).dataDisabled.value,\n      \"data-orientation\": n(e).orientation,\n      \"data-state\": n(a).dataState.value,\n      disabled: n(a).disabled.value,\n      onClick: s\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"as\", \"as-child\", \"aria-disabled\", \"aria-expanded\", \"data-disabled\", \"data-orientation\", \"data-state\", \"disabled\"]));\n  }\n}), [ye, Vs] = H(\"DialogRoot\"), Fs = /* @__PURE__ */ b({\n  __name: \"DialogRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean, default: !1 },\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, s = Y(e, \"open\", t, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = P(), l = P(), { modal: i } = z(e);\n    return Vs({\n      open: s,\n      modal: i,\n      openModal: () => {\n        s.value = !0;\n      },\n      onOpenChange: (u) => {\n        s.value = u;\n      },\n      onOpenToggle: () => {\n        s.value = !s.value;\n      },\n      contentId: te(),\n      titleId: te(),\n      descriptionId: te(),\n      triggerElement: r,\n      contentElement: l\n    }), (u, d) => y(u.$slots, \"default\");\n  }\n}), Ls = /* @__PURE__ */ b({\n  __name: \"DialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = ye(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.triggerElement = s;\n    }), (r, l) => (h(), C(n(D), T(t, {\n      ref: n(a),\n      type: r.as === \"button\" ? \"button\" : void 0,\n      \"aria-haspopup\": \"dialog\",\n      \"aria-expanded\": n(e).open.value || !1,\n      \"aria-controls\": n(e).contentId,\n      \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n      onClick: n(e).onOpenToggle\n    }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"onClick\"]));\n  }\n}), Te = /* @__PURE__ */ b({\n  __name: \"Teleport\",\n  props: {\n    to: { default: \"body\" },\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = Dt();\n    return (e, a) => n(t) || e.forceMount ? (h(), C(Ye, {\n      key: 0,\n      to: e.to,\n      disabled: e.disabled\n    }, [\n      y(e.$slots, \"default\")\n    ], 8, [\"to\", \"disabled\"])) : X(\"\", !0);\n  }\n}), lu = /* @__PURE__ */ b({\n  __name: \"DialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ks = \"dismissableLayer.pointerDownOutside\", Ns = \"dismissableLayer.focusOutside\";\nfunction Mn(o, t) {\n  const e = t.closest(\n    \"[data-dismissable-layer]\"\n  ), a = o.querySelector(\n    \"[data-dismissable-layer]\"\n  ), s = Array.from(\n    o.ownerDocument.querySelectorAll(\"[data-dismissable-layer]\")\n  );\n  return !!(e && a === e || s.indexOf(a) < s.indexOf(e));\n}\nfunction Hs(o, t) {\n  var r;\n  const e = ((r = t == null ? void 0 : t.value) == null ? void 0 : r.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), a = P(!1), s = P(() => {\n  });\n  return ee((l) => {\n    if (!_e)\n      return;\n    const i = async (d) => {\n      const p = d.target;\n      if (t != null && t.value) {\n        if (Mn(t.value, p)) {\n          a.value = !1;\n          return;\n        }\n        if (d.target && !a.value) {\n          let c = function() {\n            vo(\n              Ks,\n              o,\n              f\n            );\n          };\n          const f = { originalEvent: d };\n          d.pointerType === \"touch\" ? (e.removeEventListener(\"click\", s.value), s.value = c, e.addEventListener(\"click\", s.value, {\n            once: !0\n          })) : c();\n        } else\n          e.removeEventListener(\"click\", s.value);\n        a.value = !1;\n      }\n    }, u = window.setTimeout(() => {\n      e.addEventListener(\"pointerdown\", i);\n    }, 0);\n    l(() => {\n      window.clearTimeout(u), e.removeEventListener(\"pointerdown\", i), e.removeEventListener(\"click\", s.value);\n    });\n  }), {\n    onPointerDownCapture: () => a.value = !0\n  };\n}\nfunction js(o, t) {\n  var s;\n  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), a = P(!1);\n  return ee((r) => {\n    if (!_e)\n      return;\n    const l = async (i) => {\n      t != null && t.value && (await G(), !(!t.value || Mn(t.value, i.target)) && i.target && !a.value && vo(\n        Ns,\n        o,\n        { originalEvent: i }\n      ));\n    };\n    e.addEventListener(\"focusin\", l), r(() => e.removeEventListener(\"focusin\", l));\n  }), {\n    onFocusCapture: () => a.value = !0,\n    onBlurCapture: () => a.value = !1\n  };\n}\nconst he = Cn({\n  layersRoot: /* @__PURE__ */ new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),\n  branches: /* @__PURE__ */ new Set()\n}), De = /* @__PURE__ */ b({\n  __name: \"DismissableLayer\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { forwardRef: s, currentElement: r } = $(), l = S(\n      () => {\n        var g;\n        return ((g = r.value) == null ? void 0 : g.ownerDocument) ?? globalThis.document;\n      }\n    ), i = S(() => he.layersRoot), u = S(() => r.value ? Array.from(i.value).indexOf(r.value) : -1), d = S(() => he.layersWithOutsidePointerEventsDisabled.size > 0), p = S(() => {\n      const g = Array.from(i.value), [w] = [...he.layersWithOutsidePointerEventsDisabled].slice(-1), E = g.indexOf(w);\n      return u.value >= E;\n    }), c = Hs(async (g) => {\n      const w = [...he.branches].some(\n        (E) => E.contains(g.target)\n      );\n      !p.value || w || (a(\"pointerDownOutside\", g), a(\"interactOutside\", g), await G(), g.defaultPrevented || a(\"dismiss\"));\n    }, r), f = js((g) => {\n      [...he.branches].some(\n        (E) => E.contains(g.target)\n      ) || (a(\"focusOutside\", g), a(\"interactOutside\", g), g.defaultPrevented || a(\"dismiss\"));\n    }, r);\n    go(\"Escape\", (g) => {\n      u.value === i.value.size - 1 && (a(\"escapeKeyDown\", g), g.defaultPrevented || a(\"dismiss\"));\n    });\n    let v;\n    return ee((g) => {\n      r.value && (e.disableOutsidePointerEvents && (he.layersWithOutsidePointerEventsDisabled.size === 0 && (v = l.value.body.style.pointerEvents, l.value.body.style.pointerEvents = \"none\"), he.layersWithOutsidePointerEventsDisabled.add(r.value)), i.value.add(r.value), g(() => {\n        e.disableOutsidePointerEvents && he.layersWithOutsidePointerEventsDisabled.size === 1 && (l.value.body.style.pointerEvents = v);\n      }));\n    }), ee((g) => {\n      g(() => {\n        r.value && (i.value.delete(r.value), he.layersWithOutsidePointerEventsDisabled.delete(r.value));\n      });\n    }), (g, w) => (h(), C(n(D), {\n      ref: n(s),\n      \"as-child\": g.asChild,\n      as: g.as,\n      \"data-dismissable-layer\": \"\",\n      style: re({\n        pointerEvents: d.value ? p.value ? \"auto\" : \"none\" : void 0\n      }),\n      onFocusCapture: n(f).onFocusCapture,\n      onBlurCapture: n(f).onBlurCapture,\n      onPointerdownCapture: n(c).onPointerDownCapture\n    }, {\n      default: m(() => [\n        y(g.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"style\", \"onFocusCapture\", \"onBlurCapture\", \"onPointerdownCapture\"]));\n  }\n}), Ws = /* @__PURE__ */ b({\n  __name: \"DismissableLayerBranch\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { forwardRef: e, currentElement: a } = $();\n    return q(() => {\n      he.branches.add(a.value);\n    }), fe(() => {\n      he.branches.delete(a.value);\n    }), (s, r) => (h(), C(n(D), T({ ref: n(e) }, t), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), eo = \"focusScope.autoFocusOnMount\", to = \"focusScope.autoFocusOnUnmount\", sn = { bubbles: !1, cancelable: !0 };\nfunction xt(o, { select: t = !1 } = {}) {\n  const e = document.activeElement;\n  for (const a of o)\n    if (Pe(a, { select: t }), document.activeElement !== e)\n      return !0;\n}\nfunction zs(o) {\n  const t = $o(o), e = rn(t, o), a = rn(t.reverse(), o);\n  return [e, a];\n}\nfunction $o(o) {\n  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (a) => {\n      const s = a.tagName === \"INPUT\" && a.type === \"hidden\";\n      return a.disabled || a.hidden || s ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); )\n    t.push(e.currentNode);\n  return t;\n}\nfunction rn(o, t) {\n  for (const e of o)\n    if (!Us(e, { upTo: t }))\n      return e;\n}\nfunction Us(o, { upTo: t }) {\n  if (getComputedStyle(o).visibility === \"hidden\")\n    return !0;\n  for (; o; ) {\n    if (t !== void 0 && o === t)\n      return !1;\n    if (getComputedStyle(o).display === \"none\")\n      return !0;\n    o = o.parentElement;\n  }\n  return !1;\n}\nfunction qs(o) {\n  return o instanceof HTMLInputElement && \"select\" in o;\n}\nfunction Pe(o, { select: t = !1 } = {}) {\n  if (o && o.focus) {\n    const e = document.activeElement;\n    o.focus({ preventScroll: !0 }), o !== e && qs(o) && t && o.select();\n  }\n}\nconst Gs = En(() => P([]));\nfunction Ys() {\n  const o = Gs();\n  return {\n    add(t) {\n      const e = o.value[0];\n      t !== e && (e == null || e.pause()), o.value = ln(o.value, t), o.value.unshift(t);\n    },\n    remove(t) {\n      var e;\n      o.value = ln(o.value, t), (e = o.value[0]) == null || e.resume();\n    }\n  };\n}\nfunction ln(o, t) {\n  const e = [...o], a = e.indexOf(t);\n  return a !== -1 && e.splice(a, 1), e;\n}\nfunction Xs(o) {\n  return o.filter((t) => t.tagName !== \"A\");\n}\nconst At = /* @__PURE__ */ b({\n  __name: \"FocusScope\",\n  props: {\n    loop: { type: Boolean, default: !1 },\n    trapped: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"mountAutoFocus\", \"unmountAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { currentRef: s, currentElement: r } = $(), l = P(null), i = Ys(), u = Cn({\n      paused: !1,\n      pause() {\n        this.paused = !0;\n      },\n      resume() {\n        this.paused = !1;\n      }\n    });\n    ee((p) => {\n      if (!_e)\n        return;\n      const c = r.value;\n      if (!e.trapped)\n        return;\n      function f(E) {\n        if (u.paused || !c)\n          return;\n        const _ = E.target;\n        c.contains(_) ? l.value = _ : Pe(l.value, { select: !0 });\n      }\n      function v(E) {\n        if (u.paused || !c)\n          return;\n        const _ = E.relatedTarget;\n        _ !== null && (c.contains(_) || Pe(l.value, { select: !0 }));\n      }\n      function g(E) {\n        c.contains(l.value) || Pe(c);\n      }\n      document.addEventListener(\"focusin\", f), document.addEventListener(\"focusout\", v);\n      const w = new MutationObserver(g);\n      c && w.observe(c, { childList: !0, subtree: !0 }), p(() => {\n        document.removeEventListener(\"focusin\", f), document.removeEventListener(\"focusout\", v), w.disconnect();\n      });\n    }), ee(async (p) => {\n      const c = r.value;\n      if (await G(), !c)\n        return;\n      i.add(u);\n      const f = document.activeElement;\n      if (!c.contains(f)) {\n        const g = new CustomEvent(eo, sn);\n        c.addEventListener(\n          eo,\n          (w) => a(\"mountAutoFocus\", w)\n        ), c.dispatchEvent(g), g.defaultPrevented || (xt(Xs($o(c)), {\n          select: !0\n        }), document.activeElement === f && Pe(c));\n      }\n      p(() => {\n        c.removeEventListener(\n          eo,\n          (E) => a(\"mountAutoFocus\", E)\n        );\n        const g = new CustomEvent(to, sn), w = (E) => {\n          a(\"unmountAutoFocus\", E);\n        };\n        c.addEventListener(to, w), c.dispatchEvent(g), setTimeout(() => {\n          g.defaultPrevented || Pe(f ?? document.body, { select: !0 }), c.removeEventListener(to, w), i.remove(u);\n        }, 0);\n      });\n    });\n    function d(p) {\n      if (!e.loop && !e.trapped || u.paused)\n        return;\n      const c = p.key === \"Tab\" && !p.altKey && !p.ctrlKey && !p.metaKey, f = document.activeElement;\n      if (c && f) {\n        const v = p.currentTarget, [g, w] = zs(v);\n        g && w ? !p.shiftKey && f === w ? (p.preventDefault(), e.loop && Pe(g, { select: !0 })) : p.shiftKey && f === g && (p.preventDefault(), e.loop && Pe(w, { select: !0 })) : f === v && p.preventDefault();\n      }\n    }\n    return (p, c) => (h(), C(n(D), {\n      ref_key: \"currentRef\",\n      ref: s,\n      tabindex: \"-1\",\n      \"as-child\": p.asChild,\n      as: p.as,\n      onKeydown: d\n    }, {\n      default: m(() => [\n        y(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), Js = \"menu.itemSelect\", no = [\"Enter\", \" \"], Zs = [\"ArrowDown\", \"PageUp\", \"Home\"], kn = [\"ArrowUp\", \"PageDown\", \"End\"], Qs = [...Zs, ...kn], er = {\n  ltr: [...no, \"ArrowRight\"],\n  rtl: [...no, \"ArrowLeft\"]\n}, tr = {\n  ltr: [\"ArrowLeft\"],\n  rtl: [\"ArrowRight\"]\n};\nfunction xo(o) {\n  return o ? \"open\" : \"closed\";\n}\nfunction Pt(o) {\n  return o === \"indeterminate\";\n}\nfunction Eo(o) {\n  return Pt(o) ? \"indeterminate\" : o ? \"checked\" : \"unchecked\";\n}\nfunction ao(o) {\n  const t = document.activeElement;\n  for (const e of o)\n    if (e === t || (e.focus(), document.activeElement !== t))\n      return;\n}\nfunction or(o, t) {\n  const { x: e, y: a } = o;\n  let s = !1;\n  for (let r = 0, l = t.length - 1; r < t.length; l = r++) {\n    const i = t[r].x, u = t[r].y, d = t[l].x, p = t[l].y;\n    u > a != p > a && e < (d - i) * (a - u) / (p - u) + i && (s = !s);\n  }\n  return s;\n}\nfunction nr(o, t) {\n  if (!t)\n    return !1;\n  const e = { x: o.clientX, y: o.clientY };\n  return or(e, t);\n}\nfunction rt(o) {\n  return o.pointerType === \"mouse\";\n}\nfunction ar() {\n  const o = \"DialogContent\", t = \"DialogTitle\", e = ye(), a = `Warning: \\`${o}\\` requires a \\`${t}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${t}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://www.radix-vue.com/components/dialog.html#title;`, s = `Warning: Missing \\`Description\\` or \\`aria-describedby=\"undefined\"\\` for ${o}.`;\n  q(() => {\n    var i;\n    document.getElementById(e.titleId) || console.warn(a);\n    const l = (i = e.contentElement.value) == null ? void 0 : i.getAttribute(\"aria-describedby\");\n    e.descriptionId && l && (document.getElementById(e.descriptionId) || console.warn(s));\n  });\n}\nconst Vn = /* @__PURE__ */ b({\n  __name: \"DialogContentImpl\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = ye(), { forwardRef: r, currentElement: l } = $();\n    return q(() => {\n      s.contentElement = l;\n    }), process.env.NODE_ENV !== \"production\" && ar(), (i, u) => (h(), C(n(At), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: e.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => a(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => a(\"closeAutoFocus\", d))\n    }, {\n      default: m(() => [\n        k(n(De), T({\n          id: n(s).contentId,\n          ref: n(r),\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          role: \"dialog\",\n          \"aria-describedby\": n(s).descriptionId,\n          \"aria-labelledby\": n(s).titleId,\n          \"data-state\": n(xo)(n(s).open.value)\n        }, i.$attrs, {\n          onDismiss: u[0] || (u[0] = (d) => n(s).onOpenChange(!1)),\n          onEscapeKeyDown: u[1] || (u[1] = (d) => a(\"escapeKeyDown\", d)),\n          onFocusOutside: u[2] || (u[2] = (d) => a(\"focusOutside\", d)),\n          onInteractOutside: u[3] || (u[3] = (d) => a(\"interactOutside\", d)),\n          onPointerDownOutside: u[4] || (u[4] = (d) => a(\"pointerDownOutside\", d))\n        }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"as\", \"as-child\", \"disable-outside-pointer-events\", \"aria-describedby\", \"aria-labelledby\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), sr = /* @__PURE__ */ b({\n  __name: \"DialogContentModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = ye(), r = ce(a), { forwardRef: l, currentElement: i } = $();\n    return pt(i), (u, d) => (h(), C(Vn, T({ ...e, ...n(r) }, {\n      ref: n(l),\n      \"trap-focus\": n(s).open.value,\n      \"disable-outside-pointer-events\": !0,\n      onCloseAutoFocus: d[0] || (d[0] = (p) => {\n        var c;\n        a(\"closeAutoFocus\", p), p.defaultPrevented || (p.preventDefault(), (c = n(s).triggerElement.value) == null || c.focus());\n      }),\n      onPointerDownOutside: d[1] || (d[1] = (p) => {\n        const c = p.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0;\n        (c.button === 2 || f) && p.preventDefault();\n      }),\n      onFocusOutside: d[2] || (d[2] = (p) => {\n        p.preventDefault();\n      }),\n      onOpenAutoFocus: d[3] || (d[3] = (p) => a(\"openAutoFocus\", p))\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), rr = /* @__PURE__ */ b({\n  __name: \"DialogContentNonModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = ce(a);\n    $();\n    const r = ye(), l = P(!1), i = P(!1);\n    return (u, d) => (h(), C(Vn, T({ ...e, ...n(s) }, {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (p) => {\n        var c;\n        a(\"closeAutoFocus\", p), p.defaultPrevented || (l.value || (c = n(r).triggerElement.value) == null || c.focus(), p.preventDefault()), l.value = !1, i.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = (p) => {\n        var v;\n        p.defaultPrevented || (l.value = !0, p.detail.originalEvent.type === \"pointerdown\" && (i.value = !0));\n        const c = p.target;\n        ((v = n(r).triggerElement.value) == null ? void 0 : v.contains(c)) && p.preventDefault(), p.detail.originalEvent.type === \"focusin\" && i.value && p.preventDefault();\n      })\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lr = /* @__PURE__ */ b({\n  __name: \"DialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = ye(), r = ce(a), { forwardRef: l } = $();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(s).open.value\n    }, {\n      default: m(() => [\n        n(s).modal.value ? (h(), C(sr, T({\n          key: 0,\n          ref: n(l)\n        }, { ...e, ...n(r), ...i.$attrs }, {\n          onOpenAutoFocus: u[0] || (u[0] = (d) => a(\"openAutoFocus\", d))\n        }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (h(), C(rr, T({\n          key: 1,\n          ref: n(l)\n        }, { ...e, ...n(r), ...i.$attrs }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), ir = /* @__PURE__ */ b({\n  __name: \"DialogOverlayImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = ye();\n    return ct(!0), $(), (e, a) => (h(), C(n(D), {\n      as: e.as,\n      \"as-child\": e.asChild,\n      \"data-state\": n(t).open.value ? \"open\" : \"closed\",\n      style: { \"pointer-events\": \"auto\" }\n    }, {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\"]));\n  }\n}), ur = /* @__PURE__ */ b({\n  __name: \"DialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = ye(), { forwardRef: e } = $();\n    return (a, s) => {\n      var r;\n      return (r = n(t)) != null && r.modal.value ? (h(), C(n(se), {\n        key: 0,\n        present: a.forceMount || n(t).open.value\n      }, {\n        default: m(() => [\n          k(ir, T(a.$attrs, {\n            ref: n(e),\n            as: a.as,\n            \"as-child\": a.asChild\n          }), {\n            default: m(() => [\n              y(a.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])) : X(\"\", !0);\n    };\n  }\n}), Fn = /* @__PURE__ */ b({\n  __name: \"DialogClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = ye();\n    return (a, s) => (h(), C(n(D), T(t, {\n      type: a.as === \"button\" ? \"button\" : void 0,\n      onClick: s[0] || (s[0] = (r) => n(e).onOpenChange(!1))\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), dr = /* @__PURE__ */ b({\n  __name: \"DialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h2\" }\n  },\n  setup(o) {\n    const t = o, e = ye();\n    return $(), (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).titleId\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), cr = /* @__PURE__ */ b({\n  __name: \"DialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = ye();\n    return (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).descriptionId\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), iu = /* @__PURE__ */ b({\n  __name: \"AlertDialogRoot\",\n  props: {\n    open: { type: Boolean },\n    defaultOpen: { type: Boolean }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t);\n    return $(), (r, l) => (h(), C(n(Fs), T(n(s), { modal: !0 }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), uu = /* @__PURE__ */ b({\n  __name: \"AlertDialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Ls), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), du = /* @__PURE__ */ b({\n  __name: \"AlertDialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [pr, fr] = H(\"AlertDialogContent\"), cu = /* @__PURE__ */ b({\n  __name: \"AlertDialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    $();\n    const r = P();\n    return fr({\n      onCancelElementChange: (l) => {\n        r.value = l;\n      }\n    }), (l, i) => (h(), C(n(lr), T({ ...e, ...n(s) }, {\n      role: \"alertdialog\",\n      onPointerDownOutside: i[0] || (i[0] = oe(() => {\n      }, [\"prevent\"])),\n      onInteractOutside: i[1] || (i[1] = oe(() => {\n      }, [\"prevent\"])),\n      onOpenAutoFocus: i[2] || (i[2] = () => {\n        G(() => {\n          var u;\n          (u = r.value) == null || u.focus({\n            preventScroll: !0\n          });\n        });\n      })\n    }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), pu = /* @__PURE__ */ b({\n  __name: \"AlertDialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(ur), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fu = /* @__PURE__ */ b({\n  __name: \"AlertDialogCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = pr(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.onCancelElementChange(s.value);\n    }), (r, l) => (h(), C(n(Fn), T(t, { ref: n(a) }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vu = /* @__PURE__ */ b({\n  __name: \"AlertDialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(dr), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), mu = /* @__PURE__ */ b({\n  __name: \"AlertDialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(cr), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), hu = /* @__PURE__ */ b({\n  __name: \"AlertDialogAction\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Fn), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gu = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"AspectRatio\",\n  props: {\n    ratio: { default: 1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $(), a = S(() => 1 / t.ratio * 100);\n    return (s, r) => (h(), Q(\"div\", {\n      style: re(`position: relative; width: 100%; padding-bottom: ${a.value}%`),\n      \"data-radix-aspect-ratio-wrapper\": \"\"\n    }, [\n      k(n(D), T({\n        ref: n(e),\n        \"as-child\": s.asChild,\n        as: s.as,\n        style: { position: \"absolute\", inset: \"0px\" }\n      }, s.$attrs), {\n        default: m(() => [\n          y(s.$slots, \"default\", { aspect: a.value })\n        ]),\n        _: 3\n      }, 16, [\"as-child\", \"as\"])\n    ], 4));\n  }\n}), [Ln, vr] = H(\"AvatarRoot\"), yu = /* @__PURE__ */ b({\n  __name: \"AvatarRoot\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    return $(), vr({\n      imageLoadingStatus: P(\"loading\")\n    }), (t, e) => (h(), C(n(D), {\n      \"as-child\": t.asChild,\n      as: t.as\n    }, {\n      default: m(() => [\n        y(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n});\nfunction mr(o) {\n  const t = P(\"idle\"), e = P(!1), a = (s) => () => {\n    e.value && (t.value = s);\n  };\n  return q(() => {\n    e.value = !0, U(o, (s) => {\n      if (!s)\n        t.value = \"error\";\n      else {\n        const r = new window.Image();\n        t.value = \"loading\", r.onload = a(\"loaded\"), r.onerror = a(\"error\"), r.src = s;\n      }\n    }, { immediate: !0 });\n  }), fe(() => {\n    e.value = !1;\n  }), t;\n}\nconst bu = /* @__PURE__ */ b({\n  __name: \"AvatarImage\",\n  props: {\n    src: {},\n    asChild: { type: Boolean },\n    as: { default: \"img\" }\n  },\n  emits: [\"loadingStatusChange\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { src: s } = z(e);\n    $();\n    const r = Ln(), l = mr(s);\n    return U(\n      l,\n      (i) => {\n        a(\"loadingStatusChange\", i), i !== \"idle\" && (r.imageLoadingStatus.value = i);\n      },\n      { immediate: !0 }\n    ), (i, u) => n(l) === \"loaded\" ? (h(), C(n(D), {\n      key: 0,\n      role: \"img\",\n      \"as-child\": i.asChild,\n      as: i.as,\n      src: n(s)\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"src\"])) : X(\"\", !0);\n  }\n}), Cu = /* @__PURE__ */ b({\n  __name: \"AvatarFallback\",\n  props: {\n    delayMs: { default: 0 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = Ln();\n    $();\n    const a = P(!1);\n    let s;\n    return U(e.imageLoadingStatus, (r) => {\n      r === \"loading\" && (a.value = !1, t.delayMs ? s = setTimeout(() => {\n        a.value = !0, clearTimeout(s);\n      }, t.delayMs) : a.value = !0);\n    }, { immediate: !0 }), (r, l) => a.value && n(e).imageLoadingStatus.value !== \"loaded\" ? (h(), C(n(D), {\n      key: 0,\n      \"as-child\": r.asChild,\n      as: r.as\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"])) : X(\"\", !0);\n  }\n});\nfunction Bt(o) {\n  return o === \"indeterminate\";\n}\nfunction Kn(o) {\n  return Bt(o) ? \"indeterminate\" : o ? \"checked\" : \"unchecked\";\n}\nconst hr = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], [gr, yr] = H(\"CheckboxRoot\"), wu = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"CheckboxRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: [Boolean, String], default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    value: { default: \"on\" },\n    id: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { disabled: s } = z(e), r = Y(e, \"checked\", a, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    }), { forwardRef: l, currentElement: i } = $(), u = Ne(i), d = S(() => {\n      var p;\n      return e.id && i.value ? (p = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : p.innerText : void 0;\n    });\n    return yr({\n      disabled: s,\n      state: r\n    }), (p, c) => (h(), Q(le, null, [\n      k(n(D), T(p.$attrs, {\n        id: p.id,\n        ref: n(l),\n        role: \"checkbox\",\n        \"as-child\": e.asChild,\n        as: p.as,\n        type: p.as === \"button\" ? \"button\" : void 0,\n        \"aria-checked\": n(Bt)(n(r)) ? \"mixed\" : n(r),\n        \"aria-required\": !1,\n        \"aria-label\": p.$attrs[\"aria-label\"] || d.value,\n        \"data-state\": n(Kn)(n(r)),\n        \"data-disabled\": n(s) ? \"\" : void 0,\n        disabled: n(s),\n        onKeydown: ie(oe(() => {\n        }, [\"prevent\"]), [\"enter\"]),\n        onClick: c[0] || (c[0] = (f) => r.value = n(Bt)(n(r)) ? !0 : !n(r))\n      }), {\n        default: m(() => [\n          y(p.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"as-child\", \"as\", \"type\", \"aria-checked\", \"aria-label\", \"data-state\", \"data-disabled\", \"disabled\", \"onKeydown\"]),\n      n(u) ? (h(), Q(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: p.value,\n        checked: !!n(r),\n        name: e.name,\n        disabled: e.disabled,\n        required: e.required,\n        style: re({\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        })\n      }, null, 12, hr)) : X(\"\", !0)\n    ], 64));\n  }\n}), _u = /* @__PURE__ */ b({\n  __name: \"CheckboxIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const { forwardRef: t } = $(), e = gr();\n    return (a, s) => (h(), C(n(se), {\n      present: a.forceMount || n(Bt)(n(e).state.value) || n(e).state.value === !0\n    }, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(t),\n          \"data-state\": n(Kn)(n(e).state.value),\n          \"data-disabled\": n(e).disabled.value ? \"\" : void 0,\n          style: { pointerEvents: \"none\" },\n          \"as-child\": a.asChild,\n          as: a.as\n        }, a.$attrs), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [Nn, br] = H(\"PopperRoot\"), je = /* @__PURE__ */ b({\n  __name: \"PopperRoot\",\n  setup(o) {\n    const t = P();\n    return br({\n      anchor: t,\n      onAnchorChange: (e) => t.value = e\n    }), (e, a) => y(e.$slots, \"default\");\n  }\n}), We = /* @__PURE__ */ b({\n  __name: \"PopperAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { forwardRef: e, currentElement: a } = $(), s = Nn();\n    return U(a, () => {\n      s.onAnchorChange(t.element ?? a.value);\n    }), (r, l) => (h(), C(n(D), {\n      ref: n(e),\n      as: r.as,\n      \"as-child\": r.asChild\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n});\nfunction Cr(o) {\n  return o !== null;\n}\nfunction wr(o) {\n  return {\n    name: \"transformOrigin\",\n    options: o,\n    fn(t) {\n      var E, _, x;\n      const { placement: e, rects: a, middlewareData: s } = t, l = ((E = s.arrow) == null ? void 0 : E.centerOffset) !== 0, i = l ? 0 : o.arrowWidth, u = l ? 0 : o.arrowHeight, [d, p] = so(e), c = { start: \"0%\", center: \"50%\", end: \"100%\" }[p], f = (((_ = s.arrow) == null ? void 0 : _.x) ?? 0) + i / 2, v = (((x = s.arrow) == null ? void 0 : x.y) ?? 0) + u / 2;\n      let g = \"\", w = \"\";\n      return d === \"bottom\" ? (g = l ? c : `${f}px`, w = `${-u}px`) : d === \"top\" ? (g = l ? c : `${f}px`, w = `${a.floating.height + u}px`) : d === \"right\" ? (g = `${-u}px`, w = l ? c : `${v}px`) : d === \"left\" && (g = `${a.floating.width + u}px`, w = l ? c : `${v}px`), { data: { x: g, y: w } };\n    }\n  };\n}\nfunction so(o) {\n  const [t, e = \"center\"] = o.split(\"-\");\n  return [t, e];\n}\nconst Hn = {\n  side: \"bottom\",\n  sideOffset: 0,\n  align: \"center\",\n  alignOffset: 0,\n  arrowPadding: 0,\n  avoidCollisions: !0,\n  collisionBoundary: () => [],\n  collisionPadding: 0,\n  sticky: \"partial\",\n  hideWhenDetached: !1,\n  updatePositionStrategy: \"optimized\",\n  prioritizePosition: !1\n}, [_r, $r] = H(\"PopperContent\"), Fe = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"PopperContent\",\n  props: /* @__PURE__ */ wn({\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...Hn\n  }),\n  emits: [\"placed\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = Nn(), { forwardRef: r, currentElement: l } = $(), i = P(), u = P(), { width: d, height: p } = Dn(u), c = S(\n      () => e.side + (e.align !== \"center\" ? `-${e.align}` : \"\")\n    ), f = S(() => typeof e.collisionPadding == \"number\" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), v = S(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), g = S(() => ({\n      padding: f.value,\n      boundary: v.value.filter(Cr),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: v.value.length > 0\n    })), w = Ga(() => [\n      Ha({\n        mainAxis: e.sideOffset + p.value,\n        alignmentAxis: e.alignOffset\n      }),\n      e.prioritizePosition && e.avoidCollisions && tn({\n        ...g.value\n      }),\n      e.avoidCollisions && ja({\n        mainAxis: !0,\n        crossAxis: !!e.prioritizePosition,\n        limiter: e.sticky === \"partial\" ? Wa() : void 0,\n        ...g.value\n      }),\n      !e.prioritizePosition && e.avoidCollisions && tn({\n        ...g.value\n      }),\n      za({\n        ...g.value,\n        apply: ({ elements: I, rects: F, availableWidth: W, availableHeight: J }) => {\n          const { width: K, height: Z } = F.reference, ne = I.floating.style;\n          Object.assign(I.floating.style, {\n            maxWidth: `${W}px`,\n            maxHeight: `${J}px`\n          }), ne.setProperty(\n            \"--radix-popper-available-width\",\n            `${W}px`\n          ), ne.setProperty(\n            \"--radix-popper-available-height\",\n            `${J}px`\n          ), ne.setProperty(\n            \"--radix-popper-anchor-width\",\n            `${K}px`\n          ), ne.setProperty(\n            \"--radix-popper-anchor-height\",\n            `${Z}px`\n          );\n        }\n      }),\n      u.value && Ua({ element: u.value, padding: e.arrowPadding }),\n      wr({\n        arrowWidth: d.value,\n        arrowHeight: p.value\n      }),\n      e.hideWhenDetached && qa({ strategy: \"referenceHidden\", ...g.value })\n    ]), { floatingStyles: E, placement: _, isPositioned: x, middlewareData: B } = Ka(\n      s.anchor,\n      i,\n      {\n        strategy: \"fixed\",\n        placement: c,\n        whileElementsMounted: (...I) => Na(...I, {\n          animationFrame: e.updatePositionStrategy === \"always\"\n        }),\n        middleware: w\n      }\n    ), O = S(\n      () => so(_.value)[0]\n    ), A = S(\n      () => so(_.value)[1]\n    );\n    ee(() => {\n      x.value && a(\"placed\");\n    });\n    const M = S(\n      () => {\n        var I;\n        return ((I = B.value.arrow) == null ? void 0 : I.centerOffset) !== 0;\n      }\n    ), R = P(\"\");\n    ee(() => {\n      l.value && (R.value = window.getComputedStyle(l.value).zIndex);\n    });\n    const V = S(() => {\n      var I;\n      return ((I = B.value.arrow) == null ? void 0 : I.x) ?? 0;\n    }), j = S(() => {\n      var I;\n      return ((I = B.value.arrow) == null ? void 0 : I.y) ?? 0;\n    });\n    return $r({\n      placedSide: O,\n      onArrowChange: (I) => u.value = I,\n      arrowX: V,\n      arrowY: j,\n      shouldHideArrow: M\n    }), (I, F) => {\n      var W, J, K;\n      return h(), Q(\"div\", {\n        ref_key: \"floatingRef\",\n        ref: i,\n        \"data-radix-popper-content-wrapper\": \"\",\n        style: re({\n          ...n(E),\n          transform: n(x) ? n(E).transform : \"translate(0, -200%)\",\n          // keep off the page when measuring\n          minWidth: \"max-content\",\n          zIndex: R.value,\n          \"--radix-popper-transform-origin\": [\n            (W = n(B).transformOrigin) == null ? void 0 : W.x,\n            (J = n(B).transformOrigin) == null ? void 0 : J.y\n          ].join(\" \")\n        })\n      }, [\n        k(n(D), T({ ref: n(r) }, I.$attrs, {\n          \"as-child\": e.asChild,\n          as: I.as,\n          \"data-side\": O.value,\n          \"data-align\": A.value,\n          style: {\n            // if the PopperContent hasn't been placed yet (not all measurements done)\n            // we prevent animations so that users's animation don't kick in too early referring wrong sides\n            animation: n(x) ? void 0 : \"none\",\n            // hide the content if using the hide middleware and should be hidden\n            opacity: (K = n(B).hide) != null && K.referenceHidden ? 0 : void 0\n          }\n        }), {\n          default: m(() => [\n            y(I.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-side\", \"data-align\", \"style\"])\n      ], 4);\n    };\n  }\n}), xr = /* @__PURE__ */ ut(\"polygon\", { points: \"0,0 30,0 15,10\" }, null, -1), Er = /* @__PURE__ */ b({\n  __name: \"Arrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(D), T(t, {\n      width: e.width,\n      height: e.height,\n      viewBox: e.asChild ? void 0 : \"0 0 30 10\",\n      preserveAspectRatio: e.asChild ? void 0 : \"none\"\n    }), {\n      default: m(() => [\n        y(e.$slots, \"default\", {}, () => [\n          xr\n        ])\n      ]),\n      _: 3\n    }, 16, [\"width\", \"height\", \"viewBox\", \"preserveAspectRatio\"]));\n  }\n}), Pr = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n}, Ze = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"PopperArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const { forwardRef: t } = $(), e = _r(), a = S(() => Pr[e.placedSide.value]);\n    return (s, r) => {\n      var l, i, u, d;\n      return h(), Q(\"span\", {\n        ref: (p) => {\n          n(e).onArrowChange(p);\n        },\n        style: re({\n          position: \"absolute\",\n          left: (l = n(e).arrowX) != null && l.value ? `${(i = n(e).arrowX) == null ? void 0 : i.value}px` : void 0,\n          top: (u = n(e).arrowY) != null && u.value ? `${(d = n(e).arrowY) == null ? void 0 : d.value}px` : void 0,\n          [a.value]: 0,\n          transformOrigin: {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\"\n          }[n(e).placedSide.value],\n          transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: \"rotate(180deg)\",\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n          }[n(e).placedSide.value],\n          visibility: n(e).shouldHideArrow.value ? \"hidden\" : void 0\n        })\n      }, [\n        k(Er, T(s.$attrs, {\n          ref: n(t),\n          style: {\n            display: \"block\"\n          },\n          as: s.as,\n          \"as-child\": s.asChild,\n          width: s.width,\n          height: s.height\n        }), {\n          default: m(() => [\n            y(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"width\", \"height\"])\n      ], 4);\n    };\n  }\n}), Qe = /* @__PURE__ */ b({\n  __name: \"VisuallyHidden\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    return $(), (t, e) => (h(), C(n(D), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      style: re({\n        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n        position: \"absolute\",\n        border: 0,\n        width: \"1px\",\n        display: \"inline-block\",\n        height: \"1px\",\n        padding: 0,\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        clip: \"rect(0, 0, 0, 0)\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n      })\n    }, {\n      default: m(() => [\n        y(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"style\"]));\n  }\n}), jn = /* @__PURE__ */ b({\n  __name: \"VisuallyHiddenInput\",\n  props: {\n    name: {},\n    value: {},\n    required: { type: Boolean },\n    disabled: { type: Boolean }\n  },\n  setup(o) {\n    const t = o, e = S(() => typeof t.value == \"string\" || typeof t.value == \"number\" || typeof t.value == \"boolean\" ? [{ name: t.name, value: t.value }] : typeof t.value == \"object\" && Array.isArray(t.value) ? t.value.flatMap((a, s) => typeof a == \"object\" ? Object.entries(a).map(([r, l]) => ({ name: `[${s}][${t.name}][${r}]`, value: l })) : { name: `[${t.name}][${s}]`, value: a }) : typeof t.value == \"object\" && !Array.isArray(t.value) ? Object.entries(t.value).map(([a, s]) => ({ name: `[${t.name}][${a}]`, value: s })) : []);\n    return (a, s) => (h(!0), Q(le, null, po(e.value, (r) => (h(), C(Qe, {\n      key: r.name,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: \"\",\n      readonly: \"\",\n      name: r.name,\n      value: r.value,\n      required: a.required,\n      disabled: a.disabled\n    }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"]))), 128));\n  }\n});\nfunction Br(o) {\n  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, \"default\") ? o.default : o;\n}\nvar Sr = function o(t, e) {\n  if (t === e)\n    return !0;\n  if (t && e && typeof t == \"object\" && typeof e == \"object\") {\n    if (t.constructor !== e.constructor)\n      return !1;\n    var a, s, r;\n    if (Array.isArray(t)) {\n      if (a = t.length, a != e.length)\n        return !1;\n      for (s = a; s-- !== 0; )\n        if (!o(t[s], e[s]))\n          return !1;\n      return !0;\n    }\n    if (t.constructor === RegExp)\n      return t.source === e.source && t.flags === e.flags;\n    if (t.valueOf !== Object.prototype.valueOf)\n      return t.valueOf() === e.valueOf();\n    if (t.toString !== Object.prototype.toString)\n      return t.toString() === e.toString();\n    if (r = Object.keys(t), a = r.length, a !== Object.keys(e).length)\n      return !1;\n    for (s = a; s-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(e, r[s]))\n        return !1;\n    for (s = a; s-- !== 0; ) {\n      var l = r[s];\n      if (!o(t[l], e[l]))\n        return !1;\n    }\n    return !0;\n  }\n  return t !== t && e !== e;\n};\nconst Ge = /* @__PURE__ */ Br(Sr), Tr = \"data-radix-vue-collection-item\", [Po, Dr] = H(\"CollectionProvider\");\nfunction Bo(o = Tr) {\n  const t = P(/* @__PURE__ */ new Map()), e = P(), a = Dr({\n    collectionRef: e,\n    itemMap: t,\n    attrName: o\n  }), { getItems: s } = Wn(a), r = S(() => Array.from(a.itemMap.value.values())), l = S(() => a.itemMap.value.size);\n  return { getItems: s, reactiveItems: r, itemMapSize: l };\n}\nconst So = b({\n  name: \"CollectionSlot\",\n  setup(o, { slots: t }) {\n    const e = Po(), { primitiveElement: a, currentElement: s } = In();\n    return U(s, () => {\n      e.collectionRef.value = s.value;\n    }), () => Ve(wo, { ref: a }, t);\n  }\n}), To = b({\n  name: \"CollectionItem\",\n  setup(o, { slots: t, attrs: e }) {\n    const a = Po(), { primitiveElement: s, currentElement: r } = In(), l = Se();\n    return ee((i) => {\n      var u;\n      if (r.value) {\n        const d = en(r.value);\n        a.itemMap.value.set(d, { ref: r.value, ...en(((u = l == null ? void 0 : l.parent) == null ? void 0 : u.props) ?? {}) }), i(() => a.itemMap.value.delete(d));\n      }\n    }), () => Ve(wo, { ...e, [a.attrName]: \"\", ref: s }, t);\n  }\n});\nfunction Wn(o) {\n  const t = o ?? Po();\n  return { getItems: () => {\n    const a = t.collectionRef.value;\n    if (!a)\n      return [];\n    const s = Array.from(a.querySelectorAll(`[${t.attrName}]`));\n    return Array.from(t.itemMap.value.values()).sort(\n      (i, u) => s.indexOf(i.ref) - s.indexOf(u.ref)\n    );\n  } };\n}\nconst [$e, Or] = H(\"ComboboxRoot\"), $u = /* @__PURE__ */ b({\n  __name: \"ComboboxRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    searchTerm: {},\n    multiple: { type: Boolean },\n    disabled: { type: Boolean },\n    name: {},\n    dir: {},\n    filterFunction: {},\n    displayValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:open\", \"update:searchTerm\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { multiple: s, disabled: r, dir: l } = z(e), i = de(l), u = Y(e, \"searchTerm\", a, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: \"\",\n      passive: e.searchTerm === void 0\n    }), d = Y(e, \"modelValue\", a, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: e.defaultValue ?? s.value ? [] : void 0,\n      passive: e.modelValue === void 0,\n      deep: !0\n    }), p = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), c = P();\n    async function f(K) {\n      var Z, ne;\n      p.value = K, await G(), K ? (d.value && (Array.isArray(d.value) && s.value ? c.value = (Z = B().find((Ut) => {\n        var at, mt;\n        return ((mt = (at = Ut.ref) == null ? void 0 : at.dataset) == null ? void 0 : mt.state) === \"checked\";\n      })) == null ? void 0 : Z.value : c.value = d.value), (ne = w.value) == null || ne.focus(), J()) : (g.value = !1, V());\n    }\n    function v(K) {\n      if (Array.isArray(d.value) && s.value) {\n        const Z = d.value.findIndex((ne) => Ge(ne, K));\n        Z === -1 ? d.value.push(K) : d.value.splice(Z, 1);\n      } else\n        d.value = K, f(!1);\n    }\n    const g = P(!1), w = P(), E = P(), { forwardRef: _, currentElement: x } = $(), { getItems: B, reactiveItems: O, itemMapSize: A } = Bo(\"data-radix-vue-combobox-item\"), M = P([]);\n    U(() => A.value, () => {\n      M.value = B().map((K) => K.value);\n    }, { immediate: !0 });\n    const R = S(() => {\n      if (g.value) {\n        if (e.filterFunction)\n          return e.filterFunction(M.value, u.value);\n        const K = M.value.filter((Z) => typeof Z == \"string\");\n        if (K.length)\n          return K.filter((Z) => {\n            var ne;\n            return Z.toLowerCase().includes((ne = u.value) == null ? void 0 : ne.toLowerCase());\n          });\n      }\n      return M.value;\n    });\n    function V() {\n      !s.value && d.value && !Array.isArray(d.value) ? e.displayValue ? u.value = e.displayValue(d.value) : typeof d.value != \"object\" ? u.value = d.value.toString() : u.value = \"\" : u.value = \"\";\n    }\n    const j = S(() => R.value.findIndex((K) => Ge(K, c.value))), I = S(() => {\n      var K;\n      return (K = O.value.find((Z) => Z.value === c.value)) == null ? void 0 : K.ref;\n    }), F = S(() => JSON.stringify(d.value));\n    U(F, async () => {\n      await G(), await G(), V();\n    }, { immediate: !0 }), U(() => R.value.length, async (K) => {\n      await G(), await G(), K && j.value === -1 && (c.value = R.value[0]);\n    });\n    const W = Ne(x);\n    function J() {\n      I.value instanceof Element && I.value.scrollIntoView({ block: \"nearest\" });\n    }\n    return Or({\n      searchTerm: u,\n      modelValue: d,\n      // @ts-expect-error igoring\n      onValueChange: v,\n      isUserInputted: g,\n      multiple: s,\n      disabled: r,\n      open: p,\n      onOpenChange: f,\n      filteredOptions: R,\n      contentId: te(),\n      inputElement: w,\n      onInputElementChange: (K) => w.value = K,\n      onInputNavigation: async (K) => {\n        const Z = j.value;\n        Z === 0 && K === \"up\" || Z === R.value.length - 1 && K === \"down\" || (Z === -1 && R.value.length || K === \"home\" ? c.value = R.value[0] : K === \"end\" ? c.value = R.value[R.value.length - 1] : c.value = R.value[K === \"up\" ? Z - 1 : Z + 1], J());\n      },\n      onInputEnter: async () => {\n        var K;\n        R.value.length && c.value && I.value instanceof Element && ((K = I.value) == null || K.click());\n      },\n      selectedValue: c,\n      onSelectedValueChange: (K) => c.value = K,\n      parentElement: x,\n      contentElement: E,\n      onContentElementChange: (K) => E.value = K\n    }), (K, Z) => (h(), C(n(je), null, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(_),\n          style: {\n            pointerEvents: n(p) ? \"auto\" : void 0\n          },\n          as: K.as,\n          \"as-child\": K.asChild,\n          dir: n(i)\n        }, K.$attrs), {\n          default: m(() => [\n            y(K.$slots, \"default\", {\n              open: n(p),\n              modelValue: n(d)\n            }),\n            n(W) && e.name ? (h(), C(n(jn), {\n              key: 0,\n              name: e.name,\n              value: n(d)\n            }, null, 8, [\"name\", \"value\"])) : X(\"\", !0)\n          ]),\n          _: 3\n        }, 16, [\"style\", \"as\", \"as-child\", \"dir\"])\n      ]),\n      _: 3\n    }));\n  }\n}), xu = /* @__PURE__ */ b({\n  __name: \"ComboboxInput\",\n  props: {\n    type: { default: \"text\" },\n    disabled: { type: Boolean },\n    autoFocus: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(o) {\n    const t = o, e = $e(), { forwardRef: a, currentElement: s } = $();\n    q(() => {\n      const d = s.value.nodeName === \"INPUT\" ? s.value : s.value.querySelector(\"input\");\n      d && (e.onInputElementChange(d), setTimeout(() => {\n        t.autoFocus && (d == null || d.focus());\n      }, 1));\n    });\n    const r = S(() => t.disabled || e.disabled.value || !1);\n    function l(d) {\n      e.open.value ? e.onInputNavigation(d.key === \"ArrowUp\" ? \"up\" : \"down\") : e.onOpenChange(!0);\n    }\n    function i(d) {\n      e.open.value && e.onInputNavigation(d.key === \"Home\" ? \"home\" : \"end\");\n    }\n    function u(d) {\n      var p;\n      e.searchTerm.value = (p = d.target) == null ? void 0 : p.value, e.open.value || e.onOpenChange(!0), e.isUserInputted.value = !0;\n    }\n    return (d, p) => (h(), C(n(D), {\n      ref: n(a),\n      as: d.as,\n      \"as-child\": d.asChild,\n      type: d.type,\n      disabled: r.value,\n      value: n(e).searchTerm.value,\n      \"aria-expanded\": n(e).open.value,\n      \"aria-controls\": n(e).contentId,\n      \"aria-disabled\": r.value ?? void 0,\n      \"aria-autocomplete\": \"list\",\n      role: \"combobox\",\n      autocomplete: \"false\",\n      onInput: u,\n      onKeydown: [\n        ie(oe(l, [\"prevent\"]), [\"down\", \"up\"]),\n        ie(n(e).onInputEnter, [\"enter\"]),\n        ie(oe(i, [\"prevent\"]), [\"home\", \"end\"])\n      ]\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"disabled\", \"value\", \"aria-expanded\", \"aria-controls\", \"aria-disabled\", \"onKeydown\"]));\n  }\n}), Eu = /* @__PURE__ */ b({\n  __name: \"ComboboxAnchor\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const { forwardRef: t } = $();\n    return (e, a) => (h(), C(n(We), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(t),\n          \"as-child\": e.asChild,\n          as: e.as\n        }, e.$attrs), {\n          default: m(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Pu = /* @__PURE__ */ b({\n  __name: \"ComboboxTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = $e(), a = S(() => t.disabled || e.disabled.value || !1);\n    return (s, r) => (h(), C(n(D), T(t, {\n      type: s.as === \"button\" ? \"button\" : void 0,\n      tabindex: \"-1\",\n      \"aria-label\": \"Show popup\",\n      \"aria-haspopup\": \"listbox\",\n      \"aria-expanded\": n(e).open.value,\n      \"aria-controls\": n(e).contentId,\n      \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n      disabled: a.value,\n      \"data-disabled\": a.value ? \"\" : void 0,\n      \"aria-disabled\": a.value ?? void 0,\n      onClick: r[0] || (r[0] = (l) => n(e).onOpenChange(!n(e).open.value))\n    }), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"aria-disabled\"]));\n  }\n}), Bu = /* @__PURE__ */ b({\n  __name: \"ComboboxCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = $e();\n    function a() {\n      var s;\n      e.searchTerm.value = \"\", (s = e.inputElement.value) == null || s.focus();\n    }\n    return (s, r) => (h(), C(n(D), T({\n      type: s.as === \"button\" ? \"button\" : void 0\n    }, t, {\n      tabindex: \"-1\",\n      onClick: a\n    }), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), [zn, Ir] = H(\"ComboboxGroup\"), Su = /* @__PURE__ */ b({\n  __name: \"ComboboxGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { currentRef: e, currentElement: a } = $(), s = te(), r = $e(), l = P(!1);\n    function i() {\n      if (!a.value)\n        return;\n      const u = a.value.querySelectorAll(\"[data-radix-vue-combobox-item]:not([data-hidden])\");\n      l.value = !!u.length;\n    }\n    return fs(a, () => {\n      i();\n    }, { childList: !0 }), U(() => r.searchTerm.value, () => {\n      G(() => {\n        i();\n      });\n    }, { immediate: !0 }), Ir({\n      id: s\n    }), (u, d) => fo((h(), C(n(D), T(t, {\n      ref_key: \"currentRef\",\n      ref: e,\n      role: \"group\",\n      \"aria-labelledby\": n(s)\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"])), [\n      [_n, l.value]\n    ]);\n  }\n}), Tu = /* @__PURE__ */ b({\n  __name: \"ComboboxLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = zn({ id: \"\" });\n    return (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).id\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), [Ar, Rr] = H(\"ComboboxContent\"), Mr = /* @__PURE__ */ b({\n  __name: \"ComboboxContentImpl\",\n  props: {\n    position: { default: \"inline\" },\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean, default: !0 },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { position: s } = z(e), r = $e();\n    ct(e.bodyLock);\n    const { forwardRef: l, currentElement: i } = $();\n    pt(i);\n    const u = S(() => e.position === \"popper\" ? e : {}), d = He(u.value);\n    function p(f) {\n      r.onSelectedValueChange(\"\");\n    }\n    q(() => {\n      r.onContentElementChange(i.value);\n    });\n    const c = {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-combobox-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-combobox-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-combobox-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-combobox-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-combobox-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    };\n    return Rr({ position: s }), (f, v) => (h(), C(n(So), null, {\n      default: m(() => [\n        f.dismissable ? (h(), C(n(De), {\n          key: 0,\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": f.disableOutsidePointerEvents,\n          onDismiss: v[0] || (v[0] = (g) => n(r).onOpenChange(!1)),\n          onFocusOutside: v[1] || (v[1] = (g) => {\n            var w;\n            (w = n(r).parentElement.value) != null && w.contains(g.target) && g.preventDefault(), a(\"focusOutside\", g);\n          }),\n          onInteractOutside: v[2] || (v[2] = (g) => a(\"interactOutside\", g)),\n          onEscapeKeyDown: v[3] || (v[3] = (g) => a(\"escapeKeyDown\", g)),\n          onPointerDownOutside: v[4] || (v[4] = (g) => {\n            var w;\n            (w = n(r).parentElement.value) != null && w.contains(g.target) && g.preventDefault(), a(\"pointerDownOutside\", g);\n          })\n        }, {\n          default: m(() => [\n            (h(), C(we(n(s) === \"popper\" ? n(Fe) : n(D)), T({ ...f.$attrs, ...n(d) }, {\n              id: n(r).contentId,\n              ref: n(l),\n              role: \"listbox\",\n              \"data-state\": n(r).open.value ? \"open\" : \"closed\",\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\",\n                ...n(s) === \"popper\" ? c : {}\n              },\n              onPointerleave: p\n            }), {\n              default: m(() => [\n                y(f.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"style\"]))\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])) : (h(), C(we(n(s) === \"popper\" ? n(Fe) : n(D)), T({ key: 1 }, { ...f.$attrs, ...u.value }, {\n          id: n(r).contentId,\n          ref: n(l),\n          role: \"listbox\",\n          \"data-state\": n(r).open.value ? \"open\" : \"closed\",\n          style: {\n            // flex layout so we can place the scroll buttons properly\n            display: \"flex\",\n            flexDirection: \"column\",\n            // reset the outline by default as the content MAY get focused\n            outline: \"none\",\n            ...n(s) === \"popper\" ? c : {}\n          },\n          onPointerleave: p\n        }), {\n          default: m(() => [\n            y(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"data-state\", \"style\"]))\n      ]),\n      _: 3\n    }));\n  }\n}), Du = /* @__PURE__ */ b({\n  __name: \"ComboboxContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t), { forwardRef: r } = $(), l = $e();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(l).open.value\n    }, {\n      default: m(() => [\n        k(Mr, T({ ...n(s), ...i.$attrs }, { ref: n(r) }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Ou = /* @__PURE__ */ b({\n  __name: \"ComboboxEmpty\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = $e(), a = S(() => e.filteredOptions.value.length === 0);\n    return (s, r) => a.value ? (h(), C(n(D), L(T({ key: 0 }, t)), {\n      default: m(() => [\n        y(s.$slots, \"default\", {}, () => [\n          ue(\"No options\")\n        ])\n      ]),\n      _: 3\n    }, 16)) : X(\"\", !0);\n  }\n}), Iu = /* @__PURE__ */ b({\n  __name: \"ComboboxViewport\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $();\n    return (a, s) => (h(), Q(le, null, [\n      k(n(D), T({ ...a.$attrs, ...t }, {\n        ref: n(e),\n        \"data-radix-combobox-viewport\": \"\",\n        role: \"presentation\",\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        }\n      }), {\n        default: m(() => [\n          y(a.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"]),\n      k(n(D), { as: \"style\" }, {\n        default: m(() => [\n          ue(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-combobox-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      })\n    ], 64));\n  }\n}), [kr, Vr] = H(\"ComboboxItem\"), Fr = \"combobox.select\", Au = /* @__PURE__ */ b({\n  __name: \"ComboboxItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { disabled: s } = z(e), r = $e();\n    zn({ id: \"\", options: P([]) });\n    const { forwardRef: l } = $(), i = S(\n      () => {\n        var g, w;\n        return r.multiple.value && Array.isArray(r.modelValue.value) ? (g = r.modelValue.value) == null ? void 0 : g.some((E) => Ge(E, e.value)) : Ge((w = r.modelValue) == null ? void 0 : w.value, e.value);\n      }\n    ), u = S(() => Ge(r.selectedValue.value, e.value)), d = te(), p = S(() => r.isUserInputted.value ? r.searchTerm.value === \"\" || !!r.filteredOptions.value.find((g) => Ge(g, e.value)) : !0);\n    async function c(g) {\n      a(\"select\", g), !(g != null && g.defaultPrevented) && !s.value && g && r.onValueChange(e.value);\n    }\n    function f(g) {\n      if (!g)\n        return;\n      const w = { originalEvent: g, value: e.value };\n      vo(Fr, c, w);\n    }\n    async function v(g) {\n      await G(), !g.defaultPrevented && r.onSelectedValueChange(e.value);\n    }\n    if (e.value === \"\")\n      throw new Error(\n        \"A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return Vr({\n      isSelected: i\n    }), (g, w) => (h(), C(n(To), null, {\n      default: m(() => [\n        fo(k(n(D), {\n          ref: n(l),\n          role: \"option\",\n          tabindex: \"-1\",\n          \"aria-labelledby\": n(d),\n          \"data-highlighted\": u.value ? \"\" : void 0,\n          \"aria-selected\": i.value,\n          \"data-state\": i.value ? \"checked\" : \"unchecked\",\n          \"aria-disabled\": n(s) || void 0,\n          \"data-disabled\": n(s) ? \"\" : void 0,\n          as: g.as,\n          \"as-child\": g.asChild,\n          \"data-hidden\": p.value ? void 0 : !0,\n          onClick: f,\n          onPointermove: v\n        }, {\n          default: m(() => [\n            y(g.$slots, \"default\", {}, () => [\n              ue(Le(g.value), 1)\n            ])\n          ]),\n          _: 3\n        }, 8, [\"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"as\", \"as-child\", \"data-hidden\"]), [\n          [_n, p.value]\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), Ru = /* @__PURE__ */ b({\n  __name: \"ComboboxItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = kr();\n    return (a, s) => n(e).isSelected.value ? (h(), C(n(D), T({\n      key: 0,\n      \"aria-hidden\": \"\"\n    }, t), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", !0);\n  }\n}), Mu = /* @__PURE__ */ b({\n  __name: \"ComboboxSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(D), T(t, { \"aria-hidden\": \"\" }), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ku = /* @__PURE__ */ b({\n  __name: \"ComboboxArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o, e = $e(), a = Ar();\n    return $(), (s, r) => n(e).open.value && n(a).position.value === \"popper\" ? (h(), C(n(Ze), L(T({ key: 0 }, t)), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", !0);\n  }\n}), Vu = /* @__PURE__ */ b({\n  __name: \"ComboboxPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Rt = /* @__PURE__ */ b({\n  __name: \"MenuAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(We), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Do = /* @__PURE__ */ b({\n  __name: \"MenuArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Ze), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [ze, Un] = H([\"MenuRoot\", \"MenuSub\"], \"MenuContext\"), [ft, Lr] = H(\"MenuRoot\"), Oo = /* @__PURE__ */ b({\n  __name: \"MenuRoot\",\n  props: {\n    open: { type: Boolean, default: !1 },\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { modal: s, dir: r } = z(e), l = de(r), i = Y(e, \"open\", a), u = P(), d = P(!1);\n    return ee((p) => {\n      if (!_e)\n        return;\n      const c = () => {\n        d.value = !0, document.addEventListener(\"pointerdown\", f, {\n          capture: !0,\n          once: !0\n        }), document.addEventListener(\"pointermove\", f, {\n          capture: !0,\n          once: !0\n        });\n      }, f = () => d.value = !1;\n      document.addEventListener(\"keydown\", c, { capture: !0 }), p(() => {\n        document.removeEventListener(\"keydown\", c, { capture: !0 }), document.removeEventListener(\"pointerdown\", f, {\n          capture: !0\n        }), document.removeEventListener(\"pointermove\", f, {\n          capture: !0\n        });\n      });\n    }), Un({\n      open: i,\n      onOpenChange: (p) => {\n        i.value = p;\n      },\n      content: u,\n      onContentChange: (p) => {\n        u.value = p;\n      }\n    }), Lr({\n      onClose: () => {\n        i.value = !1;\n      },\n      isUsingKeyboardRef: d,\n      dir: l,\n      modal: s\n    }), (p, c) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(p.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Kr = \"rovingFocusGroup.onEntryFocus\", Nr = { bubbles: !1, cancelable: !0 }, Hr = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction jr(o, t) {\n  return t !== \"rtl\" ? o : o === \"ArrowLeft\" ? \"ArrowRight\" : o === \"ArrowRight\" ? \"ArrowLeft\" : o;\n}\nfunction Wr(o, t, e) {\n  const a = jr(o.key, e);\n  if (!(t === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(a)) && !(t === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(a)))\n    return Hr[a];\n}\nfunction qn(o) {\n  const t = document.activeElement;\n  for (const e of o)\n    if (e === t || (e.focus(), document.activeElement !== t))\n      return;\n}\nfunction zr(o, t) {\n  return o.map((e, a) => o[(t + a) % o.length]);\n}\nconst [Ur, qr] = H(\"RovingFocusGroup\"), et = /* @__PURE__ */ b({\n  __name: \"RovingFocusGroup\",\n  props: {\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !1 },\n    currentTabStopId: {},\n    defaultCurrentTabStopId: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"entryFocus\", \"update:currentTabStopId\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { loop: s, orientation: r, dir: l } = z(e), i = de(l), u = Y(e, \"currentTabStopId\", a, {\n      defaultValue: e.defaultCurrentTabStopId,\n      passive: e.currentTabStopId === void 0\n    }), d = P(!1), p = P(!1), c = P(0), { forwardRef: f, currentElement: v } = $(), { createCollection: g } = ve(\"rovingFocus\"), w = g(v);\n    function E(_) {\n      const x = !p.value;\n      if (_.currentTarget && _.target === _.currentTarget && x && !d.value) {\n        const B = new CustomEvent(Kr, Nr);\n        if (_.currentTarget.dispatchEvent(B), a(\"entryFocus\", B), !B.defaultPrevented) {\n          const O = w.value, A = O.find((V) => V.getAttribute(\"data-active\") === \"true\"), M = O.find(\n            (V) => V.id === u.value\n          ), R = [A, M, ...O].filter(\n            Boolean\n          );\n          qn(R);\n        }\n      }\n      p.value = !1;\n    }\n    return qr({\n      loop: s,\n      dir: i,\n      orientation: r,\n      currentTabStopId: u,\n      onItemFocus: (_) => {\n        u.value = _;\n      },\n      onItemShiftTab: () => {\n        d.value = !0;\n      },\n      onFocusableItemAdd: () => {\n        c.value++;\n      },\n      onFocusableItemRemove: () => {\n        c.value--;\n      }\n    }), (_, x) => (h(), C(n(D), {\n      ref: n(f),\n      tabindex: d.value || c.value === 0 ? -1 : 0,\n      \"data-orientation\": n(r),\n      as: _.as,\n      \"as-child\": _.asChild,\n      dir: n(i),\n      style: { outline: \"none\" },\n      onMousedown: x[0] || (x[0] = (B) => p.value = !0),\n      onFocus: E,\n      onBlur: x[1] || (x[1] = (B) => d.value = !1)\n    }, {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"tabindex\", \"data-orientation\", \"as\", \"as-child\", \"dir\"]));\n  }\n}), tt = /* @__PURE__ */ b({\n  __name: \"RovingFocusItem\",\n  props: {\n    tabStopId: {},\n    focusable: { type: Boolean, default: !0 },\n    active: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = Ur(), a = te(), s = S(() => t.tabStopId || a), r = S(\n      () => e.currentTabStopId.value === s.value\n    ), { injectCollection: l } = ve(\"rovingFocus\"), i = l();\n    q(() => {\n      t.focusable && e.onFocusableItemAdd();\n    }), fe(() => {\n      t.focusable && e.onFocusableItemRemove();\n    });\n    function u(d) {\n      if (d.key === \"Tab\" && d.shiftKey) {\n        e.onItemShiftTab();\n        return;\n      }\n      if (d.target !== d.currentTarget)\n        return;\n      const p = Wr(\n        d,\n        e.orientation.value,\n        e.dir.value\n      );\n      if (p !== void 0) {\n        d.preventDefault();\n        let c = [...i.value];\n        if (p === \"last\")\n          c.reverse();\n        else if (p === \"prev\" || p === \"next\") {\n          p === \"prev\" && c.reverse();\n          const f = c.indexOf(\n            d.currentTarget\n          );\n          c = e.loop.value ? zr(c, f + 1) : c.slice(f + 1);\n        }\n        G(() => qn(c));\n      }\n    }\n    return (d, p) => (h(), C(n(D), {\n      \"data-radix-vue-collection-item\": \"\",\n      tabindex: r.value ? 0 : -1,\n      \"data-orientation\": n(e).orientation.value,\n      \"data-active\": d.active,\n      \"data-disabled\": !d.focusable || void 0,\n      as: d.as,\n      \"as-child\": d.asChild,\n      onMousedown: p[0] || (p[0] = (c) => {\n        d.focusable ? n(e).onItemFocus(s.value) : c.preventDefault();\n      }),\n      onFocus: p[1] || (p[1] = (c) => n(e).onItemFocus(s.value)),\n      onKeydown: u\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"tabindex\", \"data-orientation\", \"data-active\", \"data-disabled\", \"as\", \"as-child\"]));\n  }\n}), [Io, Gr] = H(\"MenuContent\"), Ao = /* @__PURE__ */ b({\n  __name: \"MenuContentImpl\",\n  props: /* @__PURE__ */ wn({\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...Hn\n  }),\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\", \"dismiss\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = ze(), r = ft(), { trapFocus: l, disableOutsidePointerEvents: i, loop: u } = z(e);\n    yo(), ct(i.value);\n    const d = P(\"\"), p = P(0), c = P(0), f = P(null), v = P(\"right\"), g = P(0), w = P(null), { createCollection: E } = ve(), { forwardRef: _, currentElement: x } = $(), B = E(x);\n    U(x, (I) => {\n      s.onContentChange(I);\n    });\n    const { handleTypeaheadSearch: O } = bo(B);\n    fe(() => {\n      window.clearTimeout(p.value);\n    });\n    function A(I) {\n      var W, J;\n      return v.value === ((W = f.value) == null ? void 0 : W.side) && nr(I, (J = f.value) == null ? void 0 : J.area);\n    }\n    async function M(I) {\n      var F;\n      a(\"openAutoFocus\", I), !I.defaultPrevented && (I.preventDefault(), (F = x.value) == null || F.focus());\n    }\n    function R(I) {\n      if (I.defaultPrevented)\n        return;\n      const W = I.target.closest(\"[data-radix-menu-content]\") === I.currentTarget, J = I.ctrlKey || I.altKey || I.metaKey, K = I.key.length === 1, Z = Je(\n        I,\n        document.activeElement,\n        x.value,\n        {\n          loop: u.value,\n          arrowKeyOptions: \"vertical\",\n          dir: r == null ? void 0 : r.dir.value,\n          focus: !0,\n          attributeName: \"[data-radix-vue-collection-item]:not([data-disabled])\"\n        }\n      );\n      if (Z)\n        return Z == null ? void 0 : Z.focus();\n      if (I.code === \"Space\" || (W && (I.key === \"Tab\" && I.preventDefault(), !J && K && O(I.key)), I.target !== x.value) || !Qs.includes(I.key))\n        return;\n      I.preventDefault();\n      const ne = B.value;\n      kn.includes(I.key) && ne.reverse(), ao(ne);\n    }\n    function V(I) {\n      var F, W;\n      (W = (F = I == null ? void 0 : I.currentTarget) == null ? void 0 : F.contains) != null && W.call(F, I.target) || (window.clearTimeout(p.value), d.value = \"\");\n    }\n    function j(I) {\n      var J;\n      if (!rt(I))\n        return;\n      const F = I.target, W = g.value !== I.clientX;\n      if ((J = I == null ? void 0 : I.currentTarget) != null && J.contains(F) && W) {\n        const K = I.clientX > g.value ? \"right\" : \"left\";\n        v.value = K, g.value = I.clientX;\n      }\n    }\n    return Gr({\n      onItemEnter: (I) => !!A(I),\n      onItemLeave: (I) => {\n        var F;\n        A(I) || ((F = x.value) == null || F.focus(), w.value = null);\n      },\n      onTriggerLeave: (I) => !!A(I),\n      searchRef: d,\n      pointerGraceTimerRef: c,\n      onPointerGraceIntentChange: (I) => {\n        f.value = I;\n      }\n    }), (I, F) => (h(), C(n(At), {\n      \"as-child\": \"\",\n      trapped: n(l),\n      onMountAutoFocus: M,\n      onUnmountAutoFocus: F[7] || (F[7] = (W) => a(\"closeAutoFocus\", W))\n    }, {\n      default: m(() => [\n        k(n(De), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": n(i),\n          onEscapeKeyDown: F[2] || (F[2] = (W) => a(\"escapeKeyDown\", W)),\n          onPointerDownOutside: F[3] || (F[3] = (W) => a(\"pointerDownOutside\", W)),\n          onFocusOutside: F[4] || (F[4] = (W) => a(\"focusOutside\", W)),\n          onInteractOutside: F[5] || (F[5] = (W) => a(\"interactOutside\", W)),\n          onDismiss: F[6] || (F[6] = (W) => a(\"dismiss\"))\n        }, {\n          default: m(() => [\n            k(n(et), {\n              \"current-tab-stop-id\": w.value,\n              \"onUpdate:currentTabStopId\": F[0] || (F[0] = (W) => w.value = W),\n              \"as-child\": \"\",\n              orientation: \"vertical\",\n              dir: n(r).dir.value,\n              loop: n(u),\n              onEntryFocus: F[1] || (F[1] = (W) => {\n                a(\"entryFocus\", W), n(r).isUsingKeyboardRef.value || W.preventDefault();\n              })\n            }, {\n              default: m(() => [\n                k(n(Fe), {\n                  ref: n(_),\n                  role: \"menu\",\n                  as: I.as,\n                  \"as-child\": I.asChild,\n                  \"aria-orientation\": \"vertical\",\n                  \"data-radix-menu-content\": \"\",\n                  \"data-state\": n(xo)(n(s).open.value),\n                  dir: n(r).dir.value,\n                  side: I.side,\n                  \"side-offset\": I.sideOffset,\n                  align: I.align,\n                  \"align-offset\": I.alignOffset,\n                  \"avoid-collisions\": I.avoidCollisions,\n                  \"collision-boundary\": I.collisionBoundary,\n                  \"collision-padding\": I.collisionPadding,\n                  \"arrow-padding\": I.arrowPadding,\n                  \"prioritize-position\": I.prioritizePosition,\n                  sticky: I.sticky,\n                  \"hide-when-detached\": I.hideWhenDetached,\n                  onKeydown: R,\n                  onBlur: V,\n                  onPointermove: j\n                }, {\n                  default: m(() => [\n                    y(I.$slots, \"default\")\n                  ]),\n                  _: 3\n                }, 8, [\"as\", \"as-child\", \"data-state\", \"dir\", \"side\", \"side-offset\", \"align\", \"align-offset\", \"avoid-collisions\", \"collision-boundary\", \"collision-padding\", \"arrow-padding\", \"prioritize-position\", \"sticky\", \"hide-when-detached\"])\n              ]),\n              _: 3\n            }, 8, [\"current-tab-stop-id\", \"dir\", \"loop\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), Gn = /* @__PURE__ */ b({\n  __name: \"MenuItemImpl\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Io(), a = P(!1);\n    async function s(l) {\n      if (!l.defaultPrevented && rt(l)) {\n        if (t.disabled)\n          e.onItemLeave(l);\n        else if (!e.onItemEnter(l)) {\n          const u = l.currentTarget;\n          u == null || u.focus();\n        }\n      }\n    }\n    async function r(l) {\n      await G(), !l.defaultPrevented && rt(l) && e.onItemLeave(l);\n    }\n    return (l, i) => (h(), C(n(D), {\n      role: \"menuitem\",\n      tabindex: \"-1\",\n      as: l.as,\n      \"as-child\": l.asChild,\n      \"data-radix-vue-collection-item\": \"\",\n      \"aria-disabled\": l.disabled || void 0,\n      \"data-disabled\": l.disabled ? \"\" : void 0,\n      \"data-highlighted\": a.value ? \"\" : void 0,\n      onPointermove: s,\n      onPointerleave: r,\n      onFocus: i[0] || (i[0] = async (u) => {\n        await G(), !(u.defaultPrevented || l.disabled) && (a.value = !0);\n      }),\n      onBlur: i[1] || (i[1] = async (u) => {\n        await G(), !u.defaultPrevented && (a.value = !1);\n      })\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-disabled\", \"data-disabled\", \"data-highlighted\"]));\n  }\n}), vt = /* @__PURE__ */ b({\n  __name: \"MenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { forwardRef: s, currentElement: r } = $(), l = ft(), i = Io(), u = P(!1);\n    async function d() {\n      const p = r.value;\n      if (!e.disabled && p) {\n        const c = new CustomEvent(Js, {\n          bubbles: !0,\n          cancelable: !0\n        });\n        a(\"select\", c), await G(), c.defaultPrevented ? u.value = !1 : l.onClose();\n      }\n    }\n    return (p, c) => (h(), C(Gn, T(e, {\n      ref: n(s),\n      onClick: d,\n      onPointerdown: c[0] || (c[0] = () => {\n        u.value = !0;\n      }),\n      onPointerup: c[1] || (c[1] = async (f) => {\n        var v;\n        await G(), !f.defaultPrevented && (u.value || (v = f.currentTarget) == null || v.click());\n      }),\n      onKeydown: c[2] || (c[2] = async (f) => {\n        const v = n(i).searchRef.value !== \"\";\n        p.disabled || v && f.key === \" \" || n(no).includes(f.key) && (f.currentTarget.click(), f.preventDefault());\n      })\n    }), {\n      default: m(() => [\n        y(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Yr, Yn] = H(\n  [\"MenuCheckboxItem\", \"MenuRadioItem\"],\n  \"MenuItemIndicatorContext\"\n), Ro = /* @__PURE__ */ b({\n  __name: \"MenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = Yr({\n      checked: P(!1)\n    });\n    return (e, a) => (h(), C(n(se), {\n      present: e.forceMount || n(Pt)(n(t).checked.value) || n(t).checked.value === !0\n    }, {\n      default: m(() => [\n        k(n(D), {\n          as: e.as,\n          \"as-child\": e.asChild,\n          \"data-state\": n(Eo)(n(t).checked.value)\n        }, {\n          default: m(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Mo = /* @__PURE__ */ b({\n  __name: \"MenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String], default: !1 },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = Y(e, \"checked\", a);\n    return Yn({ checked: s }), (r, l) => (h(), C(vt, T({ role: \"menuitemcheckbox\" }, e, {\n      \"aria-checked\": n(Pt)(n(s)) ? \"mixed\" : n(s),\n      \"data-state\": n(Eo)(n(s)),\n      onSelect: l[0] || (l[0] = async (i) => {\n        a(\"select\", i), n(Pt)(n(s)) ? s.value = !0 : s.value = !n(s);\n      })\n    }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), Xr = /* @__PURE__ */ b({\n  __name: \"MenuRootContentModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = ae(e, a), r = ze(), { forwardRef: l, currentElement: i } = $();\n    return pt(i), (u, d) => (h(), C(Ao, T(n(s), {\n      ref: n(l),\n      \"trap-focus\": n(r).open.value,\n      \"disable-outside-pointer-events\": n(r).open.value,\n      \"disable-outside-scroll\": !0,\n      onDismiss: d[0] || (d[0] = (p) => n(r).onOpenChange(!1)),\n      onFocusOutside: d[1] || (d[1] = oe((p) => a(\"focusOutside\", p), [\"prevent\"]))\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\", \"disable-outside-pointer-events\"]));\n  }\n}), Jr = /* @__PURE__ */ b({\n  __name: \"MenuRootContentNonModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t), r = ze();\n    return (l, i) => (h(), C(Ao, T(n(s), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      \"disable-outside-scroll\": !1,\n      onDismiss: i[0] || (i[0] = (u) => n(r).onOpenChange(!1))\n    }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ko = /* @__PURE__ */ b({\n  __name: \"MenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t), r = ze(), l = ft();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(r).open.value\n    }, {\n      default: m(() => [\n        n(l).modal.value ? (h(), C(Xr, L(T({ key: 0 }, { ...i.$attrs, ...n(s) })), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (h(), C(Jr, L(T({ key: 1 }, { ...i.$attrs, ...n(s) })), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Mt = /* @__PURE__ */ b({\n  __name: \"MenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(D), T({ role: \"group\" }, t), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vo = /* @__PURE__ */ b({\n  __name: \"MenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(D), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Fo = /* @__PURE__ */ b({\n  __name: \"MenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Zr, Qr] = H(\"MenuRadioGroup\"), Lo = /* @__PURE__ */ b({\n  __name: \"MenuRadioGroup\",\n  props: {\n    modelValue: { default: \"\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = Y(e, \"modelValue\", t);\n    return Qr({\n      modelValue: s,\n      onValueChange: (r) => {\n        s.value = r;\n      }\n    }), (r, l) => (h(), C(Mt, L(N(e)), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ko = /* @__PURE__ */ b({\n  __name: \"MenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { value: s } = z(e), r = Zr(), l = S(\n      () => r.modelValue.value === (s == null ? void 0 : s.value)\n    );\n    return Yn({ checked: l }), (i, u) => (h(), C(vt, T({ role: \"menuitemradio\" }, e, {\n      \"aria-checked\": l.value,\n      \"data-state\": n(Eo)(l.value),\n      onSelect: u[0] || (u[0] = async (d) => {\n        a(\"select\", d), n(r).onValueChange(n(s));\n      })\n    }), {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), No = /* @__PURE__ */ b({\n  __name: \"MenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(D), T(t, {\n      role: \"separator\",\n      \"aria-orientation\": \"horizontal\"\n    }), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Xn, el] = H(\"MenuSub\"), Ho = /* @__PURE__ */ b({\n  __name: \"MenuSub\",\n  props: {\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, s = Y(e, \"open\", t, {\n      defaultValue: !1,\n      passive: e.open === void 0\n    }), r = ze(), l = P(), i = P();\n    return ee((u) => {\n      (r == null ? void 0 : r.open.value) === !1 && (s.value = !1), u(() => s.value = !1);\n    }), Un({\n      open: s,\n      onOpenChange: (u) => {\n        s.value = u;\n      },\n      content: i,\n      onContentChange: (u) => {\n        i.value = u;\n      }\n    }), el({\n      triggerId: te(),\n      contentId: te(),\n      trigger: l,\n      onTriggerChange: (u) => {\n        l.value = u;\n      }\n    }), (u, d) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), jo = /* @__PURE__ */ b({\n  __name: \"MenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t), r = ze(), l = ft(), i = Xn(), { forwardRef: u, currentElement: d } = $();\n    return (p, c) => (h(), C(n(se), {\n      present: p.forceMount || n(r).open.value\n    }, {\n      default: m(() => [\n        k(Ao, T(n(s), {\n          id: n(i).contentId,\n          ref: n(u),\n          \"aria-labelledby\": n(i).triggerId,\n          align: \"start\",\n          side: n(l).dir.value === \"rtl\" ? \"left\" : \"right\",\n          \"disable-outside-pointer-events\": !1,\n          \"disable-outside-scroll\": !1,\n          \"trap-focus\": !1,\n          onOpenAutoFocus: c[0] || (c[0] = oe((f) => {\n            var v;\n            n(l).isUsingKeyboardRef.value && ((v = n(d)) == null || v.focus());\n          }, [\"prevent\"])),\n          onCloseAutoFocus: c[1] || (c[1] = oe(() => {\n          }, [\"prevent\"])),\n          onFocusOutside: c[2] || (c[2] = (f) => {\n            f.defaultPrevented || f.target !== n(i).trigger.value && n(r).onOpenChange(!1);\n          }),\n          onEscapeKeyDown: c[3] || (c[3] = (f) => {\n            n(l).onClose(), f.preventDefault();\n          }),\n          onKeydown: c[4] || (c[4] = (f) => {\n            var w, E;\n            const v = (w = f.currentTarget) == null ? void 0 : w.contains(f.target), g = n(tr)[n(l).dir.value].includes(f.key);\n            v && g && (n(r).onOpenChange(!1), (E = n(i).trigger.value) == null || E.focus(), f.preventDefault());\n          })\n        }), {\n          default: m(() => [\n            y(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-labelledby\", \"side\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Wo = /* @__PURE__ */ b({\n  __name: \"MenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = ze(), a = ft(), s = Xn(), r = Io(), l = P(null);\n    function i() {\n      l.value && window.clearTimeout(l.value), l.value = null;\n    }\n    fe(() => {\n      i();\n    });\n    function u(c) {\n      !rt(c) || r.onItemEnter(c) || !t.disabled && !e.open.value && !l.value && (r.onPointerGraceIntentChange(null), l.value = window.setTimeout(() => {\n        e.onOpenChange(!0), i();\n      }, 100));\n    }\n    async function d(c) {\n      var v, g;\n      if (!rt(c))\n        return;\n      i();\n      const f = (v = e.content.value) == null ? void 0 : v.getBoundingClientRect();\n      if (f != null && f.width) {\n        const w = (g = e.content.value) == null ? void 0 : g.dataset.side, E = w === \"right\", _ = E ? -5 : 5, x = f[E ? \"left\" : \"right\"], B = f[E ? \"right\" : \"left\"];\n        r.onPointerGraceIntentChange({\n          area: [\n            // Apply a bleed on clientX to ensure that our exit point is\n            // consistently within polygon bounds\n            { x: c.clientX + _, y: c.clientY },\n            { x, y: f.top },\n            { x: B, y: f.top },\n            { x: B, y: f.bottom },\n            { x, y: f.bottom }\n          ],\n          side: w\n        }), window.clearTimeout(r.pointerGraceTimerRef.value), r.pointerGraceTimerRef.value = window.setTimeout(\n          () => r.onPointerGraceIntentChange(null),\n          300\n        );\n      } else {\n        if (r.onTriggerLeave(c))\n          return;\n        r.onPointerGraceIntentChange(null);\n      }\n    }\n    async function p(c) {\n      var v;\n      const f = r.searchRef.value !== \"\";\n      t.disabled || f && c.key === \" \" || er[a.dir.value].includes(c.key) && (e.onOpenChange(!0), await G(), (v = e.content.value) == null || v.focus(), c.preventDefault());\n    }\n    return (c, f) => (h(), C(Rt, { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(Gn, T(t, {\n          id: n(s).triggerId,\n          ref: (v) => {\n            var g;\n            (g = n(s)) == null || g.onTriggerChange(v == null ? void 0 : v.$el);\n          },\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": n(e).open.value,\n          \"aria-controls\": n(s).contentId,\n          \"data-state\": n(xo)(n(e).open.value),\n          onClick: f[0] || (f[0] = async (v) => {\n            t.disabled || v.defaultPrevented || (v.currentTarget.focus(), n(e).open.value || n(e).onOpenChange(!0));\n          }),\n          onPointermove: u,\n          onPointerleave: d,\n          onKeydown: p\n        }), {\n          default: m(() => [\n            y(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-expanded\", \"aria-controls\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), [Jn, tl] = H(\"ContextMenuRoot\"), Fu = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"ContextMenuRoot\",\n  props: {\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { dir: s, modal: r } = z(e);\n    $();\n    const l = de(s), i = P(!1);\n    return tl({\n      open: i,\n      onOpenChange: (u) => {\n        i.value = u;\n      },\n      dir: l,\n      modal: r\n    }), U(i, (u) => {\n      a(\"update:open\", u);\n    }), (u, d) => (h(), C(n(Oo), {\n      open: i.value,\n      \"onUpdate:open\": d[0] || (d[0] = (p) => i.value = p),\n      dir: n(l),\n      modal: n(r)\n    }, {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n});\nfunction un(o) {\n  return o.pointerType !== \"mouse\";\n}\nconst Lu = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"ContextMenuTrigger\",\n  props: {\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, { disabled: e } = z(t), { forwardRef: a } = $(), s = Jn(), r = P({ x: 0, y: 0 }), l = S(() => ({\n      getBoundingClientRect: () => ({\n        width: 0,\n        height: 0,\n        left: r.value.x,\n        right: r.value.x,\n        top: r.value.y,\n        bottom: r.value.y,\n        ...r.value\n      })\n    })), i = P(0);\n    function u() {\n      window.clearTimeout(i.value);\n    }\n    function d(v) {\n      r.value = { x: v.clientX, y: v.clientY }, s.onOpenChange(!0);\n    }\n    async function p(v) {\n      e.value || (await G(), v.defaultPrevented || (u(), d(v), v.preventDefault()));\n    }\n    async function c(v) {\n      e.value || (await G(), un(v) && !v.defaultPrevented && (u(), i.value = window.setTimeout(() => d(v), 700)));\n    }\n    async function f(v) {\n      e.value || (await G(), un(v) && !v.defaultPrevented && u());\n    }\n    return (v, g) => (h(), Q(le, null, [\n      k(n(Rt), {\n        as: \"template\",\n        element: l.value\n      }, null, 8, [\"element\"]),\n      k(n(D), T({\n        ref: n(a),\n        as: v.as,\n        \"as-child\": v.asChild,\n        \"data-state\": n(s).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": n(e) ? \"\" : void 0,\n        style: {\n          WebkitTouchCallout: \"none\"\n        }\n      }, v.$attrs, {\n        onContextmenu: p,\n        onPointerdown: c,\n        onPointermove: f,\n        onPointercancel: f,\n        onPointerup: f\n      }), {\n        default: m(() => [\n          y(v.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"])\n    ], 64));\n  }\n}), Ku = /* @__PURE__ */ b({\n  __name: \"ContextMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Fo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nu = /* @__PURE__ */ b({\n  __name: \"ContextMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    alignOffset: { default: 0 },\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t);\n    $();\n    const r = Jn(), l = P(!1);\n    return (i, u) => (h(), C(n(ko), T(n(s), {\n      side: \"right\",\n      \"side-offset\": 2,\n      align: \"start\",\n      style: {\n        \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: u[0] || (u[0] = (d) => {\n        !d.defaultPrevented && l.value && d.preventDefault(), l.value = !1;\n      }),\n      onInteractOutside: u[1] || (u[1] = (d) => {\n        !d.defaultPrevented && !n(r).modal.value && (l.value = !0);\n      })\n    }), {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), Hu = /* @__PURE__ */ b({\n  __name: \"ContextMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Do), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ju = /* @__PURE__ */ b({\n  __name: \"ContextMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(vt), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Wu = /* @__PURE__ */ b({\n  __name: \"ContextMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Mt), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), zu = /* @__PURE__ */ b({\n  __name: \"ContextMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(No), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Uu = /* @__PURE__ */ b({\n  __name: \"ContextMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Mo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), qu = /* @__PURE__ */ b({\n  __name: \"ContextMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Ro), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Gu = /* @__PURE__ */ b({\n  __name: \"ContextMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Vo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Yu = /* @__PURE__ */ b({\n  __name: \"ContextMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Lo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xu = /* @__PURE__ */ b({\n  __name: \"ContextMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Ko), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ju = /* @__PURE__ */ b({\n  __name: \"ContextMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t;\n    $();\n    const s = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (r, l) => (h(), C(n(Ho), {\n      open: n(s),\n      \"onUpdate:open\": l[0] || (l[0] = (i) => dt(s) ? s.value = i : null)\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), Zu = /* @__PURE__ */ b({\n  __name: \"ContextMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t);\n    return $(), (r, l) => (h(), C(n(jo), T(n(s), { style: {\n      \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), Qu = /* @__PURE__ */ b({\n  __name: \"ContextMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Wo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Zn, ol] = H(\"DropdownMenuRoot\"), ed = /* @__PURE__ */ b({\n  __name: \"DropdownMenuRoot\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 },\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t;\n    $();\n    const s = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = P(), { modal: l, dir: i } = z(e), u = de(i);\n    return ol({\n      open: s,\n      onOpenChange: (d) => {\n        s.value = d;\n      },\n      onOpenToggle: () => {\n        s.value = !s.value;\n      },\n      triggerId: te(),\n      triggerElement: r,\n      contentId: te(),\n      modal: l,\n      dir: u\n    }), (d, p) => (h(), C(n(Oo), {\n      open: n(s),\n      \"onUpdate:open\": p[0] || (p[0] = (c) => dt(s) ? s.value = c : null),\n      dir: n(u),\n      modal: n(l)\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n}), td = /* @__PURE__ */ b({\n  __name: \"DropdownMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Zn(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.triggerElement = s;\n    }), (r, l) => (h(), C(n(Rt), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), {\n          id: n(e).triggerId,\n          ref: n(a),\n          type: r.as === \"button\" ? \"button\" : void 0,\n          \"as-child\": t.asChild,\n          as: r.as,\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": n(e).open.value,\n          \"aria-controls\": n(e).open.value ? n(e).contentId : void 0,\n          \"data-disabled\": r.disabled ? \"\" : void 0,\n          disabled: r.disabled,\n          \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n          onClick: l[0] || (l[0] = async (i) => {\n            var u;\n            !r.disabled && i.button === 0 && i.ctrlKey === !1 && ((u = n(e)) == null || u.onOpenToggle(), await G(), n(e).open.value && i.preventDefault());\n          }),\n          onKeydown: l[1] || (l[1] = ie(\n            (i) => {\n              r.disabled || ([\"Enter\", \" \"].includes(i.key) && n(e).onOpenToggle(), i.key === \"ArrowDown\" && n(e).onOpenChange(!0), [\"Enter\", \" \", \"ArrowDown\"].includes(i.key) && i.preventDefault());\n            },\n            [\"enter\", \"space\", \"arrow-down\"]\n          ))\n        }, {\n          default: m(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as-child\", \"as\", \"aria-expanded\", \"aria-controls\", \"data-disabled\", \"disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), od = /* @__PURE__ */ b({\n  __name: \"DropdownMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Fo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), nd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t);\n    $();\n    const r = Zn(), l = P(!1);\n    function i(u) {\n      u.defaultPrevented || (l.value || setTimeout(() => {\n        var d;\n        (d = r.triggerElement.value) == null || d.focus();\n      }, 0), l.value = !1, u.preventDefault());\n    }\n    return (u, d) => {\n      var p;\n      return h(), C(n(ko), T(n(s), {\n        id: n(r).contentId,\n        \"aria-labelledby\": (p = n(r)) == null ? void 0 : p.triggerId,\n        style: {\n          \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        },\n        onCloseAutoFocus: i,\n        onInteractOutside: d[0] || (d[0] = (c) => {\n          var w;\n          if (c.defaultPrevented)\n            return;\n          const f = c.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, g = f.button === 2 || v;\n          (!n(r).modal.value || g) && (l.value = !0), (w = n(r).triggerElement.value) != null && w.contains(c.target) && c.preventDefault();\n        })\n      }), {\n        default: m(() => [\n          y(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"aria-labelledby\", \"style\"]);\n    };\n  }\n}), ad = /* @__PURE__ */ b({\n  __name: \"DropdownMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Do), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(vt), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Mt), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ld = /* @__PURE__ */ b({\n  __name: \"DropdownMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(No), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), id = /* @__PURE__ */ b({\n  __name: \"DropdownMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Mo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ud = /* @__PURE__ */ b({\n  __name: \"DropdownMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Ro), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Vo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), cd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Lo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), pd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t);\n    return $(), (r, l) => (h(), C(n(Ko), L(N(n(s))), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, s = Y(e, \"open\", t, {\n      passive: e.open === void 0,\n      defaultValue: e.defaultOpen ?? !1\n    });\n    return $(), (r, l) => (h(), C(n(Ho), {\n      open: n(s),\n      \"onUpdate:open\": l[0] || (l[0] = (i) => dt(s) ? s.value = i : null)\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), vd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t);\n    return $(), (r, l) => (h(), C(n(jo), T(n(s), { style: {\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), md = /* @__PURE__ */ b({\n  __name: \"DropdownMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Wo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [zo, nl] = H(\"HoverCardRoot\"), hd = /* @__PURE__ */ b({\n  __name: \"HoverCardRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    openDelay: { default: 700 },\n    closeDelay: { default: 300 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { openDelay: s, closeDelay: r } = z(e);\n    $();\n    const l = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), i = P(0), u = P(0), d = P(!1), p = P(!1);\n    function c() {\n      clearTimeout(u.value), i.value = window.setTimeout(() => l.value = !0, s.value);\n    }\n    function f() {\n      clearTimeout(i.value), !d.value && !p.value && (u.value = window.setTimeout(() => l.value = !1, r.value));\n    }\n    function v() {\n      l.value = !1;\n    }\n    return nl({\n      open: l,\n      onOpenChange(g) {\n        l.value = g;\n      },\n      onOpen: c,\n      onClose: f,\n      onDismiss: v,\n      hasSelectionRef: d,\n      isPointerDownOnContentRef: p\n    }), (g, w) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(g.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n});\nfunction St(o) {\n  return (t) => t.pointerType === \"touch\" ? void 0 : o();\n}\nfunction al(o) {\n  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (a) => a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  });\n  for (; e.nextNode(); )\n    t.push(e.currentNode);\n  return t;\n}\nconst gd = /* @__PURE__ */ b({\n  __name: \"HoverCardTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(o) {\n    const { forwardRef: t } = $(), e = zo();\n    return (a, s) => (h(), C(n(We), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(t),\n          \"as-child\": a.asChild,\n          as: a.as,\n          \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n          onPointerenter: s[0] || (s[0] = (r) => n(St)(n(e).onOpen)(r)),\n          onPointerleave: s[1] || (s[1] = (r) => n(St)(n(e).onClose)(r)),\n          onFocus: s[2] || (s[2] = (r) => n(e).onOpen()),\n          onBlur: n(e).onClose,\n          onTouchstart: oe(() => {\n          }, [\"prevent\"])\n        }, {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"data-state\", \"onBlur\"])\n      ]),\n      _: 3\n    }));\n  }\n}), yd = /* @__PURE__ */ b({\n  __name: \"HoverCardPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sl = /* @__PURE__ */ b({\n  __name: \"HoverCardContentImpl\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = He(e), { forwardRef: r, currentElement: l } = $(), i = zo(), u = P(!1);\n    let d;\n    ee((c) => {\n      if (u.value) {\n        const f = document.body;\n        d = f.style.userSelect || f.style.webkitUserSelect, f.style.userSelect = \"none\", f.style.webkitUserSelect = \"none\", c(() => {\n          f.style.userSelect = d, f.style.webkitUserSelect = d;\n        });\n      }\n    });\n    function p() {\n      u.value = !1, i.isPointerDownOnContentRef.value = !1, G(() => {\n        var f;\n        ((f = document.getSelection()) == null ? void 0 : f.toString()) !== \"\" && (i.hasSelectionRef.value = !0);\n      });\n    }\n    return q(() => {\n      l.value && (document.addEventListener(\"pointerup\", p), al(l.value).forEach((f) => f.setAttribute(\"tabindex\", \"-1\")));\n    }), fe(() => {\n      document.removeEventListener(\"pointerup\", p), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;\n    }), (c, f) => (h(), C(n(De), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: f[1] || (f[1] = (v) => a(\"escapeKeyDown\", v)),\n      onPointerDownOutside: f[2] || (f[2] = (v) => a(\"pointerDownOutside\", v)),\n      onFocusOutside: f[3] || (f[3] = oe((v) => a(\"focusOutside\", v), [\"prevent\"])),\n      onDismiss: n(i).onDismiss\n    }, {\n      default: m(() => [\n        k(n(Fe), T({ ...n(s), ...c.$attrs }, {\n          ref: n(r),\n          \"data-state\": n(i).open.value ? \"open\" : \"closed\",\n          style: {\n            userSelect: u.value ? \"text\" : void 0,\n            // Safari requires prefix\n            WebkitUserSelect: u.value ? \"text\" : void 0,\n            // re-namespace exposed content custom properties\n            \"--radix-hover-card-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n            \"--radix-hover-card-content-available-width\": \"var(--radix-popper-available-width)\",\n            \"--radix-hover-card-content-available-height\": \"var(--radix-popper-available-height)\",\n            \"--radix-hover-card-trigger-width\": \"var(--radix-popper-anchor-width)\",\n            \"--radix-hover-card-trigger-height\": \"var(--radix-popper-anchor-height)\"\n          },\n          onPointerdown: f[0] || (f[0] = (v) => {\n            v.currentTarget.contains(v.target) && (u.value = !0), n(i).hasSelectionRef.value = !1, n(i).isPointerDownOnContentRef.value = !0;\n          })\n        }), {\n          default: m(() => [\n            y(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"onDismiss\"]));\n  }\n}), bd = /* @__PURE__ */ b({\n  __name: \"HoverCardContent\",\n  props: {\n    forceMount: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t), { forwardRef: r } = $(), l = zo();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(l).open.value\n    }, {\n      default: m(() => [\n        k(sl, T(n(s), {\n          ref: n(r),\n          onPointerenter: u[0] || (u[0] = (d) => n(St)(n(l).onOpen)(d)),\n          onPointerleave: u[1] || (u[1] = (d) => n(St)(n(l).onClose)(d))\n        }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Cd = /* @__PURE__ */ b({\n  __name: \"HoverCardArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Ze), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), wd = /* @__PURE__ */ b({\n  __name: \"Label\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"label\" }\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(D), T(t, {\n      onMousedown: a[0] || (a[0] = (s) => {\n        !s.defaultPrevented && s.detail > 1 && s.preventDefault();\n      })\n    }), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [kt, rl] = H(\"MenubarRoot\"), _d = /* @__PURE__ */ b({\n  __name: \"MenubarRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    dir: {},\n    loop: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { forwardRef: s, currentElement: r } = $(), { createCollection: l } = ve(\"menubar\");\n    l(r);\n    const i = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), u = P(null), { dir: d, loop: p } = z(e), c = de(d);\n    return rl({\n      modelValue: i,\n      dir: c,\n      loop: p,\n      onMenuOpen: (f) => {\n        i.value = f, u.value = f;\n      },\n      onMenuClose: () => {\n        i.value = \"\";\n      },\n      onMenuToggle: (f) => {\n        i.value = i.value ? \"\" : f, u.value = f;\n      }\n    }), (f, v) => (h(), C(n(et), {\n      \"current-tab-stop-id\": u.value,\n      \"onUpdate:currentTabStopId\": v[0] || (v[0] = (g) => u.value = g),\n      orientation: \"horizontal\",\n      loop: n(p),\n      dir: n(c),\n      \"as-child\": \"\"\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(s),\n          role: \"menubar\"\n        }, {\n          default: m(() => [\n            y(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 512)\n      ]),\n      _: 3\n    }, 8, [\"current-tab-stop-id\", \"loop\", \"dir\"]));\n  }\n}), [Uo, ll] = H(\"MenubarMenu\"), $d = /* @__PURE__ */ b({\n  __name: \"MenubarMenu\",\n  props: {\n    value: {}\n  },\n  setup(o) {\n    const e = o.value ?? te(), a = kt();\n    $();\n    const s = P(), r = P(!1), l = S(() => a.modelValue.value === e);\n    return U(l, () => {\n      l.value || (r.value = !1);\n    }), ll({\n      value: e,\n      triggerElement: s,\n      triggerId: e,\n      contentId: te(),\n      wasKeyboardTriggerOpenRef: r\n    }), (i, u) => (h(), C(n(Oo), {\n      open: l.value,\n      modal: !1,\n      dir: n(a).dir.value,\n      \"onUpdate:open\": u[0] || (u[0] = (d) => {\n        d || n(a).onMenuClose();\n      })\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\"]));\n  }\n}), xd = /* @__PURE__ */ b({\n  __name: \"MenubarTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = kt(), e = Uo(), { forwardRef: a, currentElement: s } = $(), r = P(!1), l = S(() => t.modelValue.value === e.value);\n    return q(() => {\n      e.triggerElement = s;\n    }), (i, u) => (h(), C(n(tt), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      \"tab-stop-id\": n(e).value\n    }, {\n      default: m(() => [\n        k(n(Rt), { \"as-child\": \"\" }, {\n          default: m(() => [\n            k(n(D), {\n              id: n(e).triggerId,\n              ref: n(a),\n              as: i.as,\n              type: i.as === \"button\" ? \"button\" : void 0,\n              role: \"menuitem\",\n              \"aria-haspopup\": \"menu\",\n              \"aria-expanded\": l.value,\n              \"aria-controls\": l.value ? n(e).contentId : void 0,\n              \"data-highlighted\": r.value ? \"\" : void 0,\n              \"data-state\": l.value ? \"open\" : \"closed\",\n              \"data-disabled\": i.disabled ? \"\" : void 0,\n              disabled: i.disabled,\n              \"data-value\": n(e).value,\n              \"data-radix-vue-collection-item\": \"\",\n              onPointerdown: u[0] || (u[0] = (d) => {\n                !i.disabled && d.button === 0 && d.ctrlKey === !1 && (n(t).onMenuOpen(n(e).value), l.value || d.preventDefault());\n              }),\n              onPointerenter: u[1] || (u[1] = () => {\n                var p;\n                !!n(t).modelValue.value && !l.value && (n(t).onMenuOpen(n(e).value), (p = n(s)) == null || p.focus());\n              }),\n              onKeydown: u[2] || (u[2] = ie((d) => {\n                i.disabled || ([\"Enter\", \" \"].includes(d.key) && n(t).onMenuToggle(n(e).value), d.key === \"ArrowDown\" && n(t).onMenuOpen(n(e).value), [\"Enter\", \" \", \"ArrowDown\"].includes(d.key) && (n(e).wasKeyboardTriggerOpenRef.value = !0, d.preventDefault()));\n              }, [\"enter\", \"space\", \"arrow-down\"])),\n              onFocus: u[3] || (u[3] = (d) => r.value = !0),\n              onBlur: u[4] || (u[4] = (d) => r.value = !1)\n            }, {\n              default: m(() => [\n                y(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 8, [\"id\", \"as\", \"type\", \"aria-expanded\", \"aria-controls\", \"data-highlighted\", \"data-state\", \"data-disabled\", \"disabled\", \"data-value\"])\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"tab-stop-id\"]));\n  }\n}), Ed = /* @__PURE__ */ b({\n  __name: \"MenubarPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Fo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Pd = /* @__PURE__ */ b({\n  __name: \"MenubarContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t);\n    $();\n    const r = kt(), l = Uo(), { injectCollection: i } = ve(\"menubar\"), u = i(), d = P(!1);\n    function p(c) {\n      const v = c.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ), w = (r.dir.value === \"rtl\" ? \"ArrowRight\" : \"ArrowLeft\") === c.key;\n      if (!w && v)\n        return;\n      let _ = u.value.map((O) => O.dataset.value);\n      w && _.reverse();\n      const x = _.indexOf(l.value);\n      _ = r.loop.value ? Co(_, x + 1) : _.slice(x + 1);\n      const [B] = _;\n      B && r.onMenuOpen(B);\n    }\n    return (c, f) => (h(), C(n(ko), T({\n      id: n(l).contentId\n    }, n(s), {\n      \"aria-labelledby\": n(l).triggerId,\n      \"data-radix-menubar-content\": \"\",\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: f[0] || (f[0] = (v) => {\n        var w;\n        !!!n(r).modelValue.value && !d.value && ((w = n(l).triggerElement.value) == null || w.focus()), d.value = !1, v.preventDefault();\n      }),\n      onFocusOutside: f[1] || (f[1] = (v) => {\n        const g = v.target;\n        n(u).some((E) => E.contains(g)) && v.preventDefault();\n      }),\n      onInteractOutside: f[2] || (f[2] = (v) => {\n        d.value = !0;\n      }),\n      onEntryFocus: f[3] || (f[3] = (v) => {\n        n(l).wasKeyboardTriggerOpenRef.value || v.preventDefault();\n      }),\n      onKeydown: ie(p, [\"arrow-right\", \"arrow-left\"])\n    }), {\n      default: m(() => [\n        y(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\", \"style\"]));\n  }\n}), Bd = /* @__PURE__ */ b({\n  __name: \"MenubarArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Do), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sd = /* @__PURE__ */ b({\n  __name: \"MenubarItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(vt), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Td = /* @__PURE__ */ b({\n  __name: \"MenubarGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Mt), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Dd = /* @__PURE__ */ b({\n  __name: \"MenubarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(No), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Od = /* @__PURE__ */ b({\n  __name: \"MenubarCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Mo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Id = /* @__PURE__ */ b({\n  __name: \"MenubarItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Ro), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ad = /* @__PURE__ */ b({\n  __name: \"MenubarLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Vo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Rd = /* @__PURE__ */ b({\n  __name: \"MenubarRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Lo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Md = /* @__PURE__ */ b({\n  __name: \"MenubarRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t);\n    return $(), (r, l) => (h(), C(n(Ko), L(N(n(s))), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), kd = /* @__PURE__ */ b({\n  __name: \"MenubarSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t;\n    $();\n    const s = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen ?? !1,\n      passive: e.open === void 0\n    });\n    return (r, l) => (h(), C(n(Ho), {\n      open: n(s),\n      \"onUpdate:open\": l[0] || (l[0] = (i) => dt(s) ? s.value = i : null)\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), Vd = /* @__PURE__ */ b({\n  __name: \"MenubarSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t);\n    $();\n    const { injectCollection: r } = ve(\"menubar\"), l = kt(), i = Uo(), u = r();\n    function d(p) {\n      if (p.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ))\n        return;\n      let v = u.value.map((E) => E.dataset.value);\n      const g = v.indexOf(i.value);\n      v = l.loop.value ? Co(v, g + 1) : v.slice(g + 1);\n      const [w] = v;\n      w && l.onMenuOpen(w);\n    }\n    return (p, c) => (h(), C(n(jo), T(n(s), {\n      \"data-radix-menubar-content\": \"\",\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onKeydown: ie(d, [\"arrow-right\"])\n    }), {\n      default: m(() => [\n        y(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), Fd = /* @__PURE__ */ b({\n  __name: \"MenubarSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Wo), T(t, { \"data-radix-menubar-subtrigger\": \"\" }), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Oe, Qn] = H([\"NavigationMenuRoot\", \"NavigationMenuSub\"], \"NavigationMenuContext\"), Ld = /* @__PURE__ */ b({\n  __name: \"NavigationMenuRoot\",\n  props: {\n    modelValue: { default: void 0 },\n    defaultValue: {},\n    dir: {},\n    orientation: { default: \"horizontal\" },\n    delayDuration: { default: 200 },\n    skipDelayDuration: { default: 300 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = Y(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), r = P(\"\"), { forwardRef: l, currentElement: i } = $(), u = P(), d = P(), { createCollection: p } = ve(\"nav\");\n    p(u);\n    const { delayDuration: c, skipDelayDuration: f, dir: v } = z(e), g = de(v), w = Tt(!1, f), E = S(() => s.value !== \"\" || w.value ? 150 : c.value), _ = mo((x) => {\n      r.value = s.value, s.value = x;\n    }, E);\n    return Qn({\n      isRootMenu: !0,\n      modelValue: s,\n      previousValue: r,\n      baseId: te(),\n      dir: g,\n      orientation: e.orientation,\n      rootNavigationMenu: i,\n      indicatorTrack: u,\n      onIndicatorTrackChange: (x) => {\n        u.value = x;\n      },\n      viewport: d,\n      onViewportChange: (x) => {\n        d.value = x;\n      },\n      onTriggerEnter: (x) => {\n        _(x);\n      },\n      onTriggerLeave: () => {\n        w.value = !0, _(\"\");\n      },\n      onContentEnter: (x) => {\n        _(x);\n      },\n      onContentLeave: () => {\n        _(\"\");\n      },\n      onItemSelect: (x) => {\n        r.value = s.value, s.value = x;\n      },\n      onItemDismiss: () => {\n        r.value = s.value, s.value = \"\";\n      }\n    }), (x, B) => (h(), C(n(D), {\n      ref: n(l),\n      \"aria-label\": \"Main\",\n      as: x.as,\n      \"as-child\": x.asChild,\n      \"data-orientation\": x.orientation,\n      dir: n(g)\n    }, {\n      default: m(() => [\n        y(x.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"dir\"]));\n  }\n});\nfunction Vt(o) {\n  return o ? \"open\" : \"closed\";\n}\nfunction ea(o, t) {\n  return `${o}-trigger-${t}`;\n}\nfunction qo(o, t) {\n  return `${o}-content-${t}`;\n}\nconst Et = \"navigationMenu.rootContentDismiss\";\nfunction ro(o) {\n  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (a) => {\n      const s = a.tagName === \"INPUT\" && a.type === \"hidden\";\n      return a.disabled || a.hidden || s ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); )\n    t.push(e.currentNode);\n  return t;\n}\nfunction ta(o) {\n  const t = document.activeElement;\n  return o.some((e) => e === t ? !0 : (e.focus(), document.activeElement !== t));\n}\nfunction il(o) {\n  return o.forEach((t) => {\n    t.dataset.tabindex = t.getAttribute(\"tabindex\") || \"\", t.setAttribute(\"tabindex\", \"-1\");\n  }), () => {\n    o.forEach((t) => {\n      const e = t.dataset.tabindex;\n      t.setAttribute(\"tabindex\", e);\n    });\n  };\n}\nconst [Go, ul] = H(\"NavigationMenuItem\"), Kd = /* @__PURE__ */ b({\n  __name: \"NavigationMenuItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const { injectCollection: e } = ve(\"nav\"), a = e(), s = Oe(), r = t.value || te(), l = P(), i = P(), u = qo(s.baseId, r);\n    let d = () => ({});\n    const p = P(!1);\n    async function c(w = \"start\") {\n      const E = document.getElementById(u);\n      if (E) {\n        d();\n        const _ = ro(E);\n        _.length && ta(w === \"start\" ? _ : _.reverse());\n      }\n    }\n    function f() {\n      const w = document.getElementById(u);\n      if (w) {\n        const E = ro(w);\n        E.length && (d = il(E));\n      }\n    }\n    ul({\n      value: r,\n      contentId: u,\n      triggerRef: l,\n      focusProxyRef: i,\n      wasEscapeCloseRef: p,\n      onEntryKeyDown: c,\n      onFocusProxyEnter: c,\n      onContentFocusOutside: f,\n      onRootContentClose: f\n    });\n    function v() {\n      var w;\n      s.onItemDismiss(), (w = l.value) == null || w.focus();\n    }\n    function g(w) {\n      const E = document.activeElement;\n      if (w.keyCode === 32 || w.key === \"Enter\")\n        if (s.modelValue.value === r) {\n          v(), w.preventDefault();\n          return;\n        } else {\n          w.target.click(), w.preventDefault();\n          return;\n        }\n      const _ = a.value.filter(\n        (B) => {\n          var O;\n          return (O = B.parentElement) == null ? void 0 : O.hasAttribute(\"data-menu-item\");\n        }\n      ), x = Je(w, E, void 0, {\n        itemsArray: _,\n        loop: !1\n      });\n      x && (x == null || x.focus()), w.preventDefault(), w.stopPropagation();\n    }\n    return (w, E) => (h(), C(n(D), {\n      \"as-child\": w.asChild,\n      as: w.as,\n      \"data-menu-item\": \"\",\n      onKeydown: ie(g, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\", \"space\"])\n    }, {\n      default: m(() => [\n        y(w.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), dl = /* @__PURE__ */ b({\n  __name: \"NavigationMenuContentImpl\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { injectCollection: s } = ve(\"nav\"), r = s(), { forwardRef: l, currentElement: i } = $(), u = Oe(), d = Go(), p = ea(u.baseId, d.value), c = qo(u.baseId, d.value), f = P(null), v = S(() => {\n      const O = r.value.map((I) => I.id.split(\"trigger-\")[1]);\n      u.dir.value === \"rtl\" && O.reverse();\n      const A = O.indexOf(u.modelValue.value), M = O.indexOf(u.previousValue.value), R = d.value === u.modelValue.value, V = M === O.indexOf(d.value);\n      if (!R && !V)\n        return f.value;\n      const j = (() => {\n        if (A !== M) {\n          if (R && M !== -1)\n            return A > M ? \"from-end\" : \"from-start\";\n          if (V && A !== -1)\n            return A > M ? \"to-start\" : \"to-end\";\n        }\n        return null;\n      })();\n      return f.value = j, j;\n    });\n    function g(B) {\n      var O, A;\n      if (a(\"focusOutside\", B), a(\"interactOutside\", B), !B.defaultPrevented) {\n        d.onContentFocusOutside();\n        const M = B.target;\n        (A = (O = u.rootNavigationMenu) == null ? void 0 : O.value) != null && A.contains(M) && B.preventDefault();\n      }\n    }\n    function w(B) {\n      var O;\n      if (a(\"pointerDownOutside\", B), !B.defaultPrevented) {\n        const A = B.target, M = r.value.some(\n          (V) => V.contains(A)\n        ), R = u.isRootMenu && ((O = u.viewport.value) == null ? void 0 : O.contains(A));\n        (M || R || !u.isRootMenu) && B.preventDefault();\n      }\n    }\n    ee((B) => {\n      const O = i.value;\n      if (u.isRootMenu && O) {\n        const A = () => {\n          var M;\n          d.onRootContentClose(), O.contains(document.activeElement) && ((M = d.triggerRef.value) == null || M.focus());\n        };\n        O.addEventListener(Et, A), B(\n          () => O.removeEventListener(Et, A)\n        );\n      }\n    });\n    function E(B) {\n      var O, A;\n      a(\"escapeKeyDown\", B), B.defaultPrevented || (u.onItemDismiss(), (A = (O = d.triggerRef) == null ? void 0 : O.value) == null || A.focus(), d.wasEscapeCloseRef.value = !0);\n    }\n    function _(B) {\n      var V;\n      const O = B.altKey || B.ctrlKey || B.metaKey, A = B.key === \"Tab\" && !O, M = ro(B.currentTarget);\n      if (A) {\n        const j = document.activeElement, I = M.findIndex(\n          (J) => J === j\n        ), W = B.shiftKey ? M.slice(0, I).reverse() : M.slice(I + 1, M.length);\n        if (ta(W))\n          B.preventDefault();\n        else {\n          (V = d.focusProxyRef.value) == null || V.focus();\n          return;\n        }\n      }\n      const R = Je(\n        B,\n        document.activeElement,\n        void 0,\n        { itemsArray: M, loop: !1, enableIgnoredElement: !0 }\n      );\n      R == null || R.focus();\n    }\n    function x() {\n      var O;\n      const B = new Event(Et, {\n        bubbles: !0,\n        cancelable: !0\n      });\n      (O = i.value) == null || O.dispatchEvent(B);\n    }\n    return (B, O) => (h(), C(n(De), T({\n      id: n(c),\n      ref: n(l),\n      \"aria-labelledby\": n(p),\n      \"data-motion\": v.value,\n      \"data-state\": n(Vt)(n(u).modelValue.value === n(d).value),\n      \"data-orientation\": n(u).orientation\n    }, e, {\n      onKeydown: _,\n      onEscapeKeyDown: E,\n      onPointerDownOutside: w,\n      onFocusOutside: g,\n      onDismiss: x\n    }), {\n      default: m(() => [\n        y(B.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\", \"data-motion\", \"data-state\", \"data-orientation\"]));\n  }\n}), Nd = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = ce(a), { forwardRef: r } = $(), l = Dt(), i = Oe(), u = Go(), d = S(() => u.value === i.modelValue.value), p = S(() => !i.modelValue.value && i.previousValue.value ? i.previousValue.value === u.value : !1);\n    function c(f) {\n      a(\"pointerDownOutside\", f), f.preventDefault || i.onContentLeave();\n    }\n    return (f, v) => n(l) ? (h(), C(Ye, {\n      key: 0,\n      to: n(i).viewport.value,\n      disabled: !n(i).viewport.value\n    }, [\n      k(n(se), {\n        present: f.forceMount || d.value || p.value\n      }, {\n        default: m(() => [\n          k(dl, T({\n            ref: n(r),\n            \"data-state\": n(Vt)(d.value),\n            style: {\n              pointerEvents: !d.value && n(i).isRootMenu ? \"none\" : void 0\n            }\n          }, { ...f.$attrs, ...e, ...n(s) }, {\n            onPointerenter: v[0] || (v[0] = (g) => n(i).onContentEnter(n(u).value)),\n            onPointerleave: v[1] || (v[1] = (g) => n(i).onContentLeave()),\n            onPointerdown: c,\n            onFocusOutside: v[2] || (v[2] = (g) => a(\"focusOutside\", g)),\n            onInteractOutside: v[3] || (v[3] = (g) => a(\"interactOutside\", g))\n          }), {\n            default: m(() => [\n              y(f.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"data-state\", \"style\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\", \"disabled\"])) : X(\"\", !0);\n  }\n}), Hd = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $(), { injectCollection: a } = ve(\"nav\"), s = a(), r = Oe(), l = P(), i = S(() => r.orientation === \"horizontal\"), u = S(() => !!r.modelValue.value), d = P();\n    function p() {\n      d.value && (l.value = {\n        size: i.value ? d.value.offsetWidth : d.value.offsetHeight,\n        offset: i.value ? d.value.offsetLeft : d.value.offsetTop\n      });\n    }\n    return ee(() => {\n      if (!r.modelValue.value) {\n        l.value = void 0;\n        return;\n      }\n      const c = s.value;\n      d.value = c.find(\n        (f) => f.id.includes(r.modelValue.value)\n      ), p();\n    }), be(d, p), be(r.indicatorTrack, p), (c, f) => n(r).indicatorTrack.value ? (h(), C(Ye, {\n      key: 0,\n      to: n(r).indicatorTrack.value\n    }, [\n      k(n(se), {\n        present: c.forceMount || u.value\n      }, {\n        default: m(() => {\n          var v, g, w, E;\n          return [\n            k(n(D), T({\n              ref: n(e),\n              \"aria-hidden\": \"\",\n              \"data-state\": u.value ? \"visible\" : \"hidden\",\n              \"data-orientation\": n(r).orientation,\n              \"as-child\": t.asChild,\n              as: c.as,\n              style: {\n                position: \"absolute\",\n                ...i.value ? {\n                  left: 0,\n                  width: `${(v = l.value) == null ? void 0 : v.size}px`,\n                  transform: `translateX(${(g = l.value) == null ? void 0 : g.offset}px)`\n                } : {\n                  top: 0,\n                  height: `${(w = l.value) == null ? void 0 : w.size}px`,\n                  transform: `translateY(${(E = l.value) == null ? void 0 : E.offset}px)`\n                }\n              }\n            }, c.$attrs), {\n              default: m(() => [\n                y(c.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"data-state\", \"data-orientation\", \"as-child\", \"as\", \"style\"])\n          ];\n        }),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\"])) : X(\"\", !0);\n  }\n}), jd = /* @__PURE__ */ b({\n  __name: \"NavigationMenuLink\",\n  props: {\n    active: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  emits: [\"select\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t;\n    $();\n    async function s(r) {\n      var l;\n      if (a(\"select\", r), await G(), !r.defaultPrevented && !r.metaKey) {\n        const i = new CustomEvent(\n          Et,\n          {\n            bubbles: !0,\n            cancelable: !0\n          }\n        );\n        (l = r.target) == null || l.dispatchEvent(i);\n      }\n    }\n    return (r, l) => (h(), C(n(D), {\n      as: r.as,\n      \"data-active\": r.active ? \"\" : void 0,\n      \"aria-current\": r.active ? \"page\" : void 0,\n      \"as-child\": e.asChild,\n      \"data-radix-vue-collection-item\": \"\",\n      onClick: s\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"data-active\", \"aria-current\", \"as-child\"]));\n  }\n}), Wd = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuList\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"ul\" }\n  },\n  setup(o) {\n    const t = o, e = Oe(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.onIndicatorTrackChange(s.value);\n    }), (r, l) => (h(), C(n(D), {\n      ref: n(a),\n      style: { position: \"relative\" }\n    }, {\n      default: m(() => [\n        k(n(D), T(r.$attrs, {\n          \"as-child\": t.asChild,\n          as: r.as,\n          \"data-orientation\": n(e).orientation\n        }), {\n          default: m(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 512));\n  }\n}), zd = /* @__PURE__ */ b({\n  __name: \"NavigationMenuSub\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, s = Y(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), r = P(\"\"), l = Oe(), { forwardRef: i, currentElement: u } = $(), d = P(), p = P(), { createCollection: c } = ve(\"nav\");\n    return c(d), Qn({\n      ...l,\n      isRootMenu: !1,\n      modelValue: s,\n      previousValue: r,\n      orientation: e.orientation,\n      rootNavigationMenu: u,\n      indicatorTrack: d,\n      onIndicatorTrackChange: (f) => {\n        d.value = f;\n      },\n      viewport: p,\n      onViewportChange: (f) => {\n        p.value = f;\n      },\n      onTriggerEnter: (f) => {\n        s.value = f;\n      },\n      onTriggerLeave: () => {\n      },\n      onContentEnter: () => {\n      },\n      onContentLeave: () => {\n      },\n      onItemSelect: (f) => {\n        s.value = f;\n      },\n      onItemDismiss: () => {\n        s.value = \"\";\n      }\n    }), (f, v) => (h(), C(n(D), {\n      ref: n(i),\n      \"data-orientation\": f.orientation,\n      \"as-child\": e.asChild,\n      as: f.as\n    }, {\n      default: m(() => [\n        y(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), cl = [\"aria-owns\"], Ud = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Oe(), a = Go(), { forwardRef: s, currentElement: r } = $(), l = P(\"\"), i = P(\"\"), u = Tt(!1, 300), d = P(!1), p = S(() => a.value === e.modelValue.value);\n    q(() => {\n      a.triggerRef = r, l.value = ea(e.baseId, a.value), i.value = qo(e.baseId, a.value);\n    });\n    function c() {\n      d.value = !1, a.wasEscapeCloseRef.value = !1;\n    }\n    function f(x) {\n      if (x.pointerType === \"mouse\") {\n        if (t.disabled || d.value || a.wasEscapeCloseRef.value || u.value)\n          return;\n        e.onTriggerEnter(a.value), u.value = !0;\n      }\n    }\n    function v(x) {\n      if (x.pointerType === \"mouse\") {\n        if (t.disabled)\n          return;\n        e.onTriggerLeave(), u.value = !1;\n      }\n    }\n    function g() {\n      u.value || (p.value ? e.onItemSelect(\"\") : e.onItemSelect(a.value), d.value = p.value);\n    }\n    function w(x) {\n      const O = { horizontal: \"ArrowDown\", vertical: e.dir.value === \"rtl\" ? \"ArrowLeft\" : \"ArrowRight\" }[e.orientation];\n      p.value && x.key === O && (a.onEntryKeyDown(), x.preventDefault(), x.stopPropagation());\n    }\n    function E(x) {\n      a.focusProxyRef.value = pe(x);\n    }\n    function _(x) {\n      const B = document.getElementById(a.contentId), O = x.relatedTarget, A = O === r.value, M = B == null ? void 0 : B.contains(O);\n      (A || !M) && a.onFocusProxyEnter(A ? \"start\" : \"end\");\n    }\n    return (x, B) => (h(), Q(le, null, [\n      k(n(D), T({\n        id: l.value,\n        ref: n(s),\n        disabled: x.disabled,\n        \"data-disabled\": x.disabled ? \"\" : void 0,\n        \"data-state\": n(Vt)(p.value),\n        \"aria-expanded\": p.value,\n        \"aria-controls\": i.value,\n        \"as-child\": t.asChild,\n        as: x.as\n      }, x.$attrs, {\n        \"data-radix-vue-collection-item\": \"\",\n        onPointerenter: c,\n        onPointermove: f,\n        onPointerleave: v,\n        onClick: g,\n        onKeydown: w\n      }), {\n        default: m(() => [\n          y(x.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"disabled\", \"data-disabled\", \"data-state\", \"aria-expanded\", \"aria-controls\", \"as-child\", \"as\"]),\n      p.value ? (h(), Q(le, { key: 0 }, [\n        k(n(Qe), {\n          ref: E,\n          \"aria-hidden\": \"\",\n          tabindex: 0,\n          onFocus: _\n        }),\n        n(e).viewport ? (h(), Q(\"span\", {\n          key: 0,\n          \"aria-owns\": i.value\n        }, null, 8, cl)) : X(\"\", !0)\n      ], 64)) : X(\"\", !0)\n    ], 64));\n  }\n}), qd = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuViewport\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const { forwardRef: t, currentElement: e } = $(), a = Oe(), s = P(), r = S(() => !!a.modelValue.value), l = S(() => a.modelValue.value);\n    U(e, () => {\n      e.value && a.onViewportChange(e.value);\n    });\n    const i = P();\n    return U([l, r], async () => {\n      var d, p;\n      if (await G(), !e.value)\n        return;\n      const u = (p = (d = e.value.querySelector(\"[data-state=open]\")) == null ? void 0 : d.children) == null ? void 0 : p[0];\n      i.value = u;\n    }, { immediate: !0 }), be(i, () => {\n      i.value && (s.value = {\n        width: i.value.offsetWidth,\n        height: i.value.offsetHeight\n      });\n    }), (u, d) => (h(), C(n(se), {\n      present: u.forceMount || r.value\n    }, {\n      default: m(() => {\n        var p, c;\n        return [\n          k(n(D), T(u.$attrs, {\n            ref: n(t),\n            as: u.as,\n            \"as-child\": u.asChild,\n            \"data-state\": n(Vt)(r.value),\n            \"data-orientation\": n(a).orientation,\n            style: {\n              // Prevent interaction when animating out\n              pointerEvents: !r.value && n(a).isRootMenu ? \"none\" : void 0,\n              \"--radix-navigation-menu-viewport-width\": s.value ? `${(p = s.value) == null ? void 0 : p.width}px` : void 0,\n              \"--radix-navigation-menu-viewport-height\": s.value ? `${(c = s.value) == null ? void 0 : c.height}px` : void 0\n            },\n            onPointerenter: d[0] || (d[0] = (f) => n(a).onContentEnter(n(a).modelValue.value)),\n            onPointerleave: d[1] || (d[1] = (f) => n(a).onContentLeave())\n          }), {\n            default: m(() => [\n              y(u.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\", \"data-state\", \"data-orientation\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [ot, pl] = H(\"PaginationRoot\"), Gd = /* @__PURE__ */ b({\n  __name: \"PaginationRoot\",\n  props: {\n    page: {},\n    defaultPage: { default: 1 },\n    itemsPerPage: { default: 10 },\n    total: { default: 0 },\n    siblingCount: { default: 2 },\n    disabled: { type: Boolean },\n    showEdges: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:page\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { siblingCount: s, disabled: r, showEdges: l } = z(e);\n    $();\n    const i = Y(e, \"page\", a, {\n      defaultValue: e.defaultPage,\n      passive: e.page === void 0\n    }), u = S(() => Math.ceil(e.total / e.itemsPerPage));\n    return pl({\n      page: i,\n      onPageChange(d) {\n        i.value = d;\n      },\n      pageCount: u,\n      siblingCount: s,\n      disabled: r,\n      showEdges: l\n    }), (d, p) => (h(), C(n(D), {\n      as: d.as,\n      \"as-child\": d.asChild\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\", {\n          page: n(i),\n          pageCount: u.value\n        })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), Yd = /* @__PURE__ */ b({\n  __name: \"PaginationEllipsis\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(D), T(t, { \"data-type\": \"ellipsis\" }), {\n      default: m(() => [\n        y(e.$slots, \"default\", {}, () => [\n          ue(\"\")\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xd = /* @__PURE__ */ b({\n  __name: \"PaginationFirst\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = ot();\n    return $(), (a, s) => (h(), C(n(D), T(t, {\n      \"aria-label\": \"First Page\",\n      type: a.as === \"button\" ? \"button\" : void 0,\n      disabled: n(e).page.value === 1 || n(e).disabled.value,\n      onClick: s[0] || (s[0] = (r) => n(e).onPageChange(1))\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\", {}, () => [\n          ue(\"First page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), Jd = /* @__PURE__ */ b({\n  __name: \"PaginationLast\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = ot();\n    return $(), (a, s) => (h(), C(n(D), T(t, {\n      \"aria-label\": \"Last Page\",\n      type: a.as === \"button\" ? \"button\" : void 0,\n      disabled: n(e).page.value === n(e).pageCount.value || n(e).disabled.value,\n      onClick: s[0] || (s[0] = (r) => n(e).onPageChange(n(e).pageCount.value))\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\", {}, () => [\n          ue(\"Last page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n});\nfunction Ee(o, t) {\n  const e = t - o + 1;\n  return Array.from({ length: e }, (a, s) => s + o);\n}\nfunction fl(o) {\n  return o.map((t) => typeof t == \"number\" ? { type: \"page\", value: t } : { type: \"ellipsis\" });\n}\nconst wt = \"ellipsis\";\nfunction vl(o, t, e, a) {\n  const r = t, l = Math.max(o - e, 1), i = Math.min(o + e, r), u = l > 1 + 2, d = i < r - 2;\n  if (a) {\n    const c = Math.min(2 * e + 5, t) - 2;\n    if (!u && d)\n      return [...Ee(1, c), wt, r];\n    if (u && !d) {\n      const v = Ee(r - c + 1, r);\n      return [1, wt, ...v];\n    }\n    if (u && d) {\n      const v = Ee(l, i);\n      return [1, wt, ...v, wt, r];\n    }\n    return Ee(1, r);\n  } else {\n    const p = e * 2 + 1;\n    return t < p ? Ee(1, r) : o <= e + 1 ? Ee(1, p) : t - o <= e ? Ee(t - p + 1, r) : Ee(l, i);\n  }\n}\nconst Zd = /* @__PURE__ */ b({\n  __name: \"PaginationList\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = ot(), a = S(() => fl(\n      vl(\n        e.page.value,\n        e.pageCount.value,\n        e.siblingCount.value,\n        e.showEdges.value\n      )\n    ));\n    return (s, r) => (h(), C(n(D), L(N(t)), {\n      default: m(() => [\n        y(s.$slots, \"default\", { items: a.value })\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qd = /* @__PURE__ */ b({\n  __name: \"PaginationListItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = ot(), a = S(() => e.page.value === t.value);\n    return (s, r) => (h(), C(n(D), T(t, {\n      \"data-type\": \"page\",\n      \"aria-label\": `Page ${s.value}`,\n      \"aria-current\": a.value ? \"page\" : void 0,\n      \"data-selected\": a.value ? \"true\" : void 0,\n      disabled: n(e).disabled.value,\n      type: s.as === \"button\" ? \"button\" : void 0,\n      onClick: r[0] || (r[0] = (l) => n(e).onPageChange(s.value))\n    }), {\n      default: m(() => [\n        y(s.$slots, \"default\", {}, () => [\n          ue(Le(s.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-current\", \"data-selected\", \"disabled\", \"type\"]));\n  }\n}), ec = /* @__PURE__ */ b({\n  __name: \"PaginationNext\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = ot();\n    return (a, s) => (h(), C(n(D), T(t, {\n      \"aria-label\": \"Next Page\",\n      type: a.as === \"button\" ? \"button\" : void 0,\n      disabled: n(e).page.value === n(e).pageCount.value || n(e).disabled.value,\n      onClick: s[0] || (s[0] = (r) => n(e).onPageChange(n(e).page.value + 1))\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\", {}, () => [\n          ue(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), tc = /* @__PURE__ */ b({\n  __name: \"PaginationPrev\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = ot();\n    return (a, s) => {\n      var r;\n      return h(), C(n(D), T(t, {\n        \"aria-label\": \"Previous Page\",\n        type: a.as === \"button\" ? \"button\" : void 0,\n        disabled: n(e).page.value === 1 || ((r = n(e).disabled) == null ? void 0 : r.value),\n        onClick: s[0] || (s[0] = (l) => n(e).onPageChange(n(e).page.value - 1))\n      }), {\n        default: m(() => [\n          y(a.$slots, \"default\", {}, () => [\n            ue(\"Prev page\")\n          ])\n        ]),\n        _: 3\n      }, 16, [\"type\", \"disabled\"]);\n    };\n  }\n}), ml = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [hl, gl] = H(\"PinInputRoot\"), oc = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"PinInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    placeholder: { default: \"\" },\n    mask: { type: Boolean },\n    otp: { type: Boolean },\n    type: { default: \"text\" },\n    dir: {},\n    name: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    id: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"complete\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { mask: s, otp: r, placeholder: l, type: i, disabled: u, dir: d } = z(e), { forwardRef: p } = $(), c = de(d), f = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue ?? [],\n      passive: e.modelValue === void 0\n    }), v = P(/* @__PURE__ */ new Set());\n    function g(E) {\n      v.value.add(E);\n    }\n    const w = S(() => f.value.filter((_) => !!_).length === v.value.size);\n    return U(f, () => {\n      w.value && a(\"complete\", f.value);\n    }, { deep: !0 }), gl({\n      modelValue: f,\n      mask: s,\n      otp: r,\n      placeholder: l,\n      type: i,\n      dir: c,\n      disabled: u,\n      isCompleted: w,\n      inputElements: v,\n      onInputElementChange: g\n    }), (E, _) => (h(), Q(le, null, [\n      k(n(D), T(E.$attrs, {\n        ref: n(p),\n        dir: n(c),\n        \"data-complete\": w.value ? \"\" : void 0,\n        \"data-disabled\": n(u) ? \"\" : void 0\n      }), {\n        default: m(() => [\n          y(E.$slots, \"default\", { modelValue: n(f) })\n        ]),\n        _: 3\n      }, 16, [\"dir\", \"data-complete\", \"data-disabled\"]),\n      ut(\"input\", {\n        id: E.id,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: n(f).join(\"\"),\n        name: E.name,\n        disabled: n(u),\n        required: E.required,\n        style: re({\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }),\n        onFocus: _[0] || (_[0] = (x) => {\n          var B, O;\n          return (O = (B = Array.from(v.value)) == null ? void 0 : B[0]) == null ? void 0 : O.focus();\n        })\n      }, null, 44, ml)\n    ], 64));\n  }\n}), yl = [\"autocomplete\", \"type\", \"inputmode\", \"pattern\", \"placeholder\", \"value\", \"disabled\", \"data-disabled\", \"data-complete\", \"aria-label\"], nc = /* @__PURE__ */ b({\n  __name: \"PinInputInput\",\n  props: {\n    index: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(o) {\n    const t = o, e = hl(), a = S(() => Array.from(e.inputElements.value)), s = S(() => t.disabled || e.disabled.value), r = S(() => e.otp.value), l = S(() => e.type.value === \"number\"), i = S(() => e.mask.value), u = P();\n    function d(_) {\n      const x = _.target;\n      if (l.value && !/^[0-9]*$/.test(x.value)) {\n        x.value = x.value.replace(/\\D/g, \"\");\n        return;\n      }\n      x.value = x.value.slice(-1), E(t.index, x.value);\n      const B = a.value[t.index + 1];\n      B && B.focus();\n    }\n    function p(_) {\n      Je(_, document.activeElement, void 0, {\n        itemsArray: a.value,\n        focus: !0,\n        loop: !1,\n        arrowKeyOptions: \"horizontal\",\n        dir: e.dir.value\n      });\n    }\n    function c(_) {\n      if (_.preventDefault(), _.target.value)\n        E(t.index, \"\");\n      else {\n        const O = a.value[t.index - 1];\n        O && (O.focus(), E(t.index - 1, \"\"));\n      }\n    }\n    function f(_) {\n      _.key === \"Delete\" && (_.preventDefault(), E(t.index, \"\"));\n    }\n    function v(_) {\n      const x = _.target;\n      x.setSelectionRange(1, 1), x.value || (x.placeholder = \"\");\n    }\n    function g(_) {\n      const x = _.target;\n      G(() => {\n        x.value || (x.placeholder = e.placeholder.value);\n      });\n    }\n    function w(_) {\n      var R;\n      _.preventDefault();\n      const x = _.clipboardData;\n      if (!x)\n        return;\n      const B = [...e.modelValue.value], O = x.getData(\"text\"), A = O.length >= a.value.length ? 0 : t.index, M = Math.min(A + O.length, a.value.length);\n      for (let V = A; V < M; V++) {\n        const j = a.value[V], I = O[V - A];\n        l.value && !/^[0-9]*$/.test(I) || (B[V] = I, j.focus());\n      }\n      e.modelValue.value = B, (R = a.value[M]) == null || R.focus();\n    }\n    function E(_, x) {\n      const B = [...e.modelValue.value];\n      B[_] = x, e.modelValue.value = B;\n    }\n    return q(() => {\n      e.onInputElementChange(u.value);\n    }), fe(() => {\n      var _;\n      (_ = e.inputElements) == null || _.value.delete(u.value);\n    }), (_, x) => (h(), Q(\"input\", {\n      ref_key: \"inputRef\",\n      ref: u,\n      autocapitalize: \"none\",\n      autocomplete: r.value ? \"one-time-code\" : \"false\",\n      type: i.value ? \"password\" : \"text\",\n      inputmode: l.value ? \"numeric\" : \"text\",\n      pattern: l.value ? \"[0-9]*\" : void 0,\n      placeholder: n(e).placeholder.value,\n      value: n(e).modelValue.value.at(_.index),\n      disabled: s.value,\n      \"data-disabled\": s.value ? \"\" : void 0,\n      \"data-complete\": n(e).isCompleted.value ? \"\" : void 0,\n      \"aria-label\": `pin input ${_.index + 1} of ${a.value.length}`,\n      onInput: d,\n      onKeydown: [\n        ie(p, [\"left\", \"right\", \"up\", \"down\", \"home\", \"end\"]),\n        ie(c, [\"backspace\"]),\n        ie(f, [\"delete\"])\n      ],\n      onFocus: v,\n      onBlur: g,\n      onPaste: w\n    }, null, 40, yl));\n  }\n}), [Ue, bl] = H(\"PopoverRoot\"), ac = /* @__PURE__ */ b({\n  __name: \"PopoverRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { modal: s } = z(e), r = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), l = P(), i = P(!1);\n    return bl({\n      contentId: te(),\n      modal: s,\n      open: r,\n      onOpenChange: (u) => {\n        r.value = u;\n      },\n      onOpenToggle: () => {\n        r.value = !r.value;\n      },\n      triggerElement: l,\n      hasCustomAnchor: i\n    }), (u, d) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), sc = /* @__PURE__ */ b({\n  __name: \"PopoverTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Ue(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.triggerElement.value = s.value;\n    }), (r, l) => (h(), C(we(n(e).hasCustomAnchor.value ? n(D) : n(We)), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(a),\n          type: r.as === \"button\" ? \"button\" : void 0,\n          \"aria-haspopup\": \"dialog\",\n          \"aria-expanded\": n(e).open.value,\n          \"aria-controls\": n(e).contentId,\n          \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n          as: r.as,\n          \"as-child\": t.asChild,\n          onClick: n(e).onOpenToggle\n        }, {\n          default: m(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"as\", \"as-child\", \"onClick\"])\n      ]),\n      _: 3\n    }));\n  }\n}), rc = /* @__PURE__ */ b({\n  __name: \"PopoverPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), oa = /* @__PURE__ */ b({\n  __name: \"PopoverContentImpl\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = He(e), { forwardRef: r } = $(), l = Ue();\n    return yo(), (i, u) => (h(), C(n(At), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: i.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => a(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => a(\"closeAutoFocus\", d))\n    }, {\n      default: m(() => [\n        k(n(De), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          onPointerDownOutside: u[0] || (u[0] = (d) => a(\"pointerDownOutside\", d)),\n          onInteractOutside: u[1] || (u[1] = (d) => a(\"interactOutside\", d)),\n          onEscapeKeyDown: u[2] || (u[2] = (d) => a(\"escapeKeyDown\", d)),\n          onFocusOutside: u[3] || (u[3] = (d) => a(\"focusOutside\", d)),\n          onDismiss: u[4] || (u[4] = (d) => n(l).onOpenChange(!1))\n        }, {\n          default: m(() => [\n            k(n(Fe), T(n(s), {\n              id: n(l).contentId,\n              ref: n(r),\n              \"data-state\": n(l).open.value ? \"open\" : \"closed\",\n              role: \"dialog\",\n              style: {\n                \"--radix-popover-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n                \"--radix-popover-content-available-width\": \"var(--radix-popper-available-width)\",\n                \"--radix-popover-content-available-height\": \"var(--radix-popper-available-height)\",\n                \"--radix-popover-trigger-width\": \"var(--radix-popper-anchor-width)\",\n                \"--radix-popover-trigger-height\": \"var(--radix-popper-anchor-height)\"\n              }\n            }), {\n              default: m(() => [\n                y(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"style\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), Cl = /* @__PURE__ */ b({\n  __name: \"PopoverContentModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = Ue(), r = P(!1);\n    ct(!0);\n    const l = ae(e, a), { forwardRef: i, currentElement: u } = $();\n    return pt(u), (d, p) => (h(), C(oa, T(n(l), {\n      ref: n(i),\n      \"trap-focus\": n(s).open.value,\n      \"disable-outside-pointer-events\": \"\",\n      onCloseAutoFocus: p[0] || (p[0] = oe(\n        (c) => {\n          var f;\n          a(\"closeAutoFocus\", c), r.value || (f = n(s).triggerElement.value) == null || f.focus();\n        },\n        [\"prevent\"]\n      )),\n      onPointerDownOutside: p[1] || (p[1] = (c) => {\n        a(\"pointerDownOutside\", c);\n        const f = c.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, g = f.button === 2 || v;\n        r.value = g;\n      }),\n      onFocusOutside: p[2] || (p[2] = oe(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), wl = /* @__PURE__ */ b({\n  __name: \"PopoverContentNonModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = Ue(), r = P(!1), l = P(!1), i = ae(e, a);\n    return (u, d) => (h(), C(oa, T(n(i), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (p) => {\n        var c;\n        a(\"closeAutoFocus\", p), p.defaultPrevented || (r.value || (c = n(s).triggerElement.value) == null || c.focus(), p.preventDefault()), r.value = !1, l.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = async (p) => {\n        var v;\n        a(\"interactOutside\", p), p.defaultPrevented || (r.value = !0, p.detail.originalEvent.type === \"pointerdown\" && (l.value = !0));\n        const c = p.target;\n        ((v = n(s).triggerElement.value) == null ? void 0 : v.contains(c)) && p.preventDefault(), p.detail.originalEvent.type === \"focusin\" && l.value && p.preventDefault();\n      })\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lc = /* @__PURE__ */ b({\n  __name: \"PopoverContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = Ue(), r = ae(e, a), { forwardRef: l } = $();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(s).open.value\n    }, {\n      default: m(() => [\n        n(s).modal.value ? (h(), C(Cl, T({ key: 0 }, n(r), { ref: n(l) }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (h(), C(wl, T({ key: 1 }, n(r), { ref: n(l) }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), ic = /* @__PURE__ */ b({\n  __name: \"PopoverArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Ze), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), uc = /* @__PURE__ */ b({\n  __name: \"PopoverClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = Ue();\n    return (a, s) => (h(), C(n(D), {\n      type: a.as === \"button\" ? \"button\" : void 0,\n      as: a.as,\n      \"as-child\": t.asChild,\n      onClick: s[0] || (s[0] = (r) => n(e).onOpenChange(!1))\n    }, {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as\", \"as-child\"]));\n  }\n}), dc = /* @__PURE__ */ b({\n  __name: \"PopoverAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = Ue();\n    return $n(() => {\n      e.hasCustomAnchor.value = !0;\n    }), fe(() => {\n      e.hasCustomAnchor.value = !1;\n    }), (a, s) => (h(), C(n(We), L(N(t)), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lt = 100, [_l, $l] = H(\"ProgressRoot\"), Yo = (o) => typeof o == \"number\";\nfunction xl(o, t) {\n  return o === null || Yo(o) && !Number.isNaN(o) && o <= t && o >= 0 ? o : (console.error(`Invalid prop \\`value\\` of value \\`${o}\\` supplied to \\`ProgressRoot\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${lt} if no \\`max\\` prop is set)\n  - \\`null\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`), null);\n}\nfunction El(o) {\n  return Yo(o) && !Number.isNaN(o) && o > 0 ? o : (console.error(\n    `Invalid prop \\`max\\` of value \\`${o}\\` supplied to \\`ProgressRoot\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${lt}\\`.`\n  ), lt);\n}\nconst cc = /* @__PURE__ */ b({\n  __name: \"ProgressRoot\",\n  props: {\n    modelValue: {},\n    max: { default: lt },\n    getValueLabel: { type: Function, default: (o, t) => `${Math.round(o / t * lt)}%` },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:max\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t;\n    $();\n    const s = Y(e, \"modelValue\", a, {\n      passive: e.modelValue === void 0\n    }), r = Y(e, \"max\", a, {\n      passive: e.max === void 0\n    });\n    U(\n      () => s.value,\n      async (i) => {\n        const u = xl(i, e.max);\n        u !== i && (await G(), s.value = u);\n      },\n      { immediate: !0 }\n    ), U(\n      () => e.max,\n      (i) => {\n        const u = El(e.max);\n        u !== i && (r.value = u);\n      },\n      { immediate: !0 }\n    );\n    const l = S(() => s.value ? s.value === r.value ? \"complete\" : \"loading\" : \"indeterminate\");\n    return $l({\n      modelValue: s,\n      max: r,\n      progressState: l\n    }), (i, u) => (h(), C(n(D), {\n      \"as-child\": i.asChild,\n      as: i.as,\n      \"aria-valuemax\": n(r),\n      \"aria-valuemin\": 0,\n      \"aria-valuenow\": Yo(n(s)) ? n(s) : void 0,\n      \"aria-valuetext\": i.getValueLabel(n(s), n(r)),\n      \"aria-label\": i.getValueLabel(n(s), n(r)),\n      role: \"progressbar\",\n      \"data-state\": l.value,\n      \"data-value\": n(s) ?? void 0,\n      \"data-max\": n(r)\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"aria-valuemax\", \"aria-valuenow\", \"aria-valuetext\", \"aria-label\", \"data-state\", \"data-value\", \"data-max\"]));\n  }\n}), pc = /* @__PURE__ */ b({\n  __name: \"ProgressIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = _l();\n    return $(), (a, s) => {\n      var r;\n      return h(), C(n(D), T(t, {\n        \"data-state\": n(e).progressState.value,\n        \"data-value\": ((r = n(e).modelValue) == null ? void 0 : r.value) ?? void 0,\n        \"data-max\": n(e).max.value\n      }), {\n        default: m(() => [\n          y(a.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"data-state\", \"data-value\", \"data-max\"]);\n    };\n  }\n}), [Pl, Bl] = H(\"RadioGroupRoot\"), fc = /* @__PURE__ */ b({\n  __name: \"RadioGroupRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    disabled: { type: Boolean, default: !1 },\n    name: {},\n    required: { type: Boolean, default: !1 },\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { forwardRef: s } = $(), r = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), { disabled: l, loop: i, orientation: u, name: d, required: p, dir: c } = z(e), f = de(c);\n    return Bl({\n      modelValue: r,\n      changeModelValue: (v) => {\n        r.value = v;\n      },\n      disabled: l,\n      loop: i,\n      orientation: u,\n      name: d == null ? void 0 : d.value,\n      required: p\n    }), (v, g) => (h(), C(n(et), {\n      \"as-child\": \"\",\n      orientation: n(u),\n      dir: n(f),\n      loop: n(i)\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(s),\n          role: \"radiogroup\",\n          \"data-disabled\": n(l) ? \"\" : void 0,\n          \"as-child\": v.asChild,\n          as: v.as,\n          required: n(p),\n          \"aria-orientation\": n(u),\n          \"aria-required\": n(p),\n          dir: n(f),\n          name: n(d)\n        }, {\n          default: m(() => [\n            y(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"data-disabled\", \"as-child\", \"as\", \"required\", \"aria-orientation\", \"aria-required\", \"dir\", \"name\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Sl = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], Tl = /* @__PURE__ */ b({\n  __name: \"Radio\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, s = Y(e, \"checked\", t, {\n      passive: e.checked === void 0\n    }), { value: r } = z(e), { forwardRef: l, currentElement: i } = $(), u = Ne(i), d = S(() => {\n      var c;\n      return e.id && i.value ? ((c = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : c.innerText) ?? e.value : void 0;\n    });\n    function p(c) {\n      s.value = !0, u.value && c.stopPropagation();\n    }\n    return (c, f) => (h(), C(n(D), T(c.$attrs, {\n      id: c.id,\n      ref: n(l),\n      role: \"radio\",\n      type: c.as === \"button\" ? \"button\" : void 0,\n      as: c.as,\n      \"aria-checked\": n(s),\n      \"aria-label\": d.value,\n      \"as-child\": c.asChild,\n      disabled: c.disabled ? !0 : void 0,\n      \"data-state\": n(s) ? \"checked\" : \"unchecked\",\n      \"data-disabled\": c.disabled ? \"\" : void 0,\n      value: n(r),\n      required: c.required,\n      name: c.name,\n      onClick: oe(p, [\"stop\"])\n    }), {\n      default: m(() => [\n        y(c.$slots, \"default\"),\n        n(u) ? (h(), Q(\"input\", {\n          key: 0,\n          type: \"radio\",\n          tabindex: \"-1\",\n          \"aria-hidden\": \"\",\n          value: n(r),\n          checked: !!n(s),\n          name: c.name,\n          disabled: c.disabled,\n          required: c.required,\n          style: re({\n            transform: \"translateX(-100%)\",\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            opacity: 0,\n            margin: 0\n          })\n        }, null, 12, Sl)) : X(\"\", !0)\n      ]),\n      _: 3\n    }, 16, [\"id\", \"type\", \"as\", \"aria-checked\", \"aria-label\", \"as-child\", \"disabled\", \"data-state\", \"data-disabled\", \"value\", \"required\", \"name\"]));\n  }\n}), [Dl, Ol] = H(\"RadioGroupItem\"), vc = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"RadioGroupItem\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, { forwardRef: e, currentElement: a } = $(), s = Pl(), r = S(() => s.disabled.value || t.disabled), l = S(() => s.required.value || t.required), i = S(() => {\n      var c;\n      return ((c = s.modelValue) == null ? void 0 : c.value) === t.value;\n    });\n    Ol({ disabled: r, checked: i });\n    const u = P(!1), d = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\n    Be(\"keydown\", (c) => {\n      d.includes(c.key) && (u.value = !0);\n    }), Be(\"keyup\", () => {\n      u.value = !1;\n    });\n    function p() {\n      setTimeout(() => {\n        var c;\n        u.value && ((c = a.value) == null || c.click());\n      }, 0);\n    }\n    return (c, f) => (h(), C(n(tt), {\n      checked: i.value,\n      disabled: r.value,\n      \"as-child\": \"\",\n      focusable: !r.value,\n      active: i.value\n    }, {\n      default: m(() => [\n        k(Tl, T({ ...c.$attrs, ...t }, {\n          ref: n(e),\n          checked: i.value,\n          required: l.value,\n          \"onUpdate:checked\": f[0] || (f[0] = (v) => n(s).changeModelValue(c.value)),\n          onKeydown: f[1] || (f[1] = ie(oe(() => {\n          }, [\"prevent\"]), [\"enter\"])),\n          onFocus: p\n        }), {\n          default: m(() => [\n            y(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"checked\", \"required\"])\n      ]),\n      _: 3\n    }, 8, [\"checked\", \"disabled\", \"focusable\", \"active\"]));\n  }\n}), mc = /* @__PURE__ */ b({\n  __name: \"RadioGroupIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const { forwardRef: t } = $(), e = Dl();\n    return (a, s) => (h(), C(n(se), {\n      present: a.forceMount || n(e).checked.value\n    }, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(t),\n          \"data-state\": n(e).checked.value ? \"checked\" : \"unchecked\",\n          \"data-disabled\": n(e).disabled.value ? \"\" : void 0,\n          \"as-child\": a.asChild,\n          as: a.as\n        }, a.$attrs), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [me, Il] = H(\"ScrollAreaRoot\"), hc = /* @__PURE__ */ b({\n  __name: \"ScrollAreaRoot\",\n  props: {\n    type: { default: \"hover\" },\n    dir: {},\n    scrollHideDelay: { default: 600 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { forwardRef: e, currentElement: a } = $(), s = P(0), r = P(0), l = P(), i = P(), u = P(), d = P(), p = P(!1), c = P(!1), { type: f, dir: v, scrollHideDelay: g } = z(t), w = de(v);\n    return Il({\n      type: f,\n      dir: w,\n      scrollHideDelay: g,\n      scrollArea: a,\n      viewport: l,\n      onViewportChange: (E) => {\n        l.value = E || void 0;\n      },\n      content: i,\n      onContentChange: (E) => {\n        i.value = E;\n      },\n      scrollbarX: u,\n      scrollbarXEnabled: p,\n      scrollbarY: d,\n      scrollbarYEnabled: c,\n      onScrollbarXChange: (E) => {\n        u.value = E || void 0;\n      },\n      onScrollbarYChange: (E) => {\n        d.value = E || void 0;\n      },\n      onScrollbarXEnabledChange: (E) => {\n        p.value = E;\n      },\n      onScrollbarYEnabledChange: (E) => {\n        c.value = E;\n      },\n      onCornerWidthChange: (E) => {\n        s.value = E;\n      },\n      onCornerHeightChange: (E) => {\n        r.value = E;\n      }\n    }), (E, _) => (h(), C(n(D), {\n      ref: n(e),\n      \"as-child\": t.asChild,\n      as: E.as,\n      dir: n(w),\n      style: re({\n        position: \"relative\",\n        // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n        \"--radix-scroll-area-corner-width\": `${s.value}px`,\n        \"--radix-scroll-area-corner-height\": `${r.value}px`\n      })\n    }, {\n      default: m(() => [\n        y(E.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"dir\", \"style\"]));\n  }\n}), gc = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaViewport\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o, { expose: t }) {\n    const e = o, a = me(), s = P();\n    q(() => {\n      a.onViewportChange(s.value), a.onContentChange(l.value);\n    }), t({\n      viewportElement: s\n    });\n    const { forwardRef: r, currentElement: l } = $();\n    return (i, u) => (h(), Q(le, null, [\n      ut(\"div\", T({\n        ref_key: \"viewportElement\",\n        ref: s,\n        \"data-radix-scroll-area-viewport\": \"\",\n        style: {\n          /**\n           * We don't support `visible` because the intention is to have at least one scrollbar\n           * if this component is used and `visible` will behave like `auto` in that case\n           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description\n           *\n           * We don't handle `auto` because the intention is for the native implementation\n           * to be hidden if using this component. We just want to ensure the node is scrollable\n           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n           * the browser from having to work out whether to render native scrollbars or not,\n           * we tell it to with the intention of hiding them in CSS.\n           */\n          overflowX: n(a).scrollbarXEnabled.value ? \"scroll\" : \"hidden\",\n          overflowY: n(a).scrollbarYEnabled.value ? \"scroll\" : \"hidden\"\n        }\n      }, i.$attrs, { tabindex: 0 }), [\n        k(n(D), {\n          ref: n(r),\n          style: { minWidth: \"100%\", display: \"table\" },\n          \"as-child\": e.asChild,\n          as: i.as\n        }, {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ], 16),\n      k(n(D), { as: \"style\" }, {\n        default: m(() => [\n          ue(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } \")\n        ]),\n        _: 1\n      })\n    ], 64));\n  }\n});\nfunction Al(o, [t, e]) {\n  return Math.min(e, Math.max(t, o));\n}\nfunction na(o, t) {\n  return (e) => {\n    if (o[0] === o[1] || t[0] === t[1])\n      return t[0];\n    const a = (t[1] - t[0]) / (o[1] - o[0]);\n    return t[0] + a * (e - o[0]);\n  };\n}\nfunction Ft(o) {\n  const t = aa(o.viewport, o.content), e = o.scrollbar.paddingStart + o.scrollbar.paddingEnd, a = (o.scrollbar.size - e) * t;\n  return Math.max(a, 18);\n}\nfunction aa(o, t) {\n  const e = o / t;\n  return Number.isNaN(e) ? 0 : e;\n}\nfunction Rl(o, t = () => {\n}) {\n  let e = { left: o.scrollLeft, top: o.scrollTop }, a = 0;\n  return function s() {\n    const r = { left: o.scrollLeft, top: o.scrollTop }, l = e.left !== r.left, i = e.top !== r.top;\n    (l || i) && t(), e = r, a = window.requestAnimationFrame(s);\n  }(), () => window.cancelAnimationFrame(a);\n}\nfunction dn(o, t, e = \"ltr\") {\n  const a = Ft(t), s = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, r = t.scrollbar.size - s, l = t.content - t.viewport, i = r - a, u = e === \"ltr\" ? [0, l] : [l * -1, 0], d = Al(\n    o,\n    u\n  );\n  return na([0, l], [0, i])(d);\n}\nfunction _t(o) {\n  return o ? Number.parseInt(o, 10) : 0;\n}\nfunction Ml(o, t, e, a = \"ltr\") {\n  const s = Ft(e), r = s / 2, l = t || r, i = s - l, u = e.scrollbar.paddingStart + l, d = e.scrollbar.size - e.scrollbar.paddingEnd - i, p = e.content - e.viewport, c = a === \"ltr\" ? [0, p] : [p * -1, 0];\n  return na(\n    [u, d],\n    c\n  )(o);\n}\nfunction cn(o, t) {\n  return o > 0 && o < t;\n}\nconst sa = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarImpl\",\n  props: {\n    isHorizontal: { type: Boolean }\n  },\n  emits: [\"onDragScroll\", \"onWheelScroll\", \"onThumbPointerDown\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = me(), r = Lt(), l = Kt(), { forwardRef: i, currentElement: u } = $(), d = P(\"\"), p = P();\n    function c(_) {\n      var x, B;\n      if (p.value) {\n        const O = _.clientX - ((x = p.value) == null ? void 0 : x.left), A = _.clientY - ((B = p.value) == null ? void 0 : B.top);\n        a(\"onDragScroll\", { x: O, y: A });\n      }\n    }\n    function f(_) {\n      _.button === 0 && (_.target.setPointerCapture(_.pointerId), p.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = \"none\", s.viewport && (s.viewport.value.style.scrollBehavior = \"auto\"), c(_));\n    }\n    function v(_) {\n      c(_);\n    }\n    function g(_) {\n      const x = _.target;\n      x.hasPointerCapture(_.pointerId) && x.releasePointerCapture(_.pointerId), document.body.style.webkitUserSelect = d.value, s.viewport && (s.viewport.value.style.scrollBehavior = \"\"), p.value = void 0;\n    }\n    function w(_) {\n      var A;\n      const x = _.target, B = (A = u.value) == null ? void 0 : A.contains(x), O = r.sizes.value.content - r.sizes.value.viewport;\n      B && r.handleWheelScroll(_, O);\n    }\n    q(() => {\n      document.addEventListener(\"wheel\", w, { passive: !1 });\n    }), fe(() => {\n      document.removeEventListener(\"wheel\", w);\n    });\n    function E() {\n      var _, x, B, O, A;\n      u.value && (e.isHorizontal ? r.handleSizeChange({\n        content: ((_ = s.viewport.value) == null ? void 0 : _.scrollWidth) ?? 0,\n        viewport: ((x = s.viewport.value) == null ? void 0 : x.offsetWidth) ?? 0,\n        scrollbar: {\n          size: u.value.clientWidth ?? 0,\n          paddingStart: _t(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: _t(getComputedStyle(u.value).paddingRight)\n        }\n      }) : r.handleSizeChange({\n        content: ((B = s.viewport.value) == null ? void 0 : B.scrollHeight) ?? 0,\n        viewport: ((O = s.viewport.value) == null ? void 0 : O.offsetHeight) ?? 0,\n        scrollbar: {\n          size: ((A = u.value) == null ? void 0 : A.clientHeight) ?? 0,\n          paddingStart: _t(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: _t(getComputedStyle(u.value).paddingRight)\n        }\n      }));\n    }\n    return be(u, E), be(s.content, E), (_, x) => (h(), C(n(D), {\n      ref: n(i),\n      style: { position: \"absolute\" },\n      \"data-scrollbarimpl\": \"\",\n      as: n(l).as.value,\n      \"as-child\": n(l).asChild.value,\n      onPointerdown: f,\n      onPointermove: v,\n      onPointerup: g\n    }, {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), kl = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarX\",\n  setup(o) {\n    const t = me(), e = Lt(), { forwardRef: a, currentElement: s } = $();\n    q(() => {\n      s.value && t.onScrollbarXChange(s.value);\n    });\n    const r = S(() => e.sizes.value);\n    return (l, i) => (h(), C(sa, {\n      ref: n(a),\n      \"is-horizontal\": !0,\n      \"data-orientation\": \"horizontal\",\n      style: re({\n        bottom: 0,\n        left: n(t).dir.value === \"rtl\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        right: n(t).dir.value === \"ltr\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        \"--radix-scroll-area-thumb-width\": r.value ? `${n(Ft)(r.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => n(e).onDragScroll(u.x))\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), Vl = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarY\",\n  setup(o) {\n    const t = me(), e = Lt(), { forwardRef: a, currentElement: s } = $();\n    q(() => {\n      s.value && t.onScrollbarYChange(s.value);\n    });\n    const r = S(() => e.sizes.value);\n    return (l, i) => (h(), C(sa, {\n      ref: n(a),\n      \"is-horizontal\": !1,\n      \"data-orientation\": \"vertical\",\n      style: re({\n        top: 0,\n        right: n(t).dir.value === \"ltr\" ? 0 : void 0,\n        left: n(t).dir.value === \"rtl\" ? 0 : void 0,\n        bottom: \"var(--radix-scroll-area-corner-height)\",\n        \"--radix-scroll-area-thumb-height\": r.value ? `${n(Ft)(r.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => n(e).onDragScroll(u.y))\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), [Lt, Fl] = H(\"ScrollAreaScrollbarVisible\"), Xo = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarVisible\",\n  setup(o) {\n    const t = me(), e = Kt(), { forwardRef: a } = $(), s = P({\n      content: 0,\n      viewport: 0,\n      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }\n    }), r = S(() => {\n      const _ = aa(s.value.viewport, s.value.content);\n      return _ > 0 && _ < 1;\n    }), l = P(), i = P(0);\n    function u(_, x) {\n      if (v.value) {\n        const B = t.viewport.value.scrollLeft + _.deltaY;\n        t.viewport.value.scrollLeft = B, cn(B, x) && _.preventDefault();\n      } else {\n        const B = t.viewport.value.scrollTop + _.deltaY;\n        t.viewport.value.scrollTop = B, cn(B, x) && _.preventDefault();\n      }\n    }\n    function d(_, x) {\n      v.value ? i.value = x.x : i.value = x.y;\n    }\n    function p(_) {\n      i.value = 0;\n    }\n    function c(_) {\n      s.value = _;\n    }\n    function f(_, x) {\n      return Ml(\n        _,\n        i.value,\n        s.value,\n        x\n      );\n    }\n    const v = S(\n      () => e.isHorizontal.value\n    );\n    function g(_) {\n      v.value ? t.viewport.value.scrollLeft = f(\n        _,\n        t.dir.value\n      ) : t.viewport.value.scrollTop = f(_);\n    }\n    function w() {\n      if (v.value) {\n        if (t.viewport.value && l.value) {\n          const _ = t.viewport.value.scrollLeft, x = dn(\n            _,\n            s.value,\n            t.dir.value\n          );\n          l.value.style.transform = `translate3d(${x}px, 0, 0)`;\n        }\n      } else if (t.viewport.value && l.value) {\n        const _ = t.viewport.value.scrollTop, x = dn(_, s.value);\n        l.value.style.transform = `translate3d(0, ${x}px, 0)`;\n      }\n    }\n    function E(_) {\n      l.value = _;\n    }\n    return Fl({\n      sizes: s,\n      hasThumb: r,\n      handleWheelScroll: u,\n      handleThumbDown: d,\n      handleThumbUp: p,\n      handleSizeChange: c,\n      onThumbPositionChange: w,\n      onThumbChange: E,\n      onDragScroll: g\n    }), (_, x) => v.value ? (h(), C(kl, T({ key: 0 }, _.$attrs, { ref: n(a) }), {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : (h(), C(Vl, T({ key: 1 }, _.$attrs, { ref: n(a) }), {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ra = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarAuto\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = me(), e = Kt(), { forwardRef: a } = $(), s = P(!1), r = mo(() => {\n      if (t.viewport.value) {\n        const l = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;\n        s.value = e.isHorizontal.value ? l : i;\n      }\n    }, 10);\n    return q(() => r()), be(t.viewport, r), be(t.content, r), (l, i) => (h(), C(n(se), {\n      present: l.forceMount || s.value\n    }, {\n      default: m(() => [\n        k(Xo, T(l.$attrs, {\n          ref: n(a),\n          \"data-state\": s.value ? \"visible\" : \"hidden\"\n        }), {\n          default: m(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Ll = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbarHover\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = me(), { forwardRef: e } = $();\n    let a;\n    const s = P(!1);\n    function r() {\n      window.clearTimeout(a), s.value = !0;\n    }\n    function l() {\n      a = window.setTimeout(() => {\n        s.value = !1;\n      }, t.scrollHideDelay.value);\n    }\n    return q(() => {\n      const i = t.scrollArea.value;\n      i && (i.addEventListener(\"pointerenter\", r), i.addEventListener(\"pointerleave\", l));\n    }), fe(() => {\n      const i = t.scrollArea.value;\n      i && (window.clearTimeout(a), i.removeEventListener(\"pointerenter\", r), i.removeEventListener(\"pointerleave\", l));\n    }), (i, u) => (h(), C(n(se), {\n      present: i.forceMount || s.value\n    }, {\n      default: m(() => [\n        k(ra, T(i.$attrs, {\n          ref: n(e),\n          \"data-state\": s.value ? \"visible\" : \"hidden\"\n        }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Kl = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarScroll\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = me(), e = Kt(), { forwardRef: a } = $(), { state: s, dispatch: r } = On(\"hidden\", {\n      hidden: {\n        SCROLL: \"scrolling\"\n      },\n      scrolling: {\n        SCROLL_END: \"idle\",\n        POINTER_ENTER: \"interacting\"\n      },\n      interacting: {\n        SCROLL: \"interacting\",\n        POINTER_LEAVE: \"idle\"\n      },\n      idle: {\n        HIDE: \"hidden\",\n        SCROLL: \"scrolling\",\n        POINTER_ENTER: \"interacting\"\n      }\n    });\n    ee((i) => {\n      if (s.value === \"idle\") {\n        const u = window.setTimeout(\n          () => r(\"HIDE\"),\n          t.scrollHideDelay.value\n        );\n        i(() => {\n          window.clearTimeout(u);\n        });\n      }\n    });\n    const l = mo(() => r(\"SCROLL_END\"), 100);\n    return ee((i) => {\n      const u = t.viewport.value, d = e.isHorizontal.value ? \"scrollLeft\" : \"scrollTop\";\n      if (u) {\n        let p = u[d];\n        const c = () => {\n          const f = u[d];\n          p !== f && (r(\"SCROLL\"), l()), p = f;\n        };\n        u.addEventListener(\"scroll\", c), i(() => {\n          u.removeEventListener(\"scroll\", c);\n        });\n      }\n    }), (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(s) !== \"hidden\"\n    }, {\n      default: m(() => [\n        k(Xo, T(i.$attrs, { ref: n(a) }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [Kt, Nl] = H(\"ScrollAreaScrollbar\"), yc = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbar\",\n  props: {\n    orientation: { default: \"vertical\" },\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $(), a = me(), s = S(() => t.orientation === \"horizontal\");\n    U(\n      s,\n      () => {\n        s.value ? a.onScrollbarXEnabledChange(!0) : a.onScrollbarYEnabledChange(!0);\n      },\n      { immediate: !0 }\n    ), fe(() => {\n      a.onScrollbarXEnabledChange(!1), a.onScrollbarYEnabledChange(!1);\n    });\n    const { orientation: r, forceMount: l, asChild: i, as: u } = z(t);\n    return Nl({\n      orientation: r,\n      forceMount: l,\n      isHorizontal: s,\n      as: u,\n      asChild: i\n    }), (d, p) => n(a).type.value === \"hover\" ? (h(), C(Ll, T({ key: 0 }, d.$attrs, {\n      ref: n(e),\n      \"force-mount\": n(l)\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : n(a).type.value === \"scroll\" ? (h(), C(Kl, T({ key: 1 }, d.$attrs, {\n      ref: n(e),\n      \"force-mount\": n(l)\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : n(a).type.value === \"auto\" ? (h(), C(ra, T({ key: 2 }, d.$attrs, {\n      ref: n(e),\n      \"force-mount\": n(l)\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : n(a).type.value === \"always\" ? (h(), C(Xo, T({ key: 3 }, d.$attrs, {\n      ref: n(e),\n      \"data-state\": \"visible\"\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", !0);\n  }\n}), bc = /* @__PURE__ */ b({\n  __name: \"ScrollAreaThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = me(), a = Lt();\n    function s(f) {\n      const g = f.target.getBoundingClientRect(), w = f.clientX - g.left, E = f.clientY - g.top;\n      a.handleThumbDown(f, { x: w, y: E });\n    }\n    function r(f) {\n      a.handleThumbUp(f);\n    }\n    const { forwardRef: l, currentElement: i } = $(), u = P(), d = S(() => e.viewport.value);\n    function p() {\n      if (!u.value) {\n        const f = Rl(\n          d.value,\n          a.onThumbPositionChange\n        );\n        u.value = f, a.onThumbPositionChange();\n      }\n    }\n    const c = S(() => a.sizes.value);\n    return is(c, () => {\n      a.onThumbChange(i.value), d.value && (a.onThumbPositionChange(), d.value.addEventListener(\"scroll\", p));\n    }), fe(() => {\n      var f;\n      d.value.removeEventListener(\"scroll\", p), (f = e.viewport.value) == null || f.removeEventListener(\"scroll\", p);\n    }), (f, v) => (h(), C(n(D), {\n      ref: n(l),\n      \"data-state\": n(a).hasThumb ? \"visible\" : \"hidden\",\n      style: re({\n        width: \"var(--radix-scroll-area-thumb-width)\",\n        height: \"var(--radix-scroll-area-thumb-height)\"\n      }),\n      \"as-child\": t.asChild,\n      as: f.as,\n      onPointerdown: s,\n      onPointerup: r\n    }, {\n      default: m(() => [\n        y(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-state\", \"style\", \"as-child\", \"as\"]));\n  }\n}), Hl = /* @__PURE__ */ b({\n  __name: \"ScrollAreaCornerImpl\",\n  setup(o) {\n    const t = me(), e = P(0), a = P(0), s = S(() => !!e.value && !!a.value);\n    function r() {\n      var u;\n      const i = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;\n      t.onCornerHeightChange(i), a.value = i;\n    }\n    function l() {\n      var u;\n      const i = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;\n      t.onCornerWidthChange(i), e.value = i;\n    }\n    return be(t.scrollbarX.value, r), be(t.scrollbarY.value, l), U(() => t.scrollbarX.value, r), U(() => t.scrollbarY.value, l), (i, u) => {\n      var d;\n      return s.value ? (h(), C(n(D), T({\n        key: 0,\n        style: {\n          width: `${e.value}px`,\n          height: `${a.value}px`,\n          position: \"absolute\",\n          right: n(t).dir.value === \"ltr\" ? 0 : void 0,\n          left: n(t).dir.value === \"rtl\" ? 0 : void 0,\n          bottom: 0\n        }\n      }, (d = i.$parent) == null ? void 0 : d.$props), {\n        default: m(() => [\n          y(i.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])) : X(\"\", !0);\n    };\n  }\n}), Cc = /* @__PURE__ */ b({\n  __name: \"ScrollAreaCorner\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $(), a = me(), s = S(\n      () => !!a.scrollbarX.value && !!a.scrollbarY.value\n    ), r = S(\n      () => a.type.value !== \"scroll\" && s.value\n    );\n    return (l, i) => r.value ? (h(), C(Hl, T({ key: 0 }, t, { ref: n(e) }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", !0);\n  }\n}), jl = [\"default-value\"], Wl = /* @__PURE__ */ b({\n  __name: \"BubbleSelect\",\n  props: {\n    autocomplete: {},\n    autofocus: { type: Boolean },\n    disabled: { type: Boolean },\n    form: {},\n    multiple: { type: Boolean },\n    name: {},\n    required: { type: Boolean },\n    size: {},\n    value: {}\n  },\n  setup(o) {\n    const t = o, { value: e } = z(t);\n    ms(e);\n    const a = P();\n    return (s, r) => (h(), C(n(Qe), { \"as-child\": \"\" }, {\n      default: m(() => [\n        fo(ut(\"select\", T({\n          ref_key: \"selectElement\",\n          ref: a\n        }, t, {\n          \"onUpdate:modelValue\": r[0] || (r[0] = (l) => dt(e) ? e.value = l : null),\n          \"default-value\": n(e)\n        }), [\n          y(s.$slots, \"default\")\n        ], 16, jl), [\n          [Fa, n(e)]\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), zl = {\n  key: 0,\n  value: \"\"\n}, [Ie, la] = H(\"SelectRoot\"), [Ul, ql] = H(\"SelectRoot\"), wc = /* @__PURE__ */ b({\n  __name: \"SelectRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    defaultValue: { default: \"\" },\n    modelValue: { default: void 0 },\n    dir: {},\n    name: {},\n    autocomplete: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean }\n  },\n  emits: [\"update:modelValue\", \"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), r = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), l = P(), i = P(), u = P({\n      x: 0,\n      y: 0\n    }), d = P(!1), { required: p, disabled: c, dir: f } = z(e), v = de(f);\n    la({\n      triggerElement: l,\n      onTriggerChange: (_) => {\n        l.value = _;\n      },\n      valueElement: i,\n      onValueElementChange: (_) => {\n        i.value = _;\n      },\n      valueElementHasChildren: d,\n      onValueElementHasChildrenChange: (_) => {\n        d.value = _;\n      },\n      contentId: te(),\n      modelValue: s,\n      onValueChange: (_) => {\n        s.value = _;\n      },\n      open: r,\n      required: p,\n      onOpenChange: (_) => {\n        r.value = _;\n      },\n      dir: v,\n      triggerPointerDownPosRef: u,\n      disabled: c\n    });\n    const g = Ne(l), w = P(/* @__PURE__ */ new Set()), E = S(() => Array.from(w.value).map((_) => {\n      var x;\n      return (x = _.props) == null ? void 0 : x.value;\n    }).join(\";\"));\n    return ql({\n      onNativeOptionAdd: (_) => {\n        w.value.add(_);\n      },\n      onNativeOptionRemove: (_) => {\n        w.value.delete(_);\n      }\n    }), (_, x) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(_.$slots, \"default\"),\n        n(g) ? (h(), C(Wl, T({ key: E.value }, _.$attrs, {\n          \"aria-hidden\": \"\",\n          tabindex: \"-1\",\n          required: n(p),\n          name: _.name,\n          autocomplete: _.autocomplete,\n          disabled: n(c),\n          value: n(s),\n          onChange: x[0] || (x[0] = (B) => s.value = B.target.value)\n        }), {\n          default: m(() => [\n            n(s) === void 0 ? (h(), Q(\"option\", zl)) : X(\"\", !0),\n            (h(!0), Q(le, null, po(Array.from(w.value), (B) => (h(), C(we(B), T(B.props, {\n              key: B.key ?? \"\"\n            }), null, 16))), 128))\n          ]),\n          _: 1\n        }, 16, [\"required\", \"name\", \"autocomplete\", \"disabled\", \"value\"])) : X(\"\", !0)\n      ]),\n      _: 3\n    }));\n  }\n}), Gl = [\" \", \"Enter\", \"ArrowUp\", \"ArrowDown\"], Yl = [\" \", \"Enter\"], Ce = 10;\nfunction ia(o) {\n  return o === \"\" || o === void 0;\n}\nconst _c = /* @__PURE__ */ b({\n  __name: \"SelectTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Ie(), a = S(() => {\n      var f;\n      return ((f = e.disabled) == null ? void 0 : f.value) || t.disabled;\n    }), { forwardRef: s, currentElement: r } = $();\n    q(() => {\n      e.triggerElement = r;\n    });\n    const { injectCollection: l } = ve(), i = l(), { search: u, handleTypeaheadSearch: d, resetTypeahead: p } = bo(i);\n    function c() {\n      a.value || (e.onOpenChange(!0), p());\n    }\n    return (f, v) => (h(), C(n(We), { \"as-child\": \"\" }, {\n      default: m(() => {\n        var g, w, E, _;\n        return [\n          k(n(D), {\n            ref: n(s),\n            role: \"combobox\",\n            type: f.as === \"button\" ? \"button\" : void 0,\n            \"aria-controls\": n(e).contentId,\n            \"aria-expanded\": n(e).open.value || !1,\n            \"aria-required\": (g = n(e).required) == null ? void 0 : g.value,\n            \"aria-autocomplete\": \"none\",\n            disabled: a.value,\n            dir: (w = n(e)) == null ? void 0 : w.dir.value,\n            \"data-state\": (E = n(e)) != null && E.open.value ? \"open\" : \"closed\",\n            \"data-disabled\": a.value ? \"\" : void 0,\n            \"data-placeholder\": n(ia)((_ = n(e).modelValue) == null ? void 0 : _.value) ? \"\" : void 0,\n            \"as-child\": f.asChild,\n            as: f.as,\n            onClick: v[0] || (v[0] = (x) => {\n              var B;\n              (B = x == null ? void 0 : x.currentTarget) == null || B.focus();\n            }),\n            onPointerdown: v[1] || (v[1] = (x) => {\n              const B = x.target;\n              B.hasPointerCapture(x.pointerId) && B.releasePointerCapture(x.pointerId), x.button === 0 && x.ctrlKey === !1 && (c(), n(e).triggerPointerDownPosRef.value = {\n                x: Math.round(x.pageX),\n                y: Math.round(x.pageY)\n              }, x.preventDefault());\n            }),\n            onPointerup: v[2] || (v[2] = oe(() => {\n            }, [\"prevent\"])),\n            onKeydown: v[3] || (v[3] = (x) => {\n              const B = n(u) !== \"\";\n              !(x.ctrlKey || x.altKey || x.metaKey) && x.key.length === 1 && B && x.key === \" \" || (n(d)(x.key), n(Gl).includes(x.key) && (c(), x.preventDefault()));\n            })\n          }, {\n            default: m(() => [\n              y(f.$slots, \"default\")\n            ]),\n            _: 3\n          }, 8, [\"type\", \"aria-controls\", \"aria-expanded\", \"aria-required\", \"disabled\", \"dir\", \"data-state\", \"data-disabled\", \"data-placeholder\", \"as-child\", \"as\"])\n        ];\n      }),\n      _: 3\n    }));\n  }\n}), $c = /* @__PURE__ */ b({\n  __name: \"SelectPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Jo, Xl] = H(\"SelectItemAlignedPosition\"), Jl = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"SelectItemAlignedPosition\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"placed\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { injectCollection: s } = ve(), r = Ie(), l = Ae(), i = s(), u = P(!1), d = P(!0), p = P(), { forwardRef: c, currentElement: f } = $(), { viewport: v, selectedItem: g, selectedItemText: w, focusSelectedItem: E } = l;\n    function _() {\n      if (r.triggerElement.value && r.valueElement.value && p.value && f.value && (v != null && v.value) && (g != null && g.value) && (w != null && w.value)) {\n        const O = r.triggerElement.value.getBoundingClientRect(), A = f.value.getBoundingClientRect(), M = r.valueElement.value.getBoundingClientRect(), R = w.value.getBoundingClientRect();\n        if (r.dir.value !== \"rtl\") {\n          const Re = R.left - A.left, xe = M.left - Re, Me = O.left - xe, ke = O.width + Me, Gt = Math.max(ke, A.width), Yt = window.innerWidth - Ce, Xt = on(xe, Ce, Yt - Gt);\n          p.value.style.minWidth = `${ke}px`, p.value.style.left = `${Xt}px`;\n        } else {\n          const Re = A.right - R.right, xe = window.innerWidth - M.right - Re, Me = window.innerWidth - O.right - xe, ke = O.width + Me, Gt = Math.max(ke, A.width), Yt = window.innerWidth - Ce, Xt = on(\n            xe,\n            Ce,\n            Yt - Gt\n          );\n          p.value.style.minWidth = `${ke}px`, p.value.style.right = `${Xt}px`;\n        }\n        const V = i.value, j = window.innerHeight - Ce * 2, I = v.value.scrollHeight, F = window.getComputedStyle(f.value), W = Number.parseInt(\n          F.borderTopWidth,\n          10\n        ), J = Number.parseInt(F.paddingTop, 10), K = Number.parseInt(\n          F.borderBottomWidth,\n          10\n        ), Z = Number.parseInt(\n          F.paddingBottom,\n          10\n        ), ne = W + J + I + Z + K, Ut = Math.min(\n          g.value.offsetHeight * 5,\n          ne\n        ), at = window.getComputedStyle(v.value), mt = Number.parseInt(at.paddingTop, 10), Sa = Number.parseInt(\n          at.paddingBottom,\n          10\n        ), ht = O.top + O.height / 2 - Ce, Ta = j - ht, qt = g.value.offsetHeight / 2, Da = g.value.offsetTop + qt, gt = W + J + Da, Oa = ne - gt;\n        if (gt <= ht) {\n          const Re = g.value === V[V.length - 1];\n          p.value.style.bottom = \"0px\";\n          const xe = f.value.clientHeight - v.value.offsetTop - v.value.offsetHeight, Me = Math.max(\n            Ta,\n            qt + (Re ? Sa : 0) + xe + K\n          ), ke = gt + Me;\n          p.value.style.height = `${ke}px`;\n        } else {\n          const Re = g.value === V[0];\n          p.value.style.top = \"0px\";\n          const Me = Math.max(\n            ht,\n            W + v.value.offsetTop + (Re ? mt : 0) + qt\n          ) + Oa;\n          p.value.style.height = `${Me}px`, v.value.scrollTop = gt - ht + v.value.offsetTop;\n        }\n        p.value.style.margin = `${Ce}px 0`, p.value.style.minHeight = `${Ut}px`, p.value.style.maxHeight = `${j}px`, a(\"placed\"), requestAnimationFrame(() => u.value = !0);\n      }\n    }\n    const x = P(\"\");\n    q(async () => {\n      await G(), _(), f.value && (x.value = window.getComputedStyle(f.value).zIndex);\n    });\n    function B(O) {\n      O && d.value === !0 && (_(), E == null || E(), d.value = !1);\n    }\n    return Xl({\n      contentWrapper: p,\n      shouldExpandOnScrollRef: u,\n      onScrollButtonChange: B\n    }), (O, A) => (h(), Q(\"div\", {\n      ref_key: \"contentWrapperElement\",\n      ref: p,\n      style: re({\n        display: \"flex\",\n        flexDirection: \"column\",\n        position: \"fixed\",\n        zIndex: x.value\n      })\n    }, [\n      k(n(D), T({\n        ref: n(c),\n        style: {\n          // When we get the height of the content, it includes borders. If we were to set\n          // the height without having `boxSizing: 'border-box'` it would be too big.\n          boxSizing: \"border-box\",\n          // We need to ensure the content doesn't get taller than the wrapper\n          maxHeight: \"100%\"\n        }\n      }, { ...O.$attrs, ...e }), {\n        default: m(() => [\n          y(O.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])\n    ], 4));\n  }\n}), Zl = /* @__PURE__ */ b({\n  __name: \"SelectPopperPosition\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: { default: Ce },\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const e = He(o);\n    return (a, s) => (h(), C(n(Fe), T(n(e), { style: {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-select-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-select-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-select-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-select-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-select-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), nt = {\n  onViewportChange: () => {\n  },\n  itemTextRefCallback: () => {\n  },\n  itemRefCallback: () => {\n  }\n}, [Ae, Ql] = H(\"SelectContent\"), ei = /* @__PURE__ */ b({\n  __name: \"SelectContentImpl\",\n  props: {\n    position: { default: \"item-aligned\" },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = Ie();\n    yo(), ct(!0);\n    const { createCollection: r } = ve(), l = P();\n    pt(l);\n    const i = r(l), { search: u, handleTypeaheadSearch: d } = bo(i), p = P(), c = P(), f = P(), v = P(!1), g = P(!1);\n    function w() {\n      c.value && l.value && ao([c.value, l.value]);\n    }\n    U(v, () => {\n      w();\n    });\n    const { onOpenChange: E, triggerPointerDownPosRef: _ } = s;\n    ee((A) => {\n      if (!l.value)\n        return;\n      let M = { x: 0, y: 0 };\n      const R = (j) => {\n        var I, F;\n        M = {\n          x: Math.abs(\n            Math.round(j.pageX) - (((I = _.value) == null ? void 0 : I.x) ?? 0)\n          ),\n          y: Math.abs(\n            Math.round(j.pageY) - (((F = _.value) == null ? void 0 : F.y) ?? 0)\n          )\n        };\n      }, V = (j) => {\n        var I;\n        M.x <= 10 && M.y <= 10 ? j.preventDefault() : (I = l.value) != null && I.contains(j.target) || E(!1), document.removeEventListener(\"pointermove\", R), _.value = null;\n      };\n      _.value !== null && (document.addEventListener(\"pointermove\", R), document.addEventListener(\"pointerup\", V, {\n        capture: !0,\n        once: !0\n      })), A(() => {\n        document.removeEventListener(\"pointermove\", R), document.removeEventListener(\"pointerup\", V, {\n          capture: !0\n        });\n      });\n    });\n    function x(A) {\n      const M = A.ctrlKey || A.altKey || A.metaKey;\n      if (A.key === \"Tab\" && A.preventDefault(), !M && A.key.length === 1 && d(A.key), [\"ArrowUp\", \"ArrowDown\", \"Home\", \"End\"].includes(A.key)) {\n        let R = i.value;\n        if ([\"ArrowUp\", \"End\"].includes(A.key) && (R = R.slice().reverse()), [\"ArrowUp\", \"ArrowDown\"].includes(A.key)) {\n          const V = A.target, j = R.indexOf(V);\n          R = R.slice(j + 1);\n        }\n        setTimeout(() => ao(R)), A.preventDefault();\n      }\n    }\n    const B = S(() => e.position === \"popper\" ? e : {}), O = He(B.value);\n    return Ql({\n      content: l,\n      viewport: p,\n      onViewportChange: (A) => {\n        p.value = A;\n      },\n      itemRefCallback: (A, M, R) => {\n        var I, F;\n        const V = !g.value && !R;\n        (((I = s.modelValue) == null ? void 0 : I.value) !== void 0 && ((F = s.modelValue) == null ? void 0 : F.value) === M || V) && (c.value = A, V && (g.value = !0));\n      },\n      selectedItem: c,\n      selectedItemText: f,\n      onItemLeave: () => {\n        var A;\n        (A = l.value) == null || A.focus();\n      },\n      itemTextRefCallback: (A, M, R) => {\n        var I, F;\n        const V = !g.value && !R;\n        (((I = s.modelValue) == null ? void 0 : I.value) !== void 0 && ((F = s.modelValue) == null ? void 0 : F.value) === M || V) && (f.value = A);\n      },\n      focusSelectedItem: w,\n      position: e.position,\n      isPositioned: v,\n      searchRef: u\n    }), (A, M) => (h(), C(n(At), {\n      \"as-child\": \"\",\n      onMountAutoFocus: M[6] || (M[6] = oe(() => {\n      }, [\"prevent\"])),\n      onUnmountAutoFocus: M[7] || (M[7] = (R) => {\n        var V;\n        a(\"closeAutoFocus\", R), !R.defaultPrevented && ((V = n(s).triggerElement.value) == null || V.focus({ preventScroll: !0 }), R.preventDefault());\n      })\n    }, {\n      default: m(() => [\n        k(n(De), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": \"\",\n          onFocusOutside: M[2] || (M[2] = oe(() => {\n          }, [\"prevent\"])),\n          onDismiss: M[3] || (M[3] = (R) => n(s).onOpenChange(!1)),\n          onEscapeKeyDown: M[4] || (M[4] = (R) => a(\"escapeKeyDown\", R)),\n          onPointerDownOutside: M[5] || (M[5] = (R) => a(\"pointerDownOutside\", R))\n        }, {\n          default: m(() => [\n            (h(), C(we(\n              A.position === \"popper\" ? Zl : Jl\n            ), T({ ...A.$attrs, ...n(O) }, {\n              id: n(s).contentId,\n              ref: (R) => {\n                l.value = n(pe)(R);\n              },\n              role: \"listbox\",\n              \"data-state\": n(s).open.value ? \"open\" : \"closed\",\n              dir: n(s).dir.value,\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\"\n              },\n              onContextmenu: M[0] || (M[0] = oe(() => {\n              }, [\"prevent\"])),\n              onPlaced: M[1] || (M[1] = (R) => v.value = !0),\n              onKeydown: x\n            }), {\n              default: m(() => [\n                y(A.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"dir\", \"onKeydown\"]))\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }));\n  }\n}), ti = /* @__PURE__ */ b({\n  __name: \"SelectProvider\",\n  props: {\n    context: {}\n  },\n  setup(o) {\n    return la(o.context), (e, a) => y(e.$slots, \"default\");\n  }\n}), xc = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"SelectContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o, { emit: t }) {\n    const s = ae(o, t), r = Ie(), l = P();\n    q(() => {\n      l.value = new DocumentFragment();\n    });\n    const i = P();\n    return (u, d) => {\n      var p;\n      return h(), Q(le, null, [\n        k(n(se), {\n          ref_key: \"presenceRef\",\n          ref: i,\n          present: u.forceMount || n(r).open.value\n        }, {\n          default: m(() => [\n            k(ei, L(N({ ...n(s), ...u.$attrs })), {\n              default: m(() => [\n                y(u.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16)\n          ]),\n          _: 3\n        }, 8, [\"present\"]),\n        !((p = i.value) != null && p.present) && l.value ? (h(), C(Ye, {\n          key: 0,\n          to: l.value\n        }, [\n          k(ti, { context: n(r) }, {\n            default: m(() => [\n              ut(\"div\", null, [\n                y(u.$slots, \"default\")\n              ])\n            ]),\n            _: 3\n          }, 8, [\"context\"])\n        ], 8, [\"to\"])) : X(\"\", !0)\n      ], 64);\n    };\n  }\n}), Ec = /* @__PURE__ */ b({\n  __name: \"SelectArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o, e = Ie(), a = Ae();\n    return (s, r) => n(e).open.value && n(a).position === \"popper\" ? (h(), C(n(Ze), L(T({ key: 0 }, t)), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", !0);\n  }\n}), Pc = /* @__PURE__ */ b({\n  __name: \"SelectSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(D), T({ \"aria-hidden\": \"\" }, t), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [ua, oi] = H(\"SelectItem\"), Bc = /* @__PURE__ */ b({\n  __name: \"SelectItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { disabled: e } = z(t), a = Ie(), s = Ae(nt), { forwardRef: r, currentElement: l } = $(), i = S(() => {\n      var w;\n      return ((w = a.modelValue) == null ? void 0 : w.value) === t.value;\n    }), u = P(!1), d = P(t.textValue ?? \"\"), p = te();\n    async function c(w) {\n      await G(), !(w != null && w.defaultPrevented) && (e.value || (a.onValueChange(t.value), a.onOpenChange(!1)));\n    }\n    async function f(w) {\n      var E;\n      await G(), !w.defaultPrevented && (e.value ? (E = s.onItemLeave) == null || E.call(s) : w.currentTarget.focus({ preventScroll: !0 }));\n    }\n    async function v(w) {\n      var E;\n      await G(), !w.defaultPrevented && w.currentTarget === document.activeElement && ((E = s.onItemLeave) == null || E.call(s));\n    }\n    async function g(w) {\n      var _;\n      await G(), !(w.defaultPrevented || ((_ = s.searchRef) == null ? void 0 : _.value) !== \"\" && w.key === \" \") && (Yl.includes(w.key) && c(), w.key === \" \" && w.preventDefault());\n    }\n    if (t.value === \"\")\n      throw new Error(\n        \"A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return q(() => {\n      l.value && s.itemRefCallback(\n        l.value,\n        t.value,\n        t.disabled\n      );\n    }), oi({\n      value: t.value,\n      disabled: e,\n      textId: p,\n      isSelected: i,\n      onItemTextChange: (w) => {\n        d.value = ((d.value || (w == null ? void 0 : w.textContent)) ?? \"\").trim();\n      }\n    }), (w, E) => (h(), C(n(D), {\n      ref: n(r),\n      role: \"option\",\n      \"data-radix-vue-collection-item\": \"\",\n      \"aria-labelledby\": n(p),\n      \"data-highlighted\": u.value ? \"\" : void 0,\n      \"aria-selected\": i.value && u.value,\n      \"data-state\": i.value ? \"checked\" : \"unchecked\",\n      \"aria-disabled\": n(e) || void 0,\n      \"data-disabled\": n(e) ? \"\" : void 0,\n      tabindex: n(e) ? void 0 : -1,\n      as: w.as,\n      \"as-child\": w.asChild,\n      onFocus: E[0] || (E[0] = (_) => u.value = !0),\n      onBlur: E[1] || (E[1] = (_) => u.value = !1),\n      onPointerup: c,\n      onTouchend: E[2] || (E[2] = oe(() => {\n      }, [\"prevent\", \"stop\"])),\n      onPointermove: f,\n      onPointerleave: v,\n      onKeydown: g\n    }, {\n      default: m(() => [\n        y(w.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"tabindex\", \"as\", \"as-child\"]));\n  }\n}), Sc = /* @__PURE__ */ b({\n  __name: \"SelectItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = ua();\n    return (a, s) => n(e).isSelected.value ? (h(), C(n(D), T({\n      key: 0,\n      \"aria-hidden\": \"\"\n    }, t), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", !0);\n  }\n}), [ni, ai] = H(\"SelectGroup\"), Tc = /* @__PURE__ */ b({\n  __name: \"SelectGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = te();\n    return ai({ id: e }), (a, s) => (h(), C(n(D), T({ role: \"group\" }, t, { \"aria-labelledby\": n(e) }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"]));\n  }\n}), Dc = /* @__PURE__ */ b({\n  __name: \"SelectLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o) {\n    const t = o, e = ni({ id: \"\" });\n    return (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).id\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Oc = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"SelectItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = Ie(), a = Ae(nt), s = Ul(), r = ua(), { forwardRef: l, currentElement: i } = $(), u = S(() => {\n      var d;\n      return Ve(\"option\", {\n        key: r.value,\n        value: r.value,\n        disabled: r.disabled.value,\n        innerHTML: (d = i.value) == null ? void 0 : d.textContent\n      });\n    });\n    return q(() => {\n      i.value && (r.onItemTextChange(i.value), a.itemTextRefCallback(\n        i.value,\n        r.value,\n        r.disabled.value\n      ), s.onNativeOptionAdd(u.value));\n    }), co(() => {\n      s.onNativeOptionRemove(u.value);\n    }), (d, p) => (h(), Q(le, null, [\n      k(n(D), T({\n        id: n(r).textId,\n        ref: n(l)\n      }, { ...t, ...d.$attrs }), {\n        default: m(() => [\n          y(d.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\"]),\n      n(r).isSelected.value && n(e).valueElement.value && !n(e).valueElementHasChildren.value ? (h(), C(Ye, {\n        key: 0,\n        to: n(e).valueElement.value\n      }, [\n        y(d.$slots, \"default\")\n      ], 8, [\"to\"])) : X(\"\", !0)\n    ], 64));\n  }\n}), Ic = /* @__PURE__ */ b({\n  __name: \"SelectViewport\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Ae(nt), a = e.position === \"item-aligned\" ? Jo() : void 0, { forwardRef: s, currentElement: r } = $();\n    q(() => {\n      e == null || e.onViewportChange(r.value);\n    });\n    const l = P(0);\n    function i(u) {\n      const d = u.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: c } = a ?? {};\n      if (p != null && p.value && (c != null && c.value)) {\n        const f = Math.abs(l.value - d.scrollTop);\n        if (f > 0) {\n          const v = window.innerHeight - Ce * 2, g = Number.parseFloat(\n            c.value.style.minHeight\n          ), w = Number.parseFloat(c.value.style.height), E = Math.max(g, w);\n          if (E < v) {\n            const _ = E + f, x = Math.min(v, _), B = _ - x;\n            c.value.style.height = `${x}px`, c.value.style.bottom === \"0px\" && (d.scrollTop = B > 0 ? B : 0, c.value.style.justifyContent = \"flex-end\");\n          }\n        }\n      }\n      l.value = d.scrollTop;\n    }\n    return (u, d) => (h(), Q(le, null, [\n      k(n(D), T({\n        ref: n(s),\n        \"data-radix-select-viewport\": \"\",\n        role: \"presentation\"\n      }, { ...u.$attrs, ...t }, {\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        },\n        onScroll: i\n      }), {\n        default: m(() => [\n          y(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"]),\n      k(n(D), { as: \"style\" }, {\n        default: m(() => [\n          ue(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      })\n    ], 64));\n  }\n}), da = /* @__PURE__ */ b({\n  __name: \"SelectScrollButtonImpl\",\n  emits: [\"autoScroll\"],\n  setup(o, { emit: t }) {\n    const e = t, { injectCollection: a } = ve(), s = a(), r = Ae(nt), l = P(null);\n    function i() {\n      l.value !== null && (window.clearInterval(l.value), l.value = null);\n    }\n    ee(() => {\n      const p = s.value.find(\n        (c) => c === document.activeElement\n      );\n      p == null || p.scrollIntoView({ block: \"nearest\" });\n    });\n    function u() {\n      l.value === null && (l.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    function d() {\n      var p;\n      (p = r.onItemLeave) == null || p.call(r), l.value === null && (l.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    return co(() => i()), (p, c) => {\n      var f;\n      return h(), C(n(D), T({\n        \"aria-hidden\": \"\",\n        style: {\n          flexShrink: 0\n        }\n      }, (f = p.$parent) == null ? void 0 : f.$props, {\n        onPointerdown: u,\n        onPointermove: d,\n        onPointerleave: c[0] || (c[0] = () => {\n          i();\n        })\n      }), {\n        default: m(() => [\n          y(p.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16);\n    };\n  }\n}), Ac = /* @__PURE__ */ b({\n  __name: \"SelectScrollUpButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = Ae(nt), e = t.position === \"item-aligned\" ? Jo() : void 0, { forwardRef: a, currentElement: s } = $(), r = P(!1);\n    return ee((l) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          r.value = p.scrollTop > 0;\n        };\n        const p = t.viewport.value;\n        d(), p.addEventListener(\"scroll\", d), l(() => p.removeEventListener(\"scroll\", d));\n      }\n    }), U(s, () => {\n      s.value && (e == null || e.onScrollButtonChange(s.value));\n    }), (l, i) => r.value ? (h(), C(da, {\n      key: 0,\n      ref: n(a),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = n(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);\n      })\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : X(\"\", !0);\n  }\n}), Rc = /* @__PURE__ */ b({\n  __name: \"SelectScrollDownButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = Ae(nt), e = t.position === \"item-aligned\" ? Jo() : void 0, { forwardRef: a, currentElement: s } = $(), r = P(!1);\n    return ee((l) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          const c = p.scrollHeight - p.clientHeight;\n          r.value = Math.ceil(p.scrollTop) < c;\n        };\n        const p = t.viewport.value;\n        d(), p.addEventListener(\"scroll\", d), l(() => p.removeEventListener(\"scroll\", d));\n      }\n    }), U(s, () => {\n      s.value && (e == null || e.onScrollButtonChange(s.value));\n    }), (l, i) => r.value ? (h(), C(da, {\n      key: 0,\n      ref: n(a),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = n(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);\n      })\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : X(\"\", !0);\n  }\n}), Mc = /* @__PURE__ */ b({\n  __name: \"SelectValue\",\n  props: {\n    placeholder: { default: \"\" },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const { forwardRef: t, currentElement: e } = $(), a = Ie(), s = xn();\n    return $n(() => {\n      var l;\n      const r = !!Ot((l = s == null ? void 0 : s.default) == null ? void 0 : l.call(s)).length;\n      a.onValueElementHasChildrenChange(r);\n    }), q(() => {\n      a.valueElement = e;\n    }), (r, l) => (h(), C(n(D), {\n      ref: n(t),\n      as: r.as,\n      \"as-child\": r.asChild,\n      style: { pointerEvents: \"none\" }\n    }, {\n      default: m(() => {\n        var i;\n        return [\n          n(ia)((i = n(a).modelValue) == null ? void 0 : i.value) ? (h(), Q(le, { key: 0 }, [\n            ue(Le(r.placeholder), 1)\n          ], 64)) : y(r.$slots, \"default\", { key: 1 })\n        ];\n      }),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), kc = /* @__PURE__ */ b({\n  __name: \"SelectIcon\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    return (t, e) => (h(), C(n(D), {\n      \"aria-hidden\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild\n    }, {\n      default: m(() => [\n        y(t.$slots, \"default\", {}, () => [\n          ue(\"\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), ca = /* @__PURE__ */ b({\n  __name: \"BaseSeparator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = [\"horizontal\", \"vertical\"];\n    function a(i) {\n      return e.includes(i);\n    }\n    const s = S(\n      () => a(t.orientation) ? t.orientation : \"horizontal\"\n    ), r = S(\n      () => s.value === \"vertical\" ? t.orientation : void 0\n    ), l = S(\n      () => t.decorative ? { role: \"none\" } : { \"aria-orientation\": r.value, role: \"separator\" }\n    );\n    return (i, u) => (h(), C(n(D), T({\n      as: i.as,\n      \"as-child\": i.asChild,\n      \"data-orientation\": s.value\n    }, l.value), {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"data-orientation\"]));\n  }\n}), Vc = /* @__PURE__ */ b({\n  __name: \"Separator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(ca, L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction pa(o, [t, e]) {\n  return Math.min(e, Math.max(t, o));\n}\nfunction si(o = [], t, e) {\n  const a = [...o];\n  return a[e] = t, a.sort((s, r) => s - r);\n}\nfunction fa(o, t, e) {\n  const r = 100 / (e - t) * (o - t);\n  return pa(r, [0, 100]);\n}\nfunction ri(o, t) {\n  return t > 2 ? `Value ${o + 1} of ${t}` : t === 2 ? [\"Minimum\", \"Maximum\"][o] : void 0;\n}\nfunction li(o, t) {\n  if (o.length === 1)\n    return 0;\n  const e = o.map((s) => Math.abs(s - t)), a = Math.min(...e);\n  return e.indexOf(a);\n}\nfunction ii(o, t, e) {\n  const a = o / 2, r = Zo([0, 50], [0, a]);\n  return (a - r(t) * e) * e;\n}\nfunction ui(o) {\n  return o.slice(0, -1).map((t, e) => o[e + 1] - t);\n}\nfunction di(o, t) {\n  if (t > 0) {\n    const e = ui(o);\n    return Math.min(...e) >= t;\n  }\n  return !0;\n}\nfunction Zo(o, t) {\n  return (e) => {\n    if (o[0] === o[1] || t[0] === t[1])\n      return t[0];\n    const a = (t[1] - t[0]) / (o[1] - o[0]);\n    return t[0] + a * (e - o[0]);\n  };\n}\nfunction ci(o) {\n  return (String(o).split(\".\")[1] || \"\").length;\n}\nfunction pi(o, t) {\n  const e = 10 ** t;\n  return Math.round(o * e) / e;\n}\nconst va = [\"PageUp\", \"PageDown\"], ma = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"], ha = {\n  \"from-left\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-right\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowRight\"],\n  \"from-bottom\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-top\": [\"Home\", \"PageDown\", \"ArrowUp\", \"ArrowLeft\"]\n}, [ga, ya] = H([\"SliderVertical\", \"SliderHorizontal\"]), ba = /* @__PURE__ */ b({\n  __name: \"SliderImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  emits: [\"slideStart\", \"slideMove\", \"slideEnd\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = Nt();\n    return (r, l) => (h(), C(n(D), T({ \"data-slider-impl\": \"\" }, e, {\n      onKeydown: l[0] || (l[0] = (i) => {\n        i.key === \"Home\" ? (a(\"homeKeyDown\", i), i.preventDefault()) : i.key === \"End\" ? (a(\"endKeyDown\", i), i.preventDefault()) : n(va).concat(n(ma)).includes(i.key) && (a(\"stepKeyDown\", i), i.preventDefault());\n      }),\n      onPointerdown: l[1] || (l[1] = (i) => {\n        const u = i.target;\n        u.setPointerCapture(i.pointerId), i.preventDefault(), n(s).thumbElements.value.includes(u) ? u.focus() : a(\"slideStart\", i);\n      }),\n      onPointermove: l[2] || (l[2] = (i) => {\n        i.target.hasPointerCapture(i.pointerId) && a(\"slideMove\", i);\n      }),\n      onPointerup: l[3] || (l[3] = (i) => {\n        const u = i.target;\n        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), a(\"slideEnd\", i));\n      })\n    }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fi = /* @__PURE__ */ b({\n  __name: \"SliderHorizontal\",\n  props: {\n    dir: {},\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { max: s, min: r, dir: l, inverted: i } = z(e), { forwardRef: u, currentElement: d } = $(), p = P(), c = S(() => (l == null ? void 0 : l.value) === \"ltr\" && !i.value || (l == null ? void 0 : l.value) !== \"ltr\" && i.value);\n    function f(v) {\n      const g = p.value || d.value.getBoundingClientRect(), w = [0, g.width], E = c.value ? [r.value, s.value] : [s.value, r.value], _ = Zo(w, E);\n      return p.value = g, _(v - g.left);\n    }\n    return ya({\n      startEdge: c.value ? \"left\" : \"right\",\n      endEdge: c.value ? \"right\" : \"left\",\n      direction: c.value ? 1 : -1,\n      size: \"width\"\n    }), (v, g) => (h(), C(ba, {\n      ref: n(u),\n      dir: n(l),\n      \"data-orientation\": \"horizontal\",\n      style: re({\n        \"--radix-slider-thumb-transform\": \"translateX(-50%)\"\n      }),\n      onSlideStart: g[0] || (g[0] = (w) => {\n        const E = f(w.clientX);\n        a(\"slideStart\", E);\n      }),\n      onSlideMove: g[1] || (g[1] = (w) => {\n        const E = f(w.clientX);\n        a(\"slideMove\", E);\n      }),\n      onSlideEnd: g[2] || (g[2] = () => {\n        p.value = void 0, a(\"slideEnd\");\n      }),\n      onStepKeyDown: g[3] || (g[3] = (w) => {\n        const E = c.value ? \"from-left\" : \"from-right\", _ = n(ha)[E].includes(w.key);\n        a(\"stepKeyDown\", w, _ ? -1 : 1);\n      }),\n      onEndKeyDown: g[4] || (g[4] = (w) => a(\"endKeyDown\", w)),\n      onHomeKeyDown: g[5] || (g[5] = (w) => a(\"homeKeyDown\", w))\n    }, {\n      default: m(() => [\n        y(v.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"dir\", \"style\"]));\n  }\n}), vi = /* @__PURE__ */ b({\n  __name: \"SliderVertical\",\n  props: {\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { max: s, min: r, inverted: l } = z(e), { forwardRef: i, currentElement: u } = $(), d = P(), p = S(() => !l.value);\n    function c(f) {\n      const v = d.value || u.value.getBoundingClientRect(), g = [0, v.height], w = p.value ? [s.value, r.value] : [r.value, s.value], E = Zo(g, w);\n      return d.value = v, E(f - v.top);\n    }\n    return ya({\n      startEdge: p.value ? \"bottom\" : \"top\",\n      endEdge: p.value ? \"top\" : \"bottom\",\n      size: \"height\",\n      direction: p.value ? 1 : -1\n    }), (f, v) => (h(), C(ba, {\n      ref: n(i),\n      \"data-orientation\": \"vertical\",\n      style: re({\n        \"--radix-slider-thumb-transform\": \"translateY(50%)\"\n      }),\n      onSlideStart: v[0] || (v[0] = (g) => {\n        const w = c(g.clientY);\n        a(\"slideStart\", w);\n      }),\n      onSlideMove: v[1] || (v[1] = (g) => {\n        const w = c(g.clientY);\n        a(\"slideMove\", w);\n      }),\n      onSlideEnd: v[2] || (v[2] = () => {\n        d.value = void 0, a(\"slideEnd\");\n      }),\n      onStepKeyDown: v[3] || (v[3] = (g) => {\n        const w = p.value ? \"from-bottom\" : \"from-top\", E = n(ha)[w].includes(g.key);\n        a(\"stepKeyDown\", g, E ? -1 : 1);\n      }),\n      onEndKeyDown: v[4] || (v[4] = (g) => a(\"endKeyDown\", g)),\n      onHomeKeyDown: v[5] || (v[5] = (g) => a(\"homeKeyDown\", g))\n    }, {\n      default: m(() => [\n        y(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), mi = [\"value\", \"name\", \"disabled\", \"step\"], [Nt, hi] = H(\"SliderRoot\"), Fc = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"SliderRoot\",\n  props: {\n    name: {},\n    defaultValue: { default: () => [0] },\n    modelValue: {},\n    disabled: { type: Boolean, default: !1 },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    inverted: { type: Boolean, default: !1 },\n    min: { default: 0 },\n    max: { default: 100 },\n    step: { default: 1 },\n    minStepsBetweenThumbs: { default: 0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"valueCommit\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { min: s, max: r, step: l, minStepsBetweenThumbs: i, orientation: u, disabled: d, dir: p } = z(e), c = de(p), { forwardRef: f, currentElement: v } = $(), g = Ne(v);\n    Bo();\n    const w = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), E = P(0), _ = P(w.value);\n    function x(R) {\n      const V = li(w.value, R);\n      A(R, V);\n    }\n    function B(R) {\n      A(R, E.value);\n    }\n    function O() {\n      const R = _.value[E.value];\n      w.value[E.value] !== R && a(\"valueCommit\", La(w.value));\n    }\n    function A(R, V, { commit: j } = { commit: !1 }) {\n      var K;\n      const I = ci(l.value), F = pi(Math.round((R - s.value) / l.value) * l.value + s.value, I), W = pa(F, [s.value, r.value]), J = si(w.value, W, V);\n      if (di(J, i.value * l.value)) {\n        E.value = J.indexOf(W);\n        const Z = String(J) !== String(w.value);\n        Z && j && a(\"valueCommit\", J), Z && ((K = M.value[E.value]) == null || K.focus(), w.value = J);\n      }\n    }\n    const M = P([]);\n    return hi({\n      modelValue: w,\n      valueIndexToChangeRef: E,\n      thumbElements: M,\n      orientation: u,\n      min: s,\n      max: r,\n      disabled: d\n    }), (R, V) => (h(), Q(le, null, [\n      k(n(So), null, {\n        default: m(() => [\n          (h(), C(we(n(u) === \"horizontal\" ? fi : vi), T(R.$attrs, {\n            ref: n(f),\n            \"as-child\": R.asChild,\n            as: R.as,\n            min: n(s),\n            max: n(r),\n            dir: n(c),\n            inverted: R.inverted,\n            \"aria-disabled\": n(d),\n            \"data-disabled\": n(d) ? \"\" : void 0,\n            onPointerdown: V[0] || (V[0] = () => {\n              n(d) || (_.value = n(w));\n            }),\n            onSlideStart: V[1] || (V[1] = (j) => !n(d) && x(j)),\n            onSlideMove: V[2] || (V[2] = (j) => !n(d) && B(j)),\n            onSlideEnd: V[3] || (V[3] = (j) => !n(d) && O()),\n            onHomeKeyDown: V[4] || (V[4] = (j) => !n(d) && A(n(s), 0, { commit: !0 })),\n            onEndKeyDown: V[5] || (V[5] = (j) => !n(d) && A(n(r), n(w).length - 1, { commit: !0 })),\n            onStepKeyDown: V[6] || (V[6] = (j, I) => {\n              if (!n(d)) {\n                const J = n(va).includes(j.key) || j.shiftKey && n(ma).includes(j.key) ? 10 : 1, K = E.value, Z = n(w)[K], ne = n(l) * J * I;\n                A(Z + ne, K, { commit: !0 });\n              }\n            })\n          }), {\n            default: m(() => [\n              y(R.$slots, \"default\", { modelValue: n(w) })\n            ]),\n            _: 3\n          }, 16, [\"as-child\", \"as\", \"min\", \"max\", \"dir\", \"inverted\", \"aria-disabled\", \"data-disabled\"]))\n        ]),\n        _: 3\n      }),\n      n(g) ? (h(!0), Q(le, { key: 0 }, po(n(w), (j, I) => (h(), Q(\"input\", {\n        key: I,\n        value: j,\n        type: \"number\",\n        style: { display: \"none\" },\n        name: R.name ? R.name + (n(w).length > 1 ? \"[]\" : \"\") : void 0,\n        disabled: n(d),\n        step: n(l)\n      }, null, 8, mi))), 128)) : X(\"\", !0)\n    ], 64));\n  }\n}), gi = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"SliderThumbImpl\",\n  props: {\n    index: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Nt(), a = ga(), { forwardRef: s, currentElement: r } = $(), l = S(() => {\n      var v, g;\n      return (g = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : g[t.index];\n    }), i = S(() => l.value === void 0 ? 0 : fa(l.value, e.min.value ?? 0, e.max.value ?? 100)), u = S(() => {\n      var v, g;\n      return ri(t.index, ((g = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : g.length) ?? 0);\n    }), d = Dn(r), p = S(() => d[a.size].value), c = S(() => p.value ? ii(p.value, i.value, a.direction) : 0), f = Dt();\n    return q(() => {\n      e.thumbElements.value.push(r.value);\n    }), fe(() => {\n      const v = e.thumbElements.value.findIndex((g) => g === r.value) ?? -1;\n      e.thumbElements.value.splice(v, 1);\n    }), (v, g) => (h(), C(n(To), null, {\n      default: m(() => [\n        k(n(D), T(v.$attrs, {\n          ref: n(s),\n          role: \"slider\",\n          \"data-radix-vue-collection-item\": \"\",\n          tabindex: n(e).disabled.value ? void 0 : 0,\n          \"aria-label\": v.$attrs[\"aria-label\"] || u.value,\n          \"data-disabled\": n(e).disabled.value ? \"\" : void 0,\n          \"data-orientation\": n(e).orientation.value,\n          \"aria-valuenow\": l.value,\n          \"aria-valuemin\": n(e).min.value,\n          \"aria-valuemax\": n(e).max.value,\n          \"aria-orientation\": n(e).orientation.value,\n          \"as-child\": v.asChild,\n          as: v.as,\n          style: {\n            transform: \"var(--radix-slider-thumb-transform)\",\n            position: \"absolute\",\n            [n(a).startEdge]: `calc(${i.value}% + ${c.value}px)`,\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            display: !n(f) && l.value === void 0 ? \"none\" : void 0\n          },\n          onFocus: g[0] || (g[0] = () => {\n            n(e).valueIndexToChangeRef.value = v.index;\n          })\n        }), {\n          default: m(() => [\n            y(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"tabindex\", \"aria-label\", \"data-disabled\", \"data-orientation\", \"aria-valuenow\", \"aria-valuemin\", \"aria-valuemax\", \"aria-orientation\", \"as-child\", \"as\", \"style\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Lc = /* @__PURE__ */ b({\n  __name: \"SliderThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { getItems: e } = Wn(), { forwardRef: a, currentElement: s } = $(), r = S(() => s.value ? e().findIndex((l) => l.ref === s.value) : -1);\n    return (l, i) => (h(), C(gi, T({ ref: n(a) }, t, { index: r.value }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"index\"]));\n  }\n}), Kc = /* @__PURE__ */ b({\n  __name: \"SliderTrack\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = Nt();\n    return $(), (e, a) => (h(), C(n(D), {\n      \"as-child\": e.asChild,\n      as: e.as,\n      \"data-disabled\": n(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": n(t).orientation.value\n    }, {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), Nc = /* @__PURE__ */ b({\n  __name: \"SliderRange\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = Nt(), e = ga();\n    $();\n    const a = S(() => {\n      var l, i;\n      return (i = (l = t.modelValue) == null ? void 0 : l.value) == null ? void 0 : i.map(\n        (u) => fa(u, t.min.value, t.max.value)\n      );\n    }), s = S(() => t.modelValue.value.length > 1 ? Math.min(...a.value) : 0), r = S(() => 100 - Math.max(...a.value));\n    return (l, i) => (h(), C(n(D), {\n      \"data-disabled\": n(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": n(t).orientation.value,\n      \"as-child\": l.asChild,\n      as: l.as,\n      style: re({\n        [n(e).startEdge]: `${s.value}%`,\n        [n(e).endEdge]: `${r.value}%`\n      })\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-disabled\", \"data-orientation\", \"as-child\", \"as\", \"style\"]));\n  }\n}), yi = [\"name\", \"disabled\", \"required\", \"value\", \"checked\", \"data-state\", \"data-disabled\"], [bi, Ci] = H(\"SwitchRoot\"), Hc = /* @__PURE__ */ b({\n  __name: \"SwitchRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    value: { default: \"on\" },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { disabled: s } = z(e), r = Y(e, \"checked\", a, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    });\n    function l() {\n      s.value || (r.value = !r.value);\n    }\n    const { forwardRef: i, currentElement: u } = $(), d = Ne(u), p = S(() => {\n      var c;\n      return e.id && u.value ? (c = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : c.innerText : void 0;\n    });\n    return Ci({\n      checked: r,\n      toggleCheck: l,\n      disabled: s\n    }), (c, f) => (h(), Q(le, null, [\n      k(n(D), T(c.$attrs, {\n        id: c.id,\n        ref: n(i),\n        role: \"switch\",\n        type: c.as === \"button\" ? \"button\" : void 0,\n        value: c.value,\n        \"aria-label\": c.$attrs[\"aria-label\"] || p.value,\n        \"aria-checked\": n(r),\n        \"aria-required\": c.required,\n        \"data-state\": n(r) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": n(s) ? \"\" : void 0,\n        \"as-child\": c.asChild,\n        as: c.as,\n        disabled: n(s),\n        onClick: l,\n        onKeydown: ie(oe(l, [\"prevent\"]), [\"enter\"])\n      }), {\n        default: m(() => [\n          y(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"type\", \"value\", \"aria-label\", \"aria-checked\", \"aria-required\", \"data-state\", \"data-disabled\", \"as-child\", \"as\", \"disabled\", \"onKeydown\"]),\n      n(d) ? (h(), Q(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        name: c.name,\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        disabled: n(s),\n        required: c.required,\n        value: c.value,\n        checked: !!n(r),\n        \"data-state\": n(r) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": n(s) ? \"\" : void 0,\n        style: re({\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        })\n      }, null, 12, yi)) : X(\"\", !0)\n    ], 64));\n  }\n}), jc = /* @__PURE__ */ b({\n  __name: \"SwitchThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = bi();\n    return $(), (e, a) => {\n      var s;\n      return h(), C(n(D), {\n        \"data-state\": (s = n(t).checked) != null && s.value ? \"checked\" : \"unchecked\",\n        \"data-disabled\": n(t).disabled.value ? \"\" : void 0,\n        \"as-child\": e.asChild,\n        as: e.as\n      }, {\n        default: m(() => [\n          y(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"]);\n    };\n  }\n}), [Ht, wi] = H(\"TabsRoot\"), Wc = /* @__PURE__ */ b({\n  __name: \"TabsRoot\",\n  props: {\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    activationMode: { default: \"automatic\" },\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { orientation: s, dir: r } = z(e), l = de(r);\n    $();\n    const i = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), u = P();\n    return wi({\n      modelValue: i,\n      changeModelValue: (d) => {\n        i.value = d;\n      },\n      orientation: s,\n      dir: l,\n      activationMode: e.activationMode,\n      baseId: te(),\n      tabsList: u\n    }), (d, p) => (h(), C(n(D), {\n      dir: n(l),\n      \"data-orientation\": n(s),\n      \"as-child\": d.asChild,\n      as: d.as\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"dir\", \"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), zc = /* @__PURE__ */ b({\n  __name: \"TabsList\",\n  props: {\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { loop: e } = z(t), { forwardRef: a, currentElement: s } = $(), r = Ht();\n    return r.tabsList = s, (l, i) => (h(), C(n(et), {\n      \"as-child\": \"\",\n      orientation: n(r).orientation.value,\n      dir: n(r).dir.value,\n      loop: n(e)\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(a),\n          role: \"tablist\",\n          \"as-child\": l.asChild,\n          as: l.as,\n          \"aria-orientation\": n(r).orientation.value\n        }, {\n          default: m(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"aria-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n});\nfunction Ca(o, t) {\n  return `${o}-trigger-${t}`;\n}\nfunction wa(o, t) {\n  return `${o}-content-${t}`;\n}\nconst Uc = /* @__PURE__ */ b({\n  __name: \"TabsContent\",\n  props: {\n    value: {},\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $(), a = Ht(), s = S(() => Ca(a.baseId, t.value)), r = S(() => wa(a.baseId, t.value)), l = S(() => t.value === a.modelValue.value), i = P(l.value);\n    return q(() => {\n      requestAnimationFrame(() => {\n        i.value = !1;\n      });\n    }), (u, d) => (h(), C(n(se), {\n      present: l.value,\n      \"force-mount\": \"\"\n    }, {\n      default: m(({ present: p }) => [\n        k(n(D), {\n          id: r.value,\n          ref: n(e),\n          \"as-child\": u.asChild,\n          as: u.as,\n          role: \"tabpanel\",\n          \"data-state\": l.value ? \"active\" : \"inactive\",\n          \"data-orientation\": n(a).orientation.value,\n          \"aria-labelledby\": s.value,\n          hidden: !p.value,\n          tabindex: \"0\",\n          style: re({\n            animationDuration: i.value ? \"0s\" : void 0\n          })\n        }, {\n          default: m(() => [\n            u.forceMount || l.value ? y(u.$slots, \"default\", { key: 0 }) : X(\"\", !0)\n          ]),\n          _: 2\n        }, 1032, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-orientation\", \"aria-labelledby\", \"hidden\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), qc = /* @__PURE__ */ b({\n  __name: \"TabsTrigger\",\n  props: {\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $(), a = Ht(), s = S(() => Ca(a.baseId, t.value)), r = S(() => wa(a.baseId, t.value)), l = S(() => t.value === a.modelValue.value);\n    return (i, u) => (h(), C(n(tt), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      active: l.value\n    }, {\n      default: m(() => [\n        k(n(D), {\n          id: s.value,\n          ref: n(e),\n          role: \"tab\",\n          type: i.as === \"button\" ? \"button\" : void 0,\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"aria-selected\": l.value ? \"true\" : \"false\",\n          \"aria-controls\": r.value,\n          \"data-state\": l.value ? \"active\" : \"inactive\",\n          disabled: i.disabled,\n          \"data-disabled\": i.disabled ? \"\" : void 0,\n          \"data-orientation\": n(a).orientation.value,\n          onMousedown: u[0] || (u[0] = oe((d) => {\n            !i.disabled && d.ctrlKey === !1 ? n(a).changeModelValue(i.value) : d.preventDefault();\n          }, [\"left\"])),\n          onKeydown: u[1] || (u[1] = ie((d) => n(a).changeModelValue(i.value), [\"enter\", \"space\"])),\n          onFocus: u[2] || (u[2] = () => {\n            const d = n(a).activationMode !== \"manual\";\n            !l.value && !i.disabled && d && n(a).changeModelValue(i.value);\n          })\n        }, {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as\", \"as-child\", \"aria-selected\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), Gc = /* @__PURE__ */ b({\n  __name: \"TabsIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Ht();\n    $();\n    const a = P({\n      size: null,\n      position: null\n    });\n    U(() => e.modelValue.value, async (r) => {\n      await G(), s();\n    }, { immediate: !0 }), be(e.tabsList, s);\n    function s() {\n      var l;\n      const r = (l = e.tabsList.value) == null ? void 0 : l.querySelector('[role=\"tab\"][data-state=\"active\"]');\n      r && (e.orientation.value === \"horizontal\" ? a.value = {\n        size: r.offsetWidth,\n        position: r.offsetLeft\n      } : a.value = {\n        size: r.offsetHeight,\n        position: r.offsetTop\n      });\n    }\n    return (r, l) => typeof a.value.size == \"number\" ? (h(), C(n(D), T({ key: 0 }, t, {\n      style: {\n        \"--radix-tabs-indicator-size\": `${a.value.size}px`,\n        \"--radix-tabs-indicator-position\": `${a.value.position}px`\n      }\n    }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"])) : X(\"\", !0);\n  }\n}), [jt, _i] = H(\"TagsInputRoot\"), Yc = /* @__PURE__ */ b({\n  __name: \"TagsInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: { default: () => [] },\n    addOnPaste: { type: Boolean },\n    duplicate: { type: Boolean },\n    disabled: { type: Boolean },\n    delimiter: { default: \",\" },\n    dir: {},\n    max: { default: 0 },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"invalid\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { addOnPaste: s, disabled: r, delimiter: l, max: i, id: u, dir: d } = z(e), p = de(d), c = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: !0,\n      deep: !0\n    }), { forwardRef: f, currentElement: v } = $(), { focused: g } = vs(v), w = Ne(v), { getItems: E } = Bo(), _ = P(), x = P(!1);\n    return _i({\n      modelValue: c,\n      onAddValue: (B) => {\n        if (c.value.length >= i.value && i.value)\n          return a(\"invalid\", B), !1;\n        if (e.duplicate)\n          return c.value.push(B), !0;\n        if (c.value.includes(B))\n          x.value = !0;\n        else\n          return c.value.push(B), !0;\n        return a(\"invalid\", B), !1;\n      },\n      onRemoveValue: (B) => {\n        B !== -1 && c.value.splice(B, 1);\n      },\n      onInputKeydown: (B) => {\n        const O = B.target, A = E().map((R) => R.ref).filter((R) => R.dataset.disabled !== \"\");\n        if (!A.length)\n          return;\n        const M = A.at(-1);\n        switch (B.key) {\n          case \"Delete\":\n          case \"Backspace\": {\n            if (O.selectionStart !== 0 || O.selectionEnd !== 0)\n              break;\n            if (_.value) {\n              const R = A.findIndex((V) => V === _.value);\n              c.value.splice(R, 1), _.value = _.value === M ? A.at(R - 1) : A.at(R + 1), B.preventDefault();\n            } else\n              B.key === \"Backspace\" && (_.value = M, B.preventDefault());\n            break;\n          }\n          case \"Home\":\n          case \"End\":\n          case \"ArrowRight\":\n          case \"ArrowLeft\": {\n            const R = B.key === \"ArrowRight\" && p.value === \"ltr\" || B.key === \"ArrowLeft\" && p.value === \"rtl\", V = !R;\n            if (O.selectionStart !== 0 || O.selectionEnd !== 0)\n              break;\n            if (V && !_.value)\n              _.value = M, B.preventDefault();\n            else if (R && M && _.value === M)\n              _.value = void 0, B.preventDefault();\n            else if (_.value) {\n              const j = Je(B, _.value, void 0, {\n                itemsArray: A,\n                loop: !1,\n                dir: p.value\n              });\n              j && (_.value = j), B.preventDefault();\n            }\n            break;\n          }\n          case \"ArrowUp\":\n          case \"ArrowDown\": {\n            _.value && B.preventDefault();\n            break;\n          }\n          default:\n            _.value = void 0;\n        }\n      },\n      selectedElement: _,\n      isInvalidInput: x,\n      addOnPaste: s,\n      dir: p,\n      disabled: r,\n      delimiter: l,\n      max: i,\n      id: u\n    }), (B, O) => (h(), C(n(So), null, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(f),\n          dir: n(p),\n          as: B.as,\n          \"as-child\": B.asChild,\n          \"data-invalid\": x.value ? \"\" : void 0,\n          \"data-disabled\": n(r) ? \"\" : void 0,\n          \"data-focused\": n(g) ? \"\" : void 0\n        }, {\n          default: m(() => [\n            y(B.$slots, \"default\", { modelValue: n(c) }),\n            n(w) && B.name ? (h(), C(n(jn), {\n              key: 0,\n              name: B.name,\n              value: n(c),\n              required: B.required,\n              disabled: n(r)\n            }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"])) : X(\"\", !0)\n          ]),\n          _: 3\n        }, 8, [\"dir\", \"as\", \"as-child\", \"data-invalid\", \"data-disabled\", \"data-focused\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Xc = /* @__PURE__ */ b({\n  __name: \"TagsInputInput\",\n  props: {\n    placeholder: {},\n    autoFocus: { type: Boolean },\n    maxLength: {},\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(o) {\n    const t = o, e = jt(), { forwardRef: a, currentElement: s } = $();\n    async function r(u) {\n      if (await G(), u.defaultPrevented)\n        return;\n      const d = u.target;\n      if (!d.value)\n        return;\n      e.onAddValue(d.value) && (d.value = \"\"), u.preventDefault();\n    }\n    function l(u) {\n      e.isInvalidInput.value = !1;\n      const d = e.delimiter.value;\n      if (d === u.data) {\n        const p = u.target;\n        p.value = p.value.replaceAll(d, \"\"), e.onAddValue(p.value) && (p.value = \"\");\n      }\n    }\n    function i(u) {\n      if (e.addOnPaste.value) {\n        u.preventDefault();\n        const d = u.clipboardData;\n        if (!d)\n          return;\n        const p = d.getData(\"text\");\n        e.delimiter.value ? p.split(e.delimiter.value).forEach((f) => {\n          e.onAddValue(f);\n        }) : e.onAddValue(p);\n      }\n    }\n    return q(() => {\n      const u = s.value.nodeName === \"INPUT\" ? s.value : s.value.querySelector(\"input\");\n      u && setTimeout(() => {\n        t.autoFocus && (u == null || u.focus());\n      }, 1);\n    }), (u, d) => {\n      var p;\n      return h(), C(n(D), {\n        id: (p = n(e).id) == null ? void 0 : p.value,\n        ref: n(a),\n        type: \"text\",\n        autocomplete: \"off\",\n        autocorrect: \"off\",\n        autocapitalize: \"off\",\n        as: u.as,\n        \"as-child\": u.asChild,\n        maxlength: u.maxLength,\n        placeholder: u.placeholder,\n        disabled: n(e).disabled.value,\n        \"data-invalid\": n(e).isInvalidInput.value ? \"\" : void 0,\n        onInput: l,\n        onKeydown: [\n          ie(r, [\"enter\"]),\n          n(e).onInputKeydown\n        ],\n        onPaste: i\n      }, {\n        default: m(() => [\n          y(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"id\", \"as\", \"as-child\", \"maxlength\", \"placeholder\", \"disabled\", \"data-invalid\", \"onKeydown\"]);\n    };\n  }\n}), [_a, $i] = H(\"TagsInputItem\"), Jc = /* @__PURE__ */ b({\n  __name: \"TagsInputItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { value: e } = z(t), a = jt(), { forwardRef: s, currentElement: r } = $(), l = S(() => a.selectedElement.value === r.value), i = te(), u = S(() => t.disabled || a.disabled.value);\n    return $i({\n      value: e,\n      isSelected: l,\n      disabled: u,\n      textId: i\n    }), (d, p) => (h(), C(n(To), null, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(s),\n          as: d.as,\n          \"as-child\": d.asChild,\n          \"aria-labelledby\": n(i),\n          \"aria-current\": l.value,\n          \"data-disabled\": u.value ? \"\" : void 0,\n          \"data-state\": l.value ? \"active\" : \"inactive\"\n        }, {\n          default: m(() => [\n            y(d.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"aria-labelledby\", \"aria-current\", \"data-disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Zc = /* @__PURE__ */ b({\n  __name: \"TagsInputItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o) {\n    const t = o, e = _a();\n    return $(), (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).textId\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\", {}, () => [\n          ue(Le(n(e).value.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Qc = /* @__PURE__ */ b({\n  __name: \"TagsInputItemDelete\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = jt(), a = _a(), s = S(() => {\n      var l;\n      return ((l = a.disabled) == null ? void 0 : l.value) || e.disabled.value;\n    });\n    function r() {\n      if (s.value)\n        return;\n      const l = e.modelValue.value.findIndex((i) => i === a.value.value);\n      e.onRemoveValue(l);\n    }\n    return (l, i) => (h(), C(n(D), T({ tabindex: \"-1\" }, t, {\n      \"aria-labelledby\": n(a).textId,\n      \"aria-current\": n(a).isSelected.value,\n      \"data-state\": n(a).isSelected.value ? \"active\" : \"inactive\",\n      \"data-disabled\": s.value ? \"\" : void 0,\n      type: l.as === \"button\" ? \"button\" : void 0,\n      onClick: r\n    }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\", \"aria-current\", \"data-state\", \"data-disabled\", \"type\"]));\n  }\n}), ep = /* @__PURE__ */ b({\n  __name: \"TagsInputClear\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o;\n    $();\n    const e = jt();\n    function a() {\n      e.disabled.value || (e.modelValue.value = []);\n    }\n    return (s, r) => (h(), C(n(D), T(t, {\n      type: s.as === \"button\" ? \"button\" : void 0,\n      \"data-disabled\": n(e).disabled.value ? \"\" : void 0,\n      onClick: a\n    }), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"data-disabled\"]));\n  }\n}), [Wt, xi] = H(\"ToastProvider\"), tp = /* @__PURE__ */ b({\n  __name: \"ToastProvider\",\n  props: {\n    label: { default: \"Notification\" },\n    duration: { default: 5e3 },\n    swipeDirection: { default: \"right\" },\n    swipeThreshold: { default: 50 }\n  },\n  setup(o) {\n    const t = o, { label: e, duration: a, swipeDirection: s, swipeThreshold: r } = z(t), l = P(), i = P(0), u = P(!1), d = P(!1);\n    if (t.label && typeof t.label == \"string\" && !t.label.trim()) {\n      const p = \"Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.\";\n      throw new Error(p);\n    }\n    return xi({\n      label: e,\n      duration: a,\n      swipeDirection: s,\n      swipeThreshold: r,\n      toastCount: i,\n      viewport: l,\n      onViewportChange(p) {\n        l.value = p;\n      },\n      onToastAdd() {\n        i.value++;\n      },\n      onToastRemove() {\n        i.value--;\n      },\n      isFocusedToastEscapeKeyDownRef: u,\n      isClosePausedRef: d\n    }), (p, c) => y(p.$slots, \"default\");\n  }\n}), Ei = \"toast.swipeStart\", Pi = \"toast.swipeMove\", Bi = \"toast.swipeCancel\", Si = \"toast.swipeEnd\", lo = \"toast.viewportPause\", io = \"toast.viewportResume\";\nfunction $t(o, t, e) {\n  const a = e.originalEvent.currentTarget, s = new CustomEvent(o, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && a.addEventListener(o, t, { once: !0 }), a.dispatchEvent(s);\n}\nfunction pn(o, t, e = 0) {\n  const a = Math.abs(o.x), s = Math.abs(o.y), r = a > s;\n  return t === \"left\" || t === \"right\" ? r && a > e : !r && s > e;\n}\nfunction Ti(o) {\n  return o.nodeType === o.ELEMENT_NODE;\n}\nfunction $a(o) {\n  const t = [];\n  return Array.from(o.childNodes).forEach((a) => {\n    if (a.nodeType === a.TEXT_NODE && a.textContent && t.push(a.textContent), Ti(a)) {\n      const s = a.ariaHidden || a.hidden || a.style.display === \"none\", r = a.dataset.radixToastAnnounceExclude === \"\";\n      if (!s)\n        if (r) {\n          const l = a.dataset.radixToastAnnounceAlt;\n          l && t.push(l);\n        } else\n          t.push(...$a(a));\n    }\n  }), t;\n}\nconst Di = /* @__PURE__ */ b({\n  __name: \"ToastAnnounce\",\n  setup(o) {\n    const t = Wt(), e = ls(1e3), a = P(!1);\n    return cs(() => {\n      a.value = !0;\n    }), (s, r) => n(e) || a.value ? (h(), C(n(Qe), { key: 0 }, {\n      default: m(() => [\n        ue(Le(n(t).label.value) + \" \", 1),\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    })) : X(\"\", !0);\n  }\n}), [Oi, Ii] = H(\"ToastRoot\"), Ai = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"ToastRootImpl\",\n  props: {\n    type: {},\n    open: { type: Boolean, default: !1 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"close\", \"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { forwardRef: s, currentElement: r } = $(), l = Wt(), i = P(null), u = P(null), d = S(() => e.duration || l.duration.value), p = P(0), c = P(d.value), f = P(0);\n    function v(E) {\n      !E || E === Number.POSITIVE_INFINITY || (window.clearTimeout(f.value), p.value = (/* @__PURE__ */ new Date()).getTime(), f.value = window.setTimeout(g, E));\n    }\n    function g() {\n      var _, x;\n      ((_ = r.value) == null ? void 0 : _.contains(document.activeElement)) && ((x = l.viewport.value) == null || x.focus()), a(\"close\");\n    }\n    const w = S(() => r.value ? $a(r.value) : null);\n    if (e.type && ![\"foreground\", \"background\"].includes(e.type)) {\n      const E = \"Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.\";\n      throw new Error(E);\n    }\n    return ee((E) => {\n      const _ = l.viewport.value;\n      if (_) {\n        const x = () => {\n          v(c.value), a(\"resume\");\n        }, B = () => {\n          const O = (/* @__PURE__ */ new Date()).getTime() - p.value;\n          c.value = c.value - O, window.clearTimeout(f.value), a(\"pause\");\n        };\n        return _.addEventListener(lo, B), _.addEventListener(io, x), () => {\n          _.removeEventListener(lo, B), _.removeEventListener(io, x);\n        };\n      }\n    }), ee(() => {\n      e.open && !l.isClosePausedRef.value && v(d.value);\n    }), go(\"Escape\", (E) => {\n      a(\"escapeKeyDown\", E), E.defaultPrevented || (l.isFocusedToastEscapeKeyDownRef.value = !0, g());\n    }), q(() => {\n      l.onToastAdd();\n    }), fe(() => {\n      l.onToastRemove();\n    }), Ii({ onClose: g }), (E, _) => (h(), Q(le, null, [\n      w.value ? (h(), C(Di, {\n        key: 0,\n        role: \"status\",\n        \"aria-live\": E.type === \"foreground\" ? \"assertive\" : \"polite\",\n        \"aria-atomic\": \"\"\n      }, {\n        default: m(() => [\n          ue(Le(w.value), 1)\n        ]),\n        _: 1\n      }, 8, [\"aria-live\"])) : X(\"\", !0),\n      (h(), C(Ye, {\n        to: n(l).viewport.value\n      }, [\n        k(n(D), T({\n          ref: n(s),\n          role: \"status\",\n          \"aria-live\": \"off\",\n          \"aria-atomic\": \"\",\n          tabindex: \"0\",\n          \"data-radix-vue-collection-item\": \"\"\n        }, E.$attrs, {\n          as: E.as,\n          \"as-child\": E.asChild,\n          \"data-state\": E.open ? \"open\" : \"closed\",\n          \"data-swipe-direction\": n(l).swipeDirection.value,\n          style: { userSelect: \"none\", touchAction: \"none\" },\n          onPointerdown: _[0] || (_[0] = oe((x) => {\n            i.value = { x: x.clientX, y: x.clientY };\n          }, [\"left\"])),\n          onPointermove: _[1] || (_[1] = (x) => {\n            if (!i.value)\n              return;\n            const B = x.clientX - i.value.x, O = x.clientY - i.value.y, A = !!u.value, M = [\"left\", \"right\"].includes(n(l).swipeDirection.value), R = [\"left\", \"up\"].includes(n(l).swipeDirection.value) ? Math.min : Math.max, V = M ? R(0, B) : 0, j = M ? 0 : R(0, O), I = x.pointerType === \"touch\" ? 10 : 2, F = { x: V, y: j }, W = { originalEvent: x, delta: F };\n            A ? (u.value = F, n($t)(n(Pi), (J) => a(\"swipeMove\", J), W)) : n(pn)(F, n(l).swipeDirection.value, I) ? (u.value = F, n($t)(n(Ei), (J) => a(\"swipeStart\", J), W), x.target.setPointerCapture(x.pointerId)) : (Math.abs(B) > I || Math.abs(O) > I) && (i.value = null);\n          }),\n          onPointerup: _[2] || (_[2] = (x) => {\n            const B = u.value, O = x.target;\n            if (O.hasPointerCapture(x.pointerId) && O.releasePointerCapture(x.pointerId), u.value = null, i.value = null, B) {\n              const A = x.currentTarget, M = { originalEvent: x, delta: B };\n              n(pn)(B, n(l).swipeDirection.value, n(l).swipeThreshold.value) ? n($t)(n(Si), (R) => a(\"swipeEnd\", R), M) : n($t)(n(Bi), (R) => a(\"swipeCancel\", R), M), A == null || A.addEventListener(\"click\", (R) => R.preventDefault(), {\n                once: !0\n              });\n            }\n          })\n        }), {\n          default: m(() => [\n            y(E.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"data-state\", \"data-swipe-direction\"])\n      ], 8, [\"to\"]))\n    ], 64));\n  }\n}), op = /* @__PURE__ */ b({\n  __name: \"ToastRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !0 },\n    forceMount: { type: Boolean },\n    type: { default: \"foreground\" },\n    open: { type: Boolean, default: void 0 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\", \"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { forwardRef: s } = $(), r = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (l, i) => (h(), C(n(se), {\n      present: l.forceMount || n(r)\n    }, {\n      default: m(() => [\n        k(Ai, T({\n          ref: n(s),\n          open: n(r),\n          type: l.type,\n          as: l.as,\n          \"as-child\": l.asChild,\n          duration: l.duration\n        }, l.$attrs, {\n          onClose: i[0] || (i[0] = (u) => r.value = !1),\n          onPause: i[1] || (i[1] = (u) => a(\"pause\")),\n          onResume: i[2] || (i[2] = (u) => a(\"resume\")),\n          onEscapeKeyDown: i[3] || (i[3] = (u) => a(\"escapeKeyDown\", u)),\n          onSwipeStart: i[4] || (i[4] = (u) => {\n            a(\"swipeStart\", u), u.currentTarget.setAttribute(\"data-swipe\", \"start\");\n          }),\n          onSwipeMove: i[5] || (i[5] = (u) => {\n            const { x: d, y: p } = u.detail.delta, c = u.currentTarget;\n            c.setAttribute(\"data-swipe\", \"move\"), c.style.setProperty(\"--radix-toast-swipe-move-x\", `${d}px`), c.style.setProperty(\"--radix-toast-swipe-move-y\", `${p}px`);\n          }),\n          onSwipeCancel: i[6] || (i[6] = (u) => {\n            const d = u.currentTarget;\n            d.setAttribute(\"data-swipe\", \"cancel\"), d.style.removeProperty(\"--radix-toast-swipe-move-x\"), d.style.removeProperty(\"--radix-toast-swipe-move-y\"), d.style.removeProperty(\"--radix-toast-swipe-end-x\"), d.style.removeProperty(\"--radix-toast-swipe-end-y\");\n          }),\n          onSwipeEnd: i[7] || (i[7] = (u) => {\n            const { x: d, y: p } = u.detail.delta, c = u.currentTarget;\n            c.setAttribute(\"data-swipe\", \"end\"), c.style.removeProperty(\"--radix-toast-swipe-move-x\"), c.style.removeProperty(\"--radix-toast-swipe-move-y\"), c.style.setProperty(\"--radix-toast-swipe-end-x\", `${d}px`), c.style.setProperty(\"--radix-toast-swipe-end-y\", `${p}px`), r.value = !1;\n          })\n        }), {\n          default: m(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"open\", \"type\", \"as\", \"as-child\", \"duration\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), xa = /* @__PURE__ */ b({\n  __name: \"ToastAnnounceExclude\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    return (t, e) => (h(), C(n(D), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-radix-toast-announce-exclude\": \"\",\n      \"data-radix-toast-announce-alt\": t.altText || void 0\n    }, {\n      default: m(() => [\n        y(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-radix-toast-announce-alt\"]));\n  }\n}), Ri = /* @__PURE__ */ b({\n  __name: \"ToastClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = Oi(), { forwardRef: a } = $();\n    return (s, r) => (h(), C(xa, { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), T(t, {\n          ref: n(a),\n          type: s.as === \"button\" ? \"button\" : void 0,\n          onClick: r[0] || (r[0] = (l) => n(e).onClose())\n        }), {\n          default: m(() => [\n            y(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }));\n  }\n}), np = /* @__PURE__ */ b({\n  __name: \"ToastAction\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    if (!o.altText)\n      throw new Error(\"Missing prop `altText` expected on `ToastAction`\");\n    const { forwardRef: e } = $();\n    return (a, s) => a.altText ? (h(), C(xa, {\n      key: 0,\n      \"alt-text\": a.altText,\n      \"as-child\": \"\"\n    }, {\n      default: m(() => [\n        k(Ri, {\n          ref: n(e),\n          as: a.as,\n          \"as-child\": a.asChild\n        }, {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\"])\n      ]),\n      _: 3\n    }, 8, [\"alt-text\"])) : X(\"\", !0);\n  }\n}), fn = /* @__PURE__ */ b({\n  __name: \"FocusProxy\",\n  emits: [\"focusFromOutsideViewport\"],\n  setup(o, { emit: t }) {\n    const e = t, a = Wt();\n    return (s, r) => (h(), C(n(Qe), {\n      \"aria-hidden\": \"\",\n      tabindex: \"0\",\n      style: { position: \"fixed\" },\n      onFocus: r[0] || (r[0] = (l) => {\n        var d;\n        const i = l.relatedTarget;\n        !((d = n(a).viewport.value) != null && d.contains(i)) && e(\"focusFromOutsideViewport\");\n      })\n    }, {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), ap = /* @__PURE__ */ b({\n  inheritAttrs: !1,\n  __name: \"ToastViewport\",\n  props: {\n    hotkey: { default: () => [\"F8\"] },\n    label: { default: \"Notifications ({hotkey})\" },\n    asChild: { type: Boolean },\n    as: { default: \"ol\" }\n  },\n  setup(o) {\n    const t = o, { hotkey: e, label: a } = z(t), { forwardRef: s, currentElement: r } = $(), { createCollection: l } = ve(), i = l(r), u = Wt(), d = S(() => u.toastCount.value > 0), p = P(), c = P();\n    go(e.value, () => {\n      r.value.focus();\n    }), q(() => {\n      u.onViewportChange(r.value);\n    }), ee((v) => {\n      const g = r.value;\n      if (d.value && g) {\n        const w = () => {\n          if (!u.isClosePausedRef.value) {\n            const O = new CustomEvent(lo);\n            g.dispatchEvent(O), u.isClosePausedRef.value = !0;\n          }\n        }, E = () => {\n          if (u.isClosePausedRef.value) {\n            const O = new CustomEvent(io);\n            g.dispatchEvent(O), u.isClosePausedRef.value = !1;\n          }\n        }, _ = (O) => {\n          !g.contains(O.relatedTarget) && E();\n        }, x = () => {\n          g.contains(document.activeElement) || E();\n        }, B = (O) => {\n          var R, V, j;\n          const A = O.altKey || O.ctrlKey || O.metaKey;\n          if (O.key === \"Tab\" && !A) {\n            const I = document.activeElement, F = O.shiftKey;\n            if (O.target === g && F) {\n              (R = p.value) == null || R.focus();\n              return;\n            }\n            const K = f({ tabbingDirection: F ? \"backwards\" : \"forwards\" }), Z = K.findIndex((ne) => ne === I);\n            xt(K.slice(Z + 1)) ? O.preventDefault() : F ? (V = p.value) == null || V.focus() : (j = c.value) == null || j.focus();\n          }\n        };\n        g.addEventListener(\"focusin\", w), g.addEventListener(\"focusout\", _), g.addEventListener(\"pointermove\", w), g.addEventListener(\"pointerleave\", x), g.addEventListener(\"keydown\", B), window.addEventListener(\"blur\", w), window.addEventListener(\"focus\", E), v(() => {\n          g.removeEventListener(\"focusin\", w), g.removeEventListener(\"focusout\", _), g.removeEventListener(\"pointermove\", w), g.removeEventListener(\"pointerleave\", x), g.removeEventListener(\"keydown\", B), window.removeEventListener(\"blur\", w), window.removeEventListener(\"focus\", E);\n        });\n      }\n    });\n    function f({ tabbingDirection: v }) {\n      const w = i.value.map((E) => {\n        const _ = [E, ...$o(E)];\n        return v === \"forwards\" ? _ : _.reverse();\n      });\n      return (v === \"forwards\" ? w.reverse() : w).flat();\n    }\n    return (v, g) => (h(), C(n(Ws), {\n      role: \"region\",\n      \"aria-label\": n(a).replace(\"{hotkey}\", n(e).join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\")),\n      tabindex: \"-1\",\n      style: re({\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        pointerEvents: d.value ? void 0 : \"none\"\n      })\n    }, {\n      default: m(() => [\n        d.value ? (h(), C(fn, {\n          key: 0,\n          ref: (w) => {\n            p.value = n(pe)(w);\n          },\n          onFocusFromOutsideViewport: g[0] || (g[0] = () => {\n            const w = f({\n              tabbingDirection: \"forwards\"\n            });\n            n(xt)(w);\n          })\n        }, null, 512)) : X(\"\", !0),\n        k(n(D), T({\n          ref: n(s),\n          tabindex: \"-1\",\n          as: v.as,\n          \"as-child\": v.asChild\n        }, v.$attrs), {\n          default: m(() => [\n            y(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\"]),\n        d.value ? (h(), C(fn, {\n          key: 1,\n          ref: (w) => {\n            c.value = n(pe)(w);\n          },\n          onFocusFromOutsideViewport: g[1] || (g[1] = () => {\n            const w = f({\n              tabbingDirection: \"backwards\"\n            });\n            n(xt)(w);\n          })\n        }, null, 512)) : X(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"aria-label\", \"style\"]));\n  }\n}), sp = /* @__PURE__ */ b({\n  __name: \"ToastTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(D), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rp = /* @__PURE__ */ b({\n  __name: \"ToastDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(D), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Mi = /* @__PURE__ */ b({\n  __name: \"Toggle\",\n  props: {\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:pressed\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t;\n    $();\n    const s = Y(e, \"pressed\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.pressed === void 0\n    });\n    function r() {\n      s.value = !s.value;\n    }\n    const l = S(() => s.value ? \"on\" : \"off\");\n    return (i, u) => (h(), C(n(D), {\n      type: i.as === \"button\" ? \"button\" : void 0,\n      \"as-child\": e.asChild,\n      as: i.as,\n      \"aria-pressed\": n(s),\n      \"data-state\": l.value,\n      \"data-disabled\": i.disabled ? \"\" : void 0,\n      disabled: i.disabled,\n      onClick: r\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as-child\", \"as\", \"aria-pressed\", \"data-state\", \"data-disabled\", \"disabled\"]));\n  }\n}), [ki, Vi] = H(\"ToggleGroupRoot\"), Fi = /* @__PURE__ */ b({\n  __name: \"ToggleGroupRoot\",\n  props: {\n    type: { default: \"single\" },\n    defaultValue: {},\n    modelValue: {},\n    rovingFocus: { type: Boolean, default: !0 },\n    disabled: { type: Boolean, default: !1 },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, { loop: s, rovingFocus: r, disabled: l, dir: i } = z(e), u = de(i), { forwardRef: d } = $(), { modelValue: p, changeModelValue: c } = Rn(e, a);\n    return Vi({\n      type: e.type,\n      modelValue: p,\n      changeModelValue: c,\n      dir: u,\n      orientation: e.orientation,\n      loop: s,\n      rovingFocus: r,\n      disabled: l\n    }), (f, v) => (h(), C(we(n(r) ? n(et) : n(D)), {\n      \"as-child\": \"\",\n      orientation: n(r) ? f.orientation : void 0,\n      dir: n(u),\n      loop: n(r) ? n(s) : void 0\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(d),\n          role: \"group\",\n          \"as-child\": f.asChild,\n          as: f.as\n        }, {\n          default: m(() => [\n            y(f.$slots, \"default\", { modelValue: n(p) })\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Li = /* @__PURE__ */ b({\n  __name: \"ToggleGroupItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = ki(), a = S(() => {\n      var l;\n      return ((l = e.disabled) == null ? void 0 : l.value) || t.disabled;\n    }), s = S(() => {\n      var l;\n      return (l = e.modelValue.value) == null ? void 0 : l.includes(t.value);\n    }), { forwardRef: r } = $();\n    return (l, i) => (h(), C(we(n(e).rovingFocus.value ? n(tt) : n(D)), {\n      \"as-child\": \"\",\n      focusable: !a.value,\n      active: s.value\n    }, {\n      default: m(() => {\n        var u;\n        return [\n          k(n(Mi), T(t, {\n            ref: n(r),\n            disabled: a.value,\n            pressed: n(e).type === \"single\" ? n(e).modelValue.value === l.value : (u = n(e).modelValue.value) == null ? void 0 : u.includes(l.value),\n            \"onUpdate:pressed\": i[0] || (i[0] = (d) => n(e).changeModelValue(l.value))\n          }), {\n            default: m(() => [\n              y(l.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"disabled\", \"pressed\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), [Ea, Ki] = H(\"ToolbarRoot\"), lp = /* @__PURE__ */ b({\n  __name: \"ToolbarRoot\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { orientation: e, dir: a } = z(t), s = de(a), { forwardRef: r } = $();\n    return Ki({ orientation: e, dir: s }), (l, i) => (h(), C(n(et), {\n      \"as-child\": \"\",\n      orientation: n(e),\n      dir: n(s),\n      loop: l.loop\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(r),\n          role: \"toolbar\",\n          \"aria-orientation\": n(e),\n          \"as-child\": l.asChild,\n          as: l.as\n        }, {\n          default: m(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"aria-orientation\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Ni = /* @__PURE__ */ b({\n  __name: \"ToolbarButton\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $();\n    return (a, s) => (h(), C(n(tt), {\n      \"as-child\": \"\",\n      focusable: !a.disabled\n    }, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(e),\n          type: a.as === \"button\" ? \"button\" : void 0\n        }, t), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\"]));\n  }\n}), ip = /* @__PURE__ */ b({\n  __name: \"ToolbarLink\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $();\n    return (a, s) => (h(), C(n(tt), {\n      \"as-child\": \"\",\n      focusable: \"\"\n    }, {\n      default: m(() => [\n        k(n(D), T(t, {\n          ref: n(e),\n          onKeydown: s[0] || (s[0] = (r) => {\n            var l;\n            r.key === \" \" && ((l = r.currentTarget) == null || l.click());\n          })\n        }), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), up = /* @__PURE__ */ b({\n  __name: \"ToolbarToggleGroup\",\n  props: {\n    type: {},\n    defaultValue: {},\n    modelValue: {},\n    rovingFocus: { type: Boolean },\n    disabled: { type: Boolean },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = Ea(), r = ce(a);\n    return $(), (l, i) => (h(), C(n(Fi), T({ ...e, ...n(r) }, {\n      \"data-orientation\": n(s).orientation.value,\n      dir: n(s).dir.value,\n      \"roving-focus\": !1\n    }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"data-orientation\", \"dir\"]));\n  }\n}), dp = /* @__PURE__ */ b({\n  __name: \"ToolbarToggleItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, { forwardRef: e } = $();\n    return (a, s) => (h(), C(Ni, { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(Li), T(t, { ref: n(e) }), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), cp = /* @__PURE__ */ b({\n  __name: \"ToolbarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o) {\n    const t = o, e = Ea();\n    return $(), (a, s) => (h(), C(ca, {\n      orientation: n(e).orientation.value,\n      \"as-child\": t.asChild,\n      as: a.as\n    }, {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"as-child\", \"as\"]));\n  }\n}), Pa = \"tooltip.open\";\nfunction Hi(o, t) {\n  const e = Math.abs(t.top - o.y), a = Math.abs(t.bottom - o.y), s = Math.abs(t.right - o.x), r = Math.abs(t.left - o.x);\n  switch (Math.min(e, a, s, r)) {\n    case r:\n      return \"left\";\n    case s:\n      return \"right\";\n    case e:\n      return \"top\";\n    case a:\n      return \"bottom\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction ji(o, t, e = 5) {\n  const a = [];\n  switch (t) {\n    case \"top\":\n      a.push(\n        { x: o.x - e, y: o.y + e },\n        { x: o.x + e, y: o.y + e }\n      );\n      break;\n    case \"bottom\":\n      a.push(\n        { x: o.x - e, y: o.y - e },\n        { x: o.x + e, y: o.y - e }\n      );\n      break;\n    case \"left\":\n      a.push(\n        { x: o.x + e, y: o.y - e },\n        { x: o.x + e, y: o.y + e }\n      );\n      break;\n    case \"right\":\n      a.push(\n        { x: o.x - e, y: o.y - e },\n        { x: o.x - e, y: o.y + e }\n      );\n      break;\n  }\n  return a;\n}\nfunction Wi(o) {\n  const { top: t, right: e, bottom: a, left: s } = o;\n  return [\n    { x: s, y: t },\n    { x: e, y: t },\n    { x: e, y: a },\n    { x: s, y: a }\n  ];\n}\nfunction zi(o, t) {\n  const { x: e, y: a } = o;\n  let s = !1;\n  for (let r = 0, l = t.length - 1; r < t.length; l = r++) {\n    const i = t[r].x, u = t[r].y, d = t[l].x, p = t[l].y;\n    u > a != p > a && e < (d - i) * (a - u) / (p - u) + i && (s = !s);\n  }\n  return s;\n}\nfunction Ui(o) {\n  const t = o.slice();\n  return t.sort((e, a) => e.x < a.x ? -1 : e.x > a.x ? 1 : e.y < a.y ? -1 : e.y > a.y ? 1 : 0), qi(t);\n}\nfunction qi(o) {\n  if (o.length <= 1)\n    return o.slice();\n  const t = [];\n  for (let a = 0; a < o.length; a++) {\n    const s = o[a];\n    for (; t.length >= 2; ) {\n      const r = t[t.length - 1], l = t[t.length - 2];\n      if ((r.x - l.x) * (s.y - l.y) >= (r.y - l.y) * (s.x - l.x))\n        t.pop();\n      else\n        break;\n    }\n    t.push(s);\n  }\n  t.pop();\n  const e = [];\n  for (let a = o.length - 1; a >= 0; a--) {\n    const s = o[a];\n    for (; e.length >= 2; ) {\n      const r = e[e.length - 1], l = e[e.length - 2];\n      if ((r.x - l.x) * (s.y - l.y) >= (r.y - l.y) * (s.x - l.x))\n        e.pop();\n      else\n        break;\n    }\n    e.push(s);\n  }\n  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);\n}\nconst [Qo, Gi] = H(\"TooltipProvider\"), pp = /* @__PURE__ */ b({\n  __name: \"TooltipProvider\",\n  props: {\n    delayDuration: { default: 700 },\n    skipDelayDuration: { default: 300 },\n    disableHoverableContent: { type: Boolean, default: !1 },\n    disableClosingTrigger: { type: Boolean }\n  },\n  setup(o) {\n    const t = o, { delayDuration: e, skipDelayDuration: a, disableHoverableContent: s, disableClosingTrigger: r } = z(t);\n    $();\n    const l = P(!0), i = Tt(!1, 300), { start: u, stop: d } = ho(() => {\n      l.value = !0;\n    }, a, { immediate: !1 });\n    return Gi({\n      isOpenDelayed: l,\n      delayDuration: e,\n      onOpen() {\n        d(), l.value = !1;\n      },\n      onClose() {\n        u();\n      },\n      isPointerInTransitRef: i,\n      onPointerInTransitChange(p) {\n        i.value = p;\n      },\n      disableHoverableContent: s,\n      disableClosingTrigger: r\n    }), (p, c) => y(p.$slots, \"default\");\n  }\n}), [zt, Yi] = H(\"TooltipRoot\"), fp = /* @__PURE__ */ b({\n  __name: \"TooltipRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    delayDuration: { default: void 0 },\n    disableHoverableContent: { type: Boolean, default: void 0 },\n    disableClosingTrigger: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t;\n    $();\n    const s = Qo(), r = S(() => e.disableHoverableContent ?? s.disableHoverableContent.value), l = S(() => e.disableClosingTrigger ?? s.disableClosingTrigger.value), i = S(() => e.delayDuration ?? s.delayDuration.value), u = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    U(u, (_) => {\n      s.onClose && (_ ? (s.onOpen(), document.dispatchEvent(new CustomEvent(Pa))) : s.onClose());\n    });\n    const d = P(!1), p = P(), c = S(() => u.value ? d.value ? \"delayed-open\" : \"instant-open\" : \"closed\"), { start: f, stop: v } = ho(() => {\n      d.value = !0, u.value = !0;\n    }, i, { immediate: !1 });\n    function g() {\n      v(), d.value = !1, u.value = !0;\n    }\n    function w() {\n      v(), u.value = !1;\n    }\n    function E() {\n      f();\n    }\n    return Yi({\n      contentId: te(),\n      open: u,\n      stateAttribute: c,\n      trigger: p,\n      onTriggerChange(_) {\n        p.value = _;\n      },\n      onTriggerEnter() {\n        s.isOpenDelayed.value ? E() : g();\n      },\n      onTriggerLeave() {\n        r.value ? w() : v();\n      },\n      onOpen: g,\n      onClose: w,\n      disableHoverableContent: r,\n      disableClosingTrigger: l\n    }), (_, x) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), vp = /* @__PURE__ */ b({\n  __name: \"TooltipTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o) {\n    const t = o, e = zt(), a = Qo(), { forwardRef: s, currentElement: r } = $(), l = P(!1), i = P(!1);\n    function u() {\n      l.value = !1;\n    }\n    function d() {\n      l.value = !0, document.addEventListener(\"pointerup\", u, { once: !0 });\n    }\n    return q(() => {\n      e.onTriggerChange(r.value);\n    }), (p, c) => (h(), C(n(We), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(s),\n          \"aria-describedby\": n(e).open.value ? n(e).contentId : void 0,\n          \"data-state\": n(e).stateAttribute.value,\n          as: p.as,\n          \"as-child\": t.asChild,\n          onPointermove: c[0] || (c[0] = (f) => {\n            f.pointerType !== \"touch\" && !i.value && !n(a).isPointerInTransitRef.value && (n(e).onTriggerEnter(), i.value = !0);\n          }),\n          onPointerleave: c[1] || (c[1] = (f) => {\n            n(e).onTriggerLeave(), i.value = !1;\n          }),\n          onPointerdown: d,\n          onFocus: c[2] || (c[2] = () => {\n            l.value || n(e).onOpen();\n          }),\n          onBlur: c[3] || (c[3] = (f) => n(e).onClose()),\n          onClick: c[4] || (c[4] = () => {\n            n(e).disableClosingTrigger.value || n(e).onClose();\n          })\n        }, {\n          default: m(() => [\n            y(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"aria-describedby\", \"data-state\", \"as\", \"as-child\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Ba = /* @__PURE__ */ b({\n  __name: \"TooltipContentImpl\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: { default: 0 },\n    align: { default: \"center\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    arrowPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = zt(), { forwardRef: r } = $(), l = xn(), i = S(() => {\n      var p;\n      return (p = l.default) == null ? void 0 : p.call(l);\n    }), u = S(() => {\n      var f;\n      if (e.ariaLabel)\n        return e.ariaLabel;\n      let p = \"\";\n      function c(v) {\n        typeof v.children == \"string\" ? p += v.children : Array.isArray(v.children) && v.children.forEach((g) => c(g));\n      }\n      return (f = i.value) == null || f.forEach((v) => c(v)), p;\n    }), d = S(() => {\n      const { ariaLabel: p, ...c } = e;\n      return c;\n    });\n    return q(() => {\n      Be(window, \"scroll\", (p) => {\n        const c = p.target;\n        c != null && c.contains(s.trigger.value) && s.onClose();\n      }), Be(window, Pa, s.onClose);\n    }), (p, c) => (h(), C(n(De), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: c[0] || (c[0] = (f) => a(\"escapeKeyDown\", f)),\n      onPointerDownOutside: c[1] || (c[1] = (f) => {\n        var v;\n        n(s).disableClosingTrigger.value && ((v = n(s).trigger.value) != null && v.contains(f.target)) && f.preventDefault(), a(\"pointerDownOutside\", f);\n      }),\n      onFocusOutside: c[2] || (c[2] = oe(() => {\n      }, [\"prevent\"])),\n      onDismiss: c[3] || (c[3] = (f) => n(s).onClose())\n    }, {\n      default: m(() => [\n        k(n(Fe), T({\n          ref: n(r),\n          \"data-state\": n(s).stateAttribute.value\n        }, { ...p.$attrs, ...d.value }, { style: {\n          \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        } }), {\n          default: m(() => [\n            y(p.$slots, \"default\"),\n            k(n(Qe), {\n              id: n(s).contentId,\n              role: \"tooltip\"\n            }, {\n              default: m(() => [\n                ue(Le(u.value), 1)\n              ]),\n              _: 1\n            }, 8, [\"id\"])\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"style\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Xi = /* @__PURE__ */ b({\n  __name: \"TooltipContentHoverable\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  setup(o) {\n    const e = He(o), { forwardRef: a, currentElement: s } = $(), { trigger: r, onClose: l } = zt(), i = Qo(), u = P(null);\n    function d() {\n      u.value = null, i.onPointerInTransitChange(!1);\n    }\n    function p(c, f) {\n      const v = c.currentTarget, g = { x: c.clientX, y: c.clientY }, w = Hi(g, v.getBoundingClientRect()), E = ji(g, w), _ = Wi(f.getBoundingClientRect()), x = Ui([...E, ..._]);\n      u.value = x, i.onPointerInTransitChange(!0);\n    }\n    return ee((c) => {\n      if (r.value && s.value) {\n        const f = (g) => p(g, s.value), v = (g) => p(g, r.value);\n        r.value.addEventListener(\"pointerleave\", f), s.value.addEventListener(\"pointerleave\", v), c(() => {\n          var g, w;\n          (g = r.value) == null || g.removeEventListener(\"pointerleave\", f), (w = s.value) == null || w.removeEventListener(\"pointerleave\", v);\n        });\n      }\n    }), ee((c) => {\n      if (u.value) {\n        const f = (v) => {\n          var x, B;\n          if (!u.value)\n            return;\n          const g = v.target, w = { x: v.clientX, y: v.clientY }, E = ((x = r.value) == null ? void 0 : x.contains(g)) || ((B = s.value) == null ? void 0 : B.contains(g)), _ = !zi(w, u.value);\n          E ? d() : _ && (d(), l());\n        };\n        document.addEventListener(\"pointermove\", f), c(() => document.removeEventListener(\"pointermove\", f));\n      }\n    }), (c, f) => (h(), C(Ba, T({ ref: n(a) }, n(e)), {\n      default: m(() => [\n        y(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), mp = /* @__PURE__ */ b({\n  __name: \"TooltipContent\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o, { emit: t }) {\n    const e = o, a = t, s = zt(), r = ae(e, a), { forwardRef: l } = $();\n    return (i, u) => n(s).open.value ? (h(), C(we(n(s).disableHoverableContent.value ? Ba : Xi), T({\n      key: 0,\n      ref: n(l)\n    }, n(r)), {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", !0);\n  }\n}), hp = /* @__PURE__ */ b({\n  __name: \"TooltipArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o) {\n    const t = o;\n    return $(), (e, a) => (h(), C(n(Ze), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gp = /* @__PURE__ */ b({\n  __name: \"TooltipPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o) {\n    const t = o;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nexport {\n  au as AccordionContent,\n  su as AccordionHeader,\n  nu as AccordionItem,\n  ou as AccordionRoot,\n  ru as AccordionTrigger,\n  hu as AlertDialogAction,\n  fu as AlertDialogCancel,\n  cu as AlertDialogContent,\n  mu as AlertDialogDescription,\n  pu as AlertDialogOverlay,\n  du as AlertDialogPortal,\n  iu as AlertDialogRoot,\n  vu as AlertDialogTitle,\n  uu as AlertDialogTrigger,\n  gu as AspectRatio,\n  Cu as AvatarFallback,\n  bu as AvatarImage,\n  yu as AvatarRoot,\n  _u as CheckboxIndicator,\n  wu as CheckboxRoot,\n  Is as CollapsibleContent,\n  Ts as CollapsibleRoot,\n  Ds as CollapsibleTrigger,\n  Eu as ComboboxAnchor,\n  ku as ComboboxArrow,\n  Bu as ComboboxCancel,\n  Du as ComboboxContent,\n  Ou as ComboboxEmpty,\n  Su as ComboboxGroup,\n  xu as ComboboxInput,\n  Au as ComboboxItem,\n  Ru as ComboboxItemIndicator,\n  Tu as ComboboxLabel,\n  Vu as ComboboxPortal,\n  $u as ComboboxRoot,\n  Mu as ComboboxSeparator,\n  Pu as ComboboxTrigger,\n  Iu as ComboboxViewport,\n  eu as ConfigProvider,\n  Hu as ContextMenuArrow,\n  Uu as ContextMenuCheckboxItem,\n  Nu as ContextMenuContent,\n  Wu as ContextMenuGroup,\n  ju as ContextMenuItem,\n  qu as ContextMenuItemIndicator,\n  Gu as ContextMenuLabel,\n  Ku as ContextMenuPortal,\n  Yu as ContextMenuRadioGroup,\n  Xu as ContextMenuRadioItem,\n  Fu as ContextMenuRoot,\n  zu as ContextMenuSeparator,\n  Ju as ContextMenuSub,\n  Zu as ContextMenuSubContent,\n  Qu as ContextMenuSubTrigger,\n  Lu as ContextMenuTrigger,\n  Fn as DialogClose,\n  lr as DialogContent,\n  cr as DialogDescription,\n  ur as DialogOverlay,\n  lu as DialogPortal,\n  Fs as DialogRoot,\n  dr as DialogTitle,\n  Ls as DialogTrigger,\n  ad as DropdownMenuArrow,\n  id as DropdownMenuCheckboxItem,\n  nd as DropdownMenuContent,\n  rd as DropdownMenuGroup,\n  sd as DropdownMenuItem,\n  ud as DropdownMenuItemIndicator,\n  dd as DropdownMenuLabel,\n  od as DropdownMenuPortal,\n  cd as DropdownMenuRadioGroup,\n  pd as DropdownMenuRadioItem,\n  ed as DropdownMenuRoot,\n  ld as DropdownMenuSeparator,\n  fd as DropdownMenuSub,\n  vd as DropdownMenuSubContent,\n  md as DropdownMenuSubTrigger,\n  td as DropdownMenuTrigger,\n  Cd as HoverCardArrow,\n  bd as HoverCardContent,\n  yd as HoverCardPortal,\n  hd as HoverCardRoot,\n  gd as HoverCardTrigger,\n  wd as Label,\n  Bd as MenubarArrow,\n  Od as MenubarCheckboxItem,\n  Pd as MenubarContent,\n  Td as MenubarGroup,\n  Sd as MenubarItem,\n  Id as MenubarItemIndicator,\n  Ad as MenubarLabel,\n  $d as MenubarMenu,\n  Ed as MenubarPortal,\n  Rd as MenubarRadioGroup,\n  Md as MenubarRadioItem,\n  _d as MenubarRoot,\n  Dd as MenubarSeparator,\n  kd as MenubarSub,\n  Vd as MenubarSubContent,\n  Fd as MenubarSubTrigger,\n  xd as MenubarTrigger,\n  Nd as NavigationMenuContent,\n  Hd as NavigationMenuIndicator,\n  Kd as NavigationMenuItem,\n  jd as NavigationMenuLink,\n  Wd as NavigationMenuList,\n  Ld as NavigationMenuRoot,\n  zd as NavigationMenuSub,\n  Ud as NavigationMenuTrigger,\n  qd as NavigationMenuViewport,\n  Yd as PaginationEllipsis,\n  Xd as PaginationFirst,\n  Jd as PaginationLast,\n  Zd as PaginationList,\n  Qd as PaginationListItem,\n  ec as PaginationNext,\n  tc as PaginationPrev,\n  Gd as PaginationRoot,\n  nc as PinInputInput,\n  oc as PinInputRoot,\n  dc as PopoverAnchor,\n  ic as PopoverArrow,\n  uc as PopoverClose,\n  lc as PopoverContent,\n  rc as PopoverPortal,\n  ac as PopoverRoot,\n  sc as PopoverTrigger,\n  D as Primitive,\n  pc as ProgressIndicator,\n  cc as ProgressRoot,\n  mc as RadioGroupIndicator,\n  vc as RadioGroupItem,\n  fc as RadioGroupRoot,\n  Cc as ScrollAreaCorner,\n  hc as ScrollAreaRoot,\n  yc as ScrollAreaScrollbar,\n  bc as ScrollAreaThumb,\n  gc as ScrollAreaViewport,\n  Ec as SelectArrow,\n  xc as SelectContent,\n  Tc as SelectGroup,\n  kc as SelectIcon,\n  Bc as SelectItem,\n  Sc as SelectItemIndicator,\n  Oc as SelectItemText,\n  Dc as SelectLabel,\n  $c as SelectPortal,\n  wc as SelectRoot,\n  Rc as SelectScrollDownButton,\n  Ac as SelectScrollUpButton,\n  Pc as SelectSeparator,\n  _c as SelectTrigger,\n  Mc as SelectValue,\n  Ic as SelectViewport,\n  Vc as Separator,\n  Nc as SliderRange,\n  Fc as SliderRoot,\n  Lc as SliderThumb,\n  Kc as SliderTrack,\n  wo as Slot,\n  Hc as SwitchRoot,\n  jc as SwitchThumb,\n  Uc as TabsContent,\n  Gc as TabsIndicator,\n  zc as TabsList,\n  Wc as TabsRoot,\n  qc as TabsTrigger,\n  ep as TagsInputClear,\n  Xc as TagsInputInput,\n  Jc as TagsInputItem,\n  Qc as TagsInputItemDelete,\n  Zc as TagsInputItemText,\n  Yc as TagsInputRoot,\n  np as ToastAction,\n  Ri as ToastClose,\n  rp as ToastDescription,\n  tp as ToastProvider,\n  op as ToastRoot,\n  sp as ToastTitle,\n  ap as ToastViewport,\n  Mi as Toggle,\n  Li as ToggleGroupItem,\n  Fi as ToggleGroupRoot,\n  Ni as ToolbarButton,\n  ip as ToolbarLink,\n  lp as ToolbarRoot,\n  cp as ToolbarSeparator,\n  up as ToolbarToggleGroup,\n  dp as ToolbarToggleItem,\n  hp as TooltipArrow,\n  mp as TooltipContent,\n  gp as TooltipPortal,\n  pp as TooltipProvider,\n  fp as TooltipRoot,\n  vp as TooltipTrigger,\n  Qe as VisuallyHidden,\n  H as createContext,\n  ct as useBodyScrollLock,\n  ce as useEmitAsProps,\n  $ as useForwardExpose,\n  He as useForwardProps,\n  ae as useForwardPropsEmits,\n  te as useId,\n  On as useStateMachine,\n  tu as withDefault\n};\n",
      "start": 1709267491781,
      "end": 1709267491795,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1709267491795,
      "end": 1709267491795,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709267491795,
      "end": 1709267491796,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1709267491796,
      "end": 1709267491796,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { inject as vn, provide as mn, shallowRef as hn, watchEffect as ee, readonly as it, customRef as uo, ref as P, computed as S, watch as U, nextTick as G, getCurrentScope as Ia, onScopeDispose as Aa, effectScope as gn, unref as n, toRef as yn, onBeforeUnmount as co, getCurrentInstance as Se, onMounted as q, Fragment as le, defineComponent as b, toRefs as z, renderSlot as y, onBeforeUpdate as Ra, onUpdated as Ma, toHandlerKey as ka, camelize as bn, onUnmounted as fe, mergeProps as T, h as Ve, cloneVNode as Va, openBlock as h, createBlock as C, withCtx as m, createVNode as k, createCommentVNode as X, withKeys as ie, Teleport as Ye, normalizeProps as L, guardReactiveProps as N, normalizeStyle as re, reactive as Cn, withModifiers as oe, createElementBlock as Q, mergeDefaults as wn, createElementVNode as ut, renderList as po, markRaw as en, withDirectives as fo, vShow as _n, resolveDynamicComponent as we, createTextVNode as ue, toDisplayString as Le, isRef as dt, onBeforeMount as $n, vModelSelect as Fa, useSlots as xn, toRaw as La } from \"vue\";\nimport { useFloating as Ka, autoUpdate as Na, offset as Ha, flip as tn, shift as ja, limitShift as Wa, size as za, arrow as Ua, hide as qa } from \"@floating-ui/vue\";\nfunction H(o2, t) {\n  const e = typeof o2 == \"string\" && !t ? `${o2}Context` : t, a = Symbol(e);\n  return [(l) => {\n    const i = vn(a, l);\n    if (i || i === null)\n      return i;\n    throw new Error(\n      `Injection \\`${a.toString()}\\` not found. Component must be used within ${Array.isArray(o2) ? `one of the following components: ${o2.join(\n        \", \"\n      )}` : `\\`${o2}\\``}`\n    );\n  }, (l) => (mn(a, l), l)];\n}\nfunction vo(o2, t, e) {\n  const a = e.originalEvent.target, s = new CustomEvent(o2, {\n    bubbles: false,\n    cancelable: true,\n    detail: e\n  });\n  t && a.addEventListener(o2, t, { once: true }), a.dispatchEvent(s);\n}\nfunction Ga(o2, t) {\n  var e;\n  const a = hn();\n  return ee(() => {\n    a.value = o2();\n  }, {\n    ...t,\n    flush: (e = t == null ? void 0 : t.flush) != null ? e : \"sync\"\n  }), it(a);\n}\nfunction Ya(o2, t) {\n  let e, a, s;\n  const r = P(true), l = () => {\n    r.value = true, s();\n  };\n  U(o2, l, { flush: \"sync\" });\n  const i = typeof t == \"function\" ? t : t.get, u = typeof t == \"function\" ? void 0 : t.set, d = uo((p, c) => (a = p, s = c, {\n    get() {\n      return r.value && (e = i(), r.value = false), a(), e;\n    },\n    set(f) {\n      u == null || u(f);\n    }\n  }));\n  return Object.isExtensible(d) && (d.trigger = l), d;\n}\nfunction Ke(o2) {\n  return Ia() ? (Aa(o2), true) : false;\n}\nfunction En(o2) {\n  let t = false, e;\n  const a = gn(true);\n  return (...s) => (t || (e = a.run(() => o2(...s)), t = true), e);\n}\nfunction Xa(o2) {\n  let t = 0, e, a;\n  const s = () => {\n    t -= 1, a && t <= 0 && (a.stop(), e = void 0, a = void 0);\n  };\n  return (...r) => (t += 1, e || (a = gn(true), e = a.run(() => o2(...r))), Ke(s), e);\n}\nfunction ge(o2) {\n  return typeof o2 == \"function\" ? o2() : n(o2);\n}\nconst _e = typeof window < \"u\" && typeof document < \"u\";\ntypeof WorkerGlobalScope < \"u\" && globalThis instanceof WorkerGlobalScope;\nconst Ja = (o2) => typeof o2 < \"u\", Za = (o2) => o2 != null, Qa = Object.prototype.toString, es = (o2) => Qa.call(o2) === \"[object Object]\", on = (o2, t, e) => Math.min(e, Math.max(t, o2)), st = () => {\n}, nn = /* @__PURE__ */ ts();\nfunction ts() {\n  var o2, t;\n  return _e && ((o2 = window == null ? void 0 : window.navigator) == null ? void 0 : o2.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\nfunction os(o2, t) {\n  function e(...a) {\n    return new Promise((s, r) => {\n      Promise.resolve(o2(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(s).catch(r);\n    });\n  }\n  return e;\n}\nfunction ns(o2, t = {}) {\n  let e, a, s = st;\n  const r = (i) => {\n    clearTimeout(i), s(), s = st;\n  };\n  return (i) => {\n    const u = ge(o2), d = ge(t.maxWait);\n    return e && r(e), u <= 0 || d !== void 0 && d <= 0 ? (a && (r(a), a = null), Promise.resolve(i())) : new Promise((p, c) => {\n      s = t.rejectOnCancel ? c : p, d && !a && (a = setTimeout(() => {\n        e && r(e), a = null, p(i());\n      }, d)), e = setTimeout(() => {\n        a && r(a), a = null, p(i());\n      }, u);\n    });\n  };\n}\nfunction as(o2) {\n  return o2 || Se();\n}\nfunction ss(...o2) {\n  if (o2.length !== 1)\n    return yn(...o2);\n  const t = o2[0];\n  return typeof t == \"function\" ? it(uo(() => ({ get: t, set: st }))) : P(t);\n}\nfunction Tt(o2, t = 1e4) {\n  return uo((e, a) => {\n    let s = ge(o2), r;\n    const l = () => setTimeout(() => {\n      s = ge(o2), a();\n    }, ge(t));\n    return Ke(() => {\n      clearTimeout(r);\n    }), {\n      get() {\n        return e(), s;\n      },\n      set(i) {\n        s = i, a(), clearTimeout(r), r = l();\n      }\n    };\n  });\n}\nfunction mo(o2, t = 200, e = {}) {\n  return os(\n    ns(t, e),\n    o2\n  );\n}\nfunction rs(o2, t) {\n  as(t) && co(o2, t);\n}\nfunction ho(o2, t, e = {}) {\n  const {\n    immediate: a = true\n  } = e, s = P(false);\n  let r = null;\n  function l() {\n    r && (clearTimeout(r), r = null);\n  }\n  function i() {\n    s.value = false, l();\n  }\n  function u(...d) {\n    l(), s.value = true, r = setTimeout(() => {\n      s.value = false, r = null, o2(...d);\n    }, ge(t));\n  }\n  return a && (s.value = true, _e && u()), Ke(i), {\n    isPending: it(s),\n    start: u,\n    stop: i\n  };\n}\nfunction ls(o2 = 1e3, t = {}) {\n  const {\n    controls: e = false,\n    callback: a\n  } = t, s = ho(\n    a ?? st,\n    o2,\n    t\n  ), r = S(() => !s.isPending.value);\n  return e ? {\n    ready: r,\n    ...s\n  } : r;\n}\nfunction is(o2, t, e) {\n  const a = U(o2, (...s) => (G(() => a()), t(...s)), e);\n  return a;\n}\nfunction pe(o2) {\n  var t;\n  const e = ge(o2);\n  return (t = e == null ? void 0 : e.$el) != null ? t : e;\n}\nconst Xe = _e ? window : void 0;\nfunction Be(...o2) {\n  let t, e, a, s;\n  if (typeof o2[0] == \"string\" || Array.isArray(o2[0]) ? ([e, a, s] = o2, t = Xe) : [t, e, a, s] = o2, !t)\n    return st;\n  Array.isArray(e) || (e = [e]), Array.isArray(a) || (a = [a]);\n  const r = [], l = () => {\n    r.forEach((p) => p()), r.length = 0;\n  }, i = (p, c, f, v) => (p.addEventListener(c, f, v), () => p.removeEventListener(c, f, v)), u = U(\n    () => [pe(t), ge(s)],\n    ([p, c]) => {\n      if (l(), !p)\n        return;\n      const f = es(c) ? { ...c } : c;\n      r.push(\n        ...e.flatMap((v) => a.map((g) => i(p, v, g, f)))\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  ), d = () => {\n    u(), l();\n  };\n  return Ke(d), d;\n}\nfunction us(o2) {\n  return typeof o2 == \"function\" ? o2 : typeof o2 == \"string\" ? (t) => t.key === o2 : Array.isArray(o2) ? (t) => o2.includes(t.key) : () => true;\n}\nfunction go(...o2) {\n  let t, e, a = {};\n  o2.length === 3 ? (t = o2[0], e = o2[1], a = o2[2]) : o2.length === 2 ? typeof o2[1] == \"object\" ? (t = true, e = o2[0], a = o2[1]) : (t = o2[0], e = o2[1]) : (t = true, e = o2[0]);\n  const {\n    target: s = Xe,\n    eventName: r = \"keydown\",\n    passive: l = false,\n    dedupe: i = false\n  } = a, u = us(t);\n  return Be(s, r, (p) => {\n    p.repeat && ge(i) || u(p) && e(p);\n  }, l);\n}\nfunction ds(o2 = {}) {\n  var t;\n  const {\n    window: e = Xe,\n    deep: a = true\n  } = o2, s = (t = o2.document) != null ? t : e == null ? void 0 : e.document, r = () => {\n    var i;\n    let u = s == null ? void 0 : s.activeElement;\n    if (a)\n      for (; u != null && u.shadowRoot; )\n        u = (i = u == null ? void 0 : u.shadowRoot) == null ? void 0 : i.activeElement;\n    return u;\n  }, l = Ya(\n    () => null,\n    () => r()\n  );\n  return e && (Be(e, \"blur\", (i) => {\n    i.relatedTarget === null && l.trigger();\n  }, true), Be(e, \"focus\", l.trigger, true)), l;\n}\nfunction Dt() {\n  const o2 = P(false), t = Se();\n  return t && q(() => {\n    o2.value = true;\n  }, t), o2;\n}\nfunction Pn(o2) {\n  const t = Dt();\n  return S(() => (t.value, !!o2()));\n}\nfunction cs(o2, t = {}) {\n  const {\n    immediate: e = true,\n    fpsLimit: a = void 0,\n    window: s = Xe\n  } = t, r = P(false), l = a ? 1e3 / a : null;\n  let i = 0, u = null;\n  function d(f) {\n    if (!r.value || !s)\n      return;\n    i || (i = f);\n    const v = f - i;\n    if (l && v < l) {\n      u = s.requestAnimationFrame(d);\n      return;\n    }\n    i = f, o2({ delta: v, timestamp: f }), u = s.requestAnimationFrame(d);\n  }\n  function p() {\n    !r.value && s && (r.value = true, i = 0, u = s.requestAnimationFrame(d));\n  }\n  function c() {\n    r.value = false, u != null && s && (s.cancelAnimationFrame(u), u = null);\n  }\n  return e && p(), Ke(c), {\n    isActive: it(r),\n    pause: c,\n    resume: p\n  };\n}\nfunction ps(o2) {\n  return JSON.parse(JSON.stringify(o2));\n}\nfunction fs(o2, t, e = {}) {\n  const { window: a = Xe, ...s } = e;\n  let r;\n  const l = Pn(() => a && \"MutationObserver\" in a), i = () => {\n    r && (r.disconnect(), r = void 0);\n  }, u = S(() => {\n    const f = ge(o2), v = (Array.isArray(f) ? f : [f]).map(pe).filter(Za);\n    return new Set(v);\n  }), d = U(\n    () => u.value,\n    (f) => {\n      i(), l.value && a && f.size && (r = new MutationObserver(t), f.forEach((v) => r.observe(v, s)));\n    },\n    { immediate: true, flush: \"post\" }\n  ), p = () => r == null ? void 0 : r.takeRecords(), c = () => {\n    i(), d();\n  };\n  return Ke(c), {\n    isSupported: l,\n    stop: c,\n    takeRecords: p\n  };\n}\nfunction be(o2, t, e = {}) {\n  const { window: a = Xe, ...s } = e;\n  let r;\n  const l = Pn(() => a && \"ResizeObserver\" in a), i = () => {\n    r && (r.disconnect(), r = void 0);\n  }, u = S(() => Array.isArray(o2) ? o2.map((c) => pe(c)) : [pe(o2)]), d = U(\n    u,\n    (c) => {\n      if (i(), l.value && a) {\n        r = new ResizeObserver(t);\n        for (const f of c)\n          f && r.observe(f, s);\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  ), p = () => {\n    i(), d();\n  };\n  return Ke(p), {\n    isSupported: l,\n    stop: p\n  };\n}\nfunction vs(o2, t = {}) {\n  const e = ds(t), a = S(() => pe(o2));\n  return { focused: S(() => a.value && e.value ? a.value.contains(e.value) : false) };\n}\nfunction ms(o2, t) {\n  const e = hn(t);\n  return U(\n    ss(o2),\n    (a, s) => {\n      e.value = s;\n    },\n    { flush: \"sync\" }\n  ), it(e);\n}\nfunction Y(o2, t, e, a = {}) {\n  var s, r, l;\n  const {\n    clone: i = false,\n    passive: u = false,\n    eventName: d,\n    deep: p = false,\n    defaultValue: c,\n    shouldEmit: f\n  } = a, v = Se(), g = e || (v == null ? void 0 : v.emit) || ((s = v == null ? void 0 : v.$emit) == null ? void 0 : s.bind(v)) || ((l = (r = v == null ? void 0 : v.proxy) == null ? void 0 : r.$emit) == null ? void 0 : l.bind(v == null ? void 0 : v.proxy));\n  let w = d;\n  t || (t = \"modelValue\"), w = w || `update:${t.toString()}`;\n  const E = (B) => i ? typeof i == \"function\" ? i(B) : ps(B) : B, _ = () => Ja(o2[t]) ? E(o2[t]) : c, x = (B) => {\n    f ? f(B) && g(w, B) : g(w, B);\n  };\n  if (u) {\n    const B = _(), O = P(B);\n    let A = false;\n    return U(\n      () => o2[t],\n      (M) => {\n        A || (A = true, O.value = E(M), G(() => A = false));\n      }\n    ), U(\n      O,\n      (M) => {\n        !A && (M !== o2[t] || p) && x(M);\n      },\n      { deep: p }\n    ), O;\n  } else\n    return S({\n      get() {\n        return _();\n      },\n      set(B) {\n        x(B);\n      }\n    });\n}\nfunction Ot(o2) {\n  return o2 ? o2.flatMap((t) => t.type === le ? Ot(t.children) : [t]) : [];\n}\nconst hs = [\"INPUT\", \"TEXTAREA\"];\nfunction Je(o2, t, e, a = {}) {\n  if (!t || a.enableIgnoredElement && hs.includes(t.nodeName))\n    return null;\n  const {\n    arrowKeyOptions: s = \"both\",\n    attributeName: r = \"[data-radix-vue-collection-item]\",\n    itemsArray: l = [],\n    loop: i = true,\n    dir: u = \"ltr\",\n    preventScroll: d = true,\n    focus: p = false\n  } = a, [c, f, v, g, w, E] = [\n    o2.key === \"ArrowRight\",\n    o2.key === \"ArrowLeft\",\n    o2.key === \"ArrowUp\",\n    o2.key === \"ArrowDown\",\n    o2.key === \"Home\",\n    o2.key === \"End\"\n  ], _ = v || g, x = c || f;\n  if (!w && !E && (!_ && !x || s === \"vertical\" && x || s === \"horizontal\" && _))\n    return null;\n  const B = e ? Array.from(e.querySelectorAll(r)) : l;\n  if (!B.length)\n    return null;\n  d && o2.preventDefault();\n  let O = null;\n  return x || _ ? O = Bn(B, t, {\n    goForward: _ ? g : u === \"ltr\" ? c : f,\n    loop: i\n  }) : w ? O = B.at(0) || null : E && (O = B.at(-1) || null), p && (O == null || O.focus()), O;\n}\nfunction Bn(o2, t, { goForward: e, loop: a }, s = o2.length) {\n  if (--s === 0)\n    return null;\n  const r = o2.indexOf(t), l = e ? r + 1 : r - 1;\n  if (!a && (l < 0 || l >= o2.length))\n    return null;\n  const i = (l + o2.length) % o2.length, u = o2[i];\n  return u ? u.hasAttribute(\"disabled\") && u.getAttribute(\"disabled\") !== \"false\" ? Bn(\n    o2,\n    u,\n    { goForward: e, loop: a },\n    s\n  ) : u : null;\n}\nfunction Jt(o2) {\n  if (o2 === null || typeof o2 != \"object\")\n    return false;\n  const t = Object.getPrototypeOf(o2);\n  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in o2 ? false : Symbol.toStringTag in o2 ? Object.prototype.toString.call(o2) === \"[object Module]\" : true;\n}\nfunction oo(o2, t, e = \".\", a) {\n  if (!Jt(t))\n    return oo(o2, {}, e, a);\n  const s = Object.assign({}, t);\n  for (const r in o2) {\n    if (r === \"__proto__\" || r === \"constructor\")\n      continue;\n    const l = o2[r];\n    l != null && (a && a(s, r, l, e) || (Array.isArray(l) && Array.isArray(s[r]) ? s[r] = [...l, ...s[r]] : Jt(l) && Jt(s[r]) ? s[r] = oo(\n      l,\n      s[r],\n      (e ? `${e}.` : \"\") + r.toString(),\n      a\n    ) : s[r] = l));\n  }\n  return s;\n}\nfunction gs(o2) {\n  return (...t) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    t.reduce((e, a) => oo(e, a, \"\", o2), {})\n  );\n}\nconst ys = gs(), [Sn, bs] = H(\"ConfigProvider\"), eu = /* @__PURE__ */ b({\n  __name: \"ConfigProvider\",\n  props: {\n    dir: { default: \"ltr\" },\n    scrollBody: { type: [Boolean, Object], default: true }\n  },\n  setup(o2) {\n    const t = o2, { dir: e, scrollBody: a } = z(t);\n    return bs({\n      dir: e,\n      scrollBody: a\n    }), (s, r) => y(s.$slots, \"default\");\n  }\n}), Cs = En(() => ({ count: P(0) }));\nfunction te(o2) {\n  const { count: t } = Cs();\n  return o2 || t.value++, o2 || `radix-${t.value}`;\n}\nconst ws = Xa(() => {\n  const o2 = P(/* @__PURE__ */ new Map()), t = P(), e = S(() => {\n    for (const l of o2.value.values())\n      if (l)\n        return true;\n    return false;\n  }), a = Sn({\n    scrollBody: P(true)\n  });\n  let s = null;\n  const r = () => {\n    document.body.style.paddingRight = \"\", document.body.style.marginRight = \"\", document.body.style.pointerEvents = \"\", document.body.style.removeProperty(\"--scrollbar-width\"), document.body.style.overflow = t.value ?? \"\", nn && (s == null || s()), t.value = void 0;\n  };\n  return U(e, (l, i) => {\n    var c;\n    if (!_e)\n      return;\n    if (!l) {\n      i && r();\n      return;\n    }\n    t.value === void 0 && (t.value = document.body.style.overflow);\n    const u = window.innerWidth - document.documentElement.clientWidth, d = { padding: u, margin: 0 }, p = (c = a.scrollBody) != null && c.value ? typeof a.scrollBody.value == \"object\" ? ys({\n      padding: a.scrollBody.value.padding === true ? u : a.scrollBody.value.padding,\n      margin: a.scrollBody.value.margin === true ? u : a.scrollBody.value.margin\n    }, d) : d : { padding: 0, margin: 0 };\n    u > 0 && (document.body.style.paddingRight = `${p.padding}px`, document.body.style.marginRight = `${p.margin}px`, document.body.style.setProperty(\"--scrollbar-width\", `${u}px`), document.body.style.overflow = \"hidden\"), nn && (s = Be(\n      document,\n      \"touchmove\",\n      (f) => {\n        var v;\n        f.target === document.documentElement && (f.touches.length > 1 || (v = f.preventDefault) == null || v.call(f));\n      },\n      { passive: false }\n    )), G(() => {\n      document.body.style.pointerEvents = \"none\", document.body.style.overflow = \"hidden\";\n    });\n  }, { immediate: true, flush: \"sync\" }), o2;\n});\nfunction ct(o2) {\n  const t = te(), e = ws();\n  e.value.set(t, o2 ?? false);\n  const a = S({\n    get: () => e.value.get(t) ?? false,\n    set: (s) => e.value.set(t, s)\n  });\n  return rs(() => {\n    e.value.delete(t);\n  }), a;\n}\nconst _s = \"data-radix-vue-collection-item\";\nfunction ve(o2, t = _s) {\n  const e = o2 ?? Symbol();\n  return { createCollection: (r) => {\n    const l = P([]);\n    function i() {\n      const u = pe(r);\n      return u ? l.value = Array.from(\n        u.querySelectorAll(`[${t}]:not([data-disabled])`)\n      ) : l.value = [];\n    }\n    return Ra(() => {\n      l.value = [];\n    }), q(i), Ma(i), U(() => r == null ? void 0 : r.value, i, { immediate: true }), mn(e, l), l;\n  }, injectCollection: () => vn(e, P([])) };\n}\nfunction de(o2) {\n  const t = Sn({\n    dir: P(\"ltr\")\n  });\n  return S(() => {\n    var e;\n    return (o2 == null ? void 0 : o2.value) || ((e = t.dir) == null ? void 0 : e.value) || \"ltr\";\n  });\n}\nfunction ce(o2) {\n  const t = Se(), e = t == null ? void 0 : t.type.emits, a = {};\n  return e != null && e.length || console.warn(\n    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`\n  ), e == null || e.forEach((s) => {\n    a[ka(bn(s))] = (...r) => o2(s, ...r);\n  }), a;\n}\nlet Zt = 0;\nfunction yo() {\n  ee((o2) => {\n    if (!_e)\n      return;\n    const t = document.querySelectorAll(\"[data-radix-focus-guard]\");\n    document.body.insertAdjacentElement(\n      \"afterbegin\",\n      t[0] ?? an()\n    ), document.body.insertAdjacentElement(\n      \"beforeend\",\n      t[1] ?? an()\n    ), Zt++, o2(() => {\n      Zt === 1 && document.querySelectorAll(\"[data-radix-focus-guard]\").forEach((e) => e.remove()), Zt--;\n    });\n  });\n}\nfunction an() {\n  const o2 = document.createElement(\"span\");\n  return o2.setAttribute(\"data-radix-focus-guard\", \"\"), o2.tabIndex = 0, o2.style.cssText = \"outline: none; opacity: 0; position: fixed; pointer-events: none\", o2;\n}\nfunction Ne(o2) {\n  return S(() => {\n    var t;\n    return ge(o2) ? !!((t = pe(o2)) != null && t.closest(\"form\")) : true;\n  });\n}\nfunction He(o2) {\n  const t = Se(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((s, r) => {\n    const l = (t == null ? void 0 : t.type.props[r]).default;\n    return l !== void 0 && (s[r] = l), s;\n  }, {}), a = yn(o2);\n  return S(() => {\n    const s = {}, r = (t == null ? void 0 : t.vnode.props) ?? {};\n    return Object.keys(r).forEach((l) => {\n      s[bn(l)] = r[l];\n    }), Object.keys({ ...e, ...s }).reduce((l, i) => (a.value[i] !== void 0 && (l[i] = a.value[i]), l), {});\n  });\n}\nfunction ae(o2, t) {\n  const e = He(o2), a = t ? ce(t) : {};\n  return S(() => ({\n    ...e.value,\n    ...a\n  }));\n}\nfunction $() {\n  const o2 = Se(), t = P(), e = S(() => {\n    var l, i;\n    return [\"#text\", \"#comment\"].includes((l = t.value) == null ? void 0 : l.$el.nodeName) ? (i = t.value) == null ? void 0 : i.$el.nextElementSibling : pe(t);\n  }), a = Object.assign({}, o2.exposed), s = {};\n  for (const l in o2.props)\n    Object.defineProperty(s, l, {\n      enumerable: true,\n      configurable: true,\n      get: () => o2.props[l]\n    });\n  if (Object.keys(a).length > 0)\n    for (const l in a)\n      Object.defineProperty(s, l, {\n        enumerable: true,\n        configurable: true,\n        get: () => a[l]\n      });\n  Object.defineProperty(s, \"$el\", {\n    enumerable: true,\n    configurable: true,\n    get: () => o2.vnode.el\n  }), o2.exposed = s;\n  function r(l) {\n    t.value = l, !(l instanceof Element || !l) && (Object.defineProperty(s, \"$el\", {\n      enumerable: true,\n      configurable: true,\n      get: () => l.$el\n    }), o2.exposed = s);\n  }\n  return { forwardRef: r, currentRef: t, currentElement: e };\n}\nvar $s = function(o2) {\n  if (typeof document > \"u\")\n    return null;\n  var t = Array.isArray(o2) ? o2[0] : o2;\n  return t.ownerDocument.body;\n}, qe = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), bt = {}, Qt = 0, Tn = function(o2) {\n  return o2 && (o2.host || Tn(o2.parentNode));\n}, xs = function(o2, t) {\n  return t.map(function(e) {\n    if (o2.contains(e))\n      return e;\n    var a = Tn(e);\n    return a && o2.contains(a) ? a : (console.error(\"aria-hidden\", e, \"in not contained inside\", o2, \". Doing nothing\"), null);\n  }).filter(function(e) {\n    return !!e;\n  });\n}, Es = function(o2, t, e, a) {\n  var s = xs(t, Array.isArray(o2) ? o2 : [o2]);\n  bt[e] || (bt[e] = /* @__PURE__ */ new WeakMap());\n  var r = bt[e], l = [], i = /* @__PURE__ */ new Set(), u = new Set(s), d = function(c) {\n    !c || i.has(c) || (i.add(c), d(c.parentNode));\n  };\n  s.forEach(d);\n  var p = function(c) {\n    !c || u.has(c) || Array.prototype.forEach.call(c.children, function(f) {\n      if (i.has(f))\n        p(f);\n      else {\n        var v = f.getAttribute(a), g = v !== null && v !== \"false\", w = (qe.get(f) || 0) + 1, E = (r.get(f) || 0) + 1;\n        qe.set(f, w), r.set(f, E), l.push(f), w === 1 && g && yt.set(f, true), E === 1 && f.setAttribute(e, \"true\"), g || f.setAttribute(a, \"true\");\n      }\n    });\n  };\n  return p(t), i.clear(), Qt++, function() {\n    l.forEach(function(c) {\n      var f = qe.get(c) - 1, v = r.get(c) - 1;\n      qe.set(c, f), r.set(c, v), f || (yt.has(c) || c.removeAttribute(a), yt.delete(c)), v || c.removeAttribute(e);\n    }), Qt--, Qt || (qe = /* @__PURE__ */ new WeakMap(), qe = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), bt = {});\n  };\n}, Ps = function(o2, t, e) {\n  e === void 0 && (e = \"data-aria-hidden\");\n  var a = Array.from(Array.isArray(o2) ? o2 : [o2]), s = t || $s(o2);\n  return s ? (a.push.apply(a, Array.from(s.querySelectorAll(\"[aria-live]\"))), Es(a, s, e, \"aria-hidden\")) : function() {\n    return null;\n  };\n};\nfunction pt(o2) {\n  let t;\n  U(() => pe(o2), (e) => {\n    e ? t = Ps(e) : t && t();\n  }), fe(() => {\n    t && t();\n  });\n}\nfunction Dn(o2) {\n  const t = P(), e = S(() => {\n    var s;\n    return ((s = t.value) == null ? void 0 : s.width) ?? 0;\n  }), a = S(() => {\n    var s;\n    return ((s = t.value) == null ? void 0 : s.height) ?? 0;\n  });\n  return q(() => {\n    const s = pe(o2);\n    if (s) {\n      t.value = { width: s.offsetWidth, height: s.offsetHeight };\n      const r = new ResizeObserver((l) => {\n        if (!Array.isArray(l) || !l.length)\n          return;\n        const i = l[0];\n        let u, d;\n        if (\"borderBoxSize\" in i) {\n          const p = i.borderBoxSize, c = Array.isArray(p) ? p[0] : p;\n          u = c.inlineSize, d = c.blockSize;\n        } else\n          u = s.offsetWidth, d = s.offsetHeight;\n        t.value = { width: u, height: d };\n      });\n      return r.observe(s, { box: \"border-box\" }), () => r.unobserve(s);\n    } else\n      t.value = void 0;\n  }), {\n    width: e,\n    height: a\n  };\n}\nfunction On(o2, t) {\n  const e = P(o2);\n  function a(r) {\n    return t[e.value][r] ?? e.value;\n  }\n  return {\n    state: e,\n    dispatch: (r) => {\n      e.value = a(r);\n    }\n  };\n}\nfunction bo(o2) {\n  const t = Tt(\"\", 1e3);\n  return {\n    search: t,\n    handleTypeaheadSearch: (s) => {\n      var c, f;\n      t.value = t.value + s;\n      const r = o2.value, l = document.activeElement, i = ((f = (c = r.find((v) => v === l)) == null ? void 0 : c.textContent) == null ? void 0 : f.trim()) ?? \"\", u = r.map((v) => {\n        var g;\n        return ((g = v.textContent) == null ? void 0 : g.trim()) ?? \"\";\n      }), d = Bs(u, t.value, i), p = r.find(\n        (v) => {\n          var g;\n          return ((g = v.textContent) == null ? void 0 : g.trim()) === d;\n        }\n      );\n      p && p.focus();\n    },\n    resetTypeahead: () => {\n      t.value = \"\";\n    }\n  };\n}\nfunction Co(o2, t) {\n  return o2.map((e, a) => o2[(t + a) % o2.length]);\n}\nfunction Bs(o2, t, e) {\n  const s = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, r = e ? o2.indexOf(e) : -1;\n  let l = Co(o2, Math.max(r, 0));\n  s.length === 1 && (l = l.filter((d) => d !== e));\n  const u = l.find(\n    (d) => d.toLowerCase().startsWith(s.toLowerCase())\n  );\n  return u !== e ? u : void 0;\n}\nfunction tu(o2, t) {\n  return {\n    inheritAttrs: false,\n    name: `${o2.__name ?? \"\"}Wrapper`,\n    setup(e, a) {\n      return () => {\n        const s = typeof (t == null ? void 0 : t.props) == \"function\" ? t == null ? void 0 : t.props(a.attrs) : t == null ? void 0 : t.props, { forwardRef: r } = $(), l = T(s, a.attrs);\n        return Ve(o2, { ...l, ref: r }, a.slots);\n      };\n    }\n  };\n}\nconst wo = b({\n  name: \"PrimitiveSlot\",\n  inheritAttrs: false,\n  setup(o2, { attrs: t, slots: e }) {\n    return () => {\n      var l, i;\n      if (!e.default)\n        return null;\n      const a = Ot(e.default()), [s, ...r] = a;\n      if (Object.keys(t).length > 0) {\n        (l = s.props) == null || delete l.ref;\n        const u = T(t, s.props ?? {});\n        t.class && ((i = s.props) != null && i.class) && delete s.props.class;\n        const d = Va(s, u);\n        for (const p in u)\n          p.startsWith(\"on\") && (d.props || (d.props = {}), d.props[p] = u[p]);\n        return a.length === 1 ? d : [d, ...r];\n      }\n      return a;\n    };\n  }\n}), D = b({\n  name: \"Primitive\",\n  inheritAttrs: false,\n  props: {\n    asChild: {\n      type: Boolean,\n      default: false\n    },\n    as: {\n      type: [String, Object],\n      default: \"div\"\n    }\n  },\n  setup(o2, { attrs: t, slots: e }) {\n    return (o2.asChild ? \"template\" : o2.as) !== \"template\" ? () => Ve(o2.as, t, { default: e.default }) : () => Ve(wo, t, { default: e.default });\n  }\n});\nfunction In() {\n  const o2 = P(), t = S(() => {\n    var e, a;\n    return [\"#text\", \"#comment\"].includes((e = o2.value) == null ? void 0 : e.$el.nodeName) ? (a = o2.value) == null ? void 0 : a.$el.nextElementSibling : pe(o2);\n  });\n  return {\n    primitiveElement: o2,\n    currentElement: t\n  };\n}\nconst [An, Ss] = H(\"CollapsibleRoot\"), Ts = /* @__PURE__ */ b({\n  __name: \"CollapsibleRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: false },\n    open: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:open\"],\n  setup(o2, { expose: t, emit: e }) {\n    const a = o2, r = Y(a, \"open\", e, {\n      defaultValue: a.defaultOpen,\n      passive: a.open === void 0\n    }), l = Y(a, \"disabled\");\n    return Ss({\n      contentId: te(),\n      disabled: l,\n      open: r,\n      onOpenToggle: () => {\n        r.value = !r.value;\n      }\n    }), t({ open: r }), $(), (i, u) => (h(), C(n(D), {\n      as: i.as,\n      \"as-child\": a.asChild,\n      \"data-state\": a.open ? \"open\" : \"closed\",\n      \"data-disabled\": a.disabled ? \"\" : void 0\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\", { open: n(r) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"]));\n  }\n}), Ds = /* @__PURE__ */ b({\n  __name: \"CollapsibleTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = An();\n    return (a, s) => {\n      var r, l;\n      return h(), C(n(D), {\n        type: a.as === \"button\" ? \"button\" : void 0,\n        as: a.as,\n        \"as-child\": t.asChild,\n        \"aria-controls\": n(e).contentId,\n        \"aria-expanded\": n(e).open.value,\n        \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": (r = n(e).disabled) != null && r.value ? \"\" : void 0,\n        disabled: (l = n(e).disabled) == null ? void 0 : l.value,\n        onClick: n(e).onOpenToggle\n      }, {\n        default: m(() => [\n          y(a.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"type\", \"as\", \"as-child\", \"aria-controls\", \"aria-expanded\", \"data-state\", \"data-disabled\", \"disabled\", \"onClick\"]);\n    };\n  }\n});\nfunction Os(o2, t) {\n  const e = P({}), a = P(\"none\"), s = o2.value ? \"mounted\" : \"unmounted\", { state: r, dispatch: l } = On(s, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  });\n  U(\n    o2,\n    async (f, v) => {\n      var w;\n      const g = v !== f;\n      if (await G(), g) {\n        const E = a.value, _ = Ct(t.value);\n        f ? l(\"MOUNT\") : _ === \"none\" || ((w = e.value) == null ? void 0 : w.display) === \"none\" ? l(\"UNMOUNT\") : l(v && E !== _ ? \"ANIMATION_OUT\" : \"UNMOUNT\");\n      }\n    },\n    { immediate: true }\n  );\n  const i = (f) => {\n    const v = Ct(t.value), g = v.includes(\n      f.animationName\n    );\n    f.target === t.value && g && l(\"ANIMATION_END\"), f.target === t.value && v === \"none\" && l(\"ANIMATION_END\");\n  }, u = (f) => {\n    f.target === t.value && (a.value = Ct(t.value));\n  }, d = U(\n    t,\n    (f, v) => {\n      f ? (e.value = getComputedStyle(f), f.addEventListener(\"animationstart\", u), f.addEventListener(\"animationcancel\", i), f.addEventListener(\"animationend\", i)) : (l(\"ANIMATION_END\"), v == null || v.removeEventListener(\"animationstart\", u), v == null || v.removeEventListener(\"animationcancel\", i), v == null || v.removeEventListener(\"animationend\", i));\n    },\n    { immediate: true }\n  ), p = U(r, () => {\n    const f = Ct(t.value);\n    a.value = r.value === \"mounted\" ? f : \"none\";\n  });\n  return fe(() => {\n    d(), p();\n  }), {\n    isPresent: S(\n      () => [\"mounted\", \"unmountSuspended\"].includes(r.value)\n    )\n  };\n}\nfunction Ct(o2) {\n  return o2 && getComputedStyle(o2).animationName || \"none\";\n}\nconst se = b({\n  name: \"Presence\",\n  props: {\n    present: {\n      type: Boolean,\n      required: true\n    },\n    forceMount: {\n      type: Boolean\n    }\n  },\n  slots: {},\n  setup(o2, { slots: t, expose: e }) {\n    var d;\n    const { present: a, forceMount: s } = z(o2), r = P(), { isPresent: l } = Os(a, r);\n    e({ present: l });\n    let i = t.default({ present: l });\n    i = Ot(i || []);\n    const u = Se();\n    if (i && (i == null ? void 0 : i.length) > 1) {\n      const p = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : \"component\";\n      throw new Error(\n        [\n          `Detected an invalid children for \\`${p}\\` for  \\`Presence\\` component.`,\n          \"\",\n          \"Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.\",\n          \"You can apply a few solutions:\",\n          [\n            \"Provide a single child element so that `presence` directive attach correctly.\",\n            \"Ensure the first child is an actual element instead of a raw text node or comment node.\"\n          ].map((c) => `  - ${c}`).join(`\n`)\n        ].join(`\n`)\n      );\n    }\n    return () => s.value || a.value || l.value ? Ve(t.default({ present: l })[0], {\n      ref: (p) => {\n        const c = pe(p);\n        return typeof (c == null ? void 0 : c.hasAttribute) > \"u\" || (c != null && c.hasAttribute(\"data-radix-popper-content-wrapper\") ? r.value = c.firstElementChild : r.value = c), c;\n      }\n    }) : null;\n  }\n}), Is = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"CollapsibleContent\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = An(), a = P(), { forwardRef: s, currentElement: r } = $(), l = P(0), i = P(0), u = S(() => e.open.value), d = P(u.value), p = P();\n    return U(\n      () => {\n        var c;\n        return [u.value, (c = a.value) == null ? void 0 : c.present];\n      },\n      async () => {\n        await G();\n        const c = r.value;\n        if (!c)\n          return;\n        p.value = p.value || {\n          transitionDuration: c.style.transitionDuration,\n          animationName: c.style.animationName\n        }, c.style.transitionDuration = \"0s\", c.style.animationName = \"none\";\n        const f = c.getBoundingClientRect();\n        i.value = f.height, l.value = f.width, d.value || (c.style.transitionDuration = p.value.transitionDuration, c.style.animationName = p.value.animationName);\n      },\n      {\n        immediate: true\n      }\n    ), q(() => {\n      requestAnimationFrame(() => {\n        d.value = false;\n      });\n    }), (c, f) => (h(), C(n(se), {\n      ref_key: \"presentRef\",\n      ref: a,\n      present: c.forceMount || n(e).open.value,\n      \"force-mount\": true\n    }, {\n      default: m(() => {\n        var v, g;\n        return [\n          k(n(D), T(c.$attrs, {\n            id: n(e).contentId,\n            ref: n(s),\n            \"as-child\": t.asChild,\n            as: c.as,\n            \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n            \"data-disabled\": (v = n(e).disabled) != null && v.value ? \"\" : void 0,\n            hidden: !((g = a.value) != null && g.present),\n            style: {\n              \"--radix-collapsible-content-height\": `${i.value}px`,\n              \"--radix-collapsible-content-width\": `${l.value}px`\n            }\n          }), {\n            default: m(() => {\n              var w;\n              return [\n                (w = a.value) != null && w.present ? y(c.$slots, \"default\", { key: 0 }) : X(\"\", true)\n              ];\n            }),\n            _: 3\n          }, 16, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-disabled\", \"hidden\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction As(o2, t) {\n  if (o2 === \"single\") {\n    if (Array.isArray(t)) {\n      console.error(`Invalid prop \\`value\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`single\\`. The \\`value\\` prop must be:\n  - a string\n  - \\`undefined\\`\n\nIf you want to use multiple values, use the \\`AccordionRoot\\` with type \\`multiple\\`.\n\nDefaulting to \\`undefined\\`.`);\n      return;\n    }\n  } else if (o2 === \"multiple\" && (typeof t == \"string\" || typeof t > \"u\"))\n    return console.error(`Invalid prop \\`value\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`multiple\\`. The \\`value\\` prop must be:\n- an array of strings\n- empty array (\\`[]\\`)\n\nIf you want to use just one value, use the \\`AccordionRoot\\` with type \\`single\\`.\n\nDefaulting to empty array (\\`[]\\`).`), [];\n  return t;\n}\nfunction Rs({ type: o2, defaultValue: t }) {\n  if (o2 === \"multiple\")\n    return Array.isArray(t) ? t : t === void 0 ? [] : (console.error(\n      `Invalid prop \\`defaultValue\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`multiple\\`. The \\`defaultValue\\` prop must be:\n  - an array of strings\n  - empty array (\\`[]\\`)\n\nIf you want to use just one value, use the \\`AccordionRoot\\` with type \\`single\\`.\n\nDefaulting to empty array (\\`[]\\`).`\n    ), []);\n  if (o2 === \"single\") {\n    if (typeof t == \"string\")\n      return t;\n    if (t === void 0)\n      return;\n    console.error(\n      `Invalid prop \\`defaultValue\\` of value \\`${t}\\` supplied to \\`AccordionRoot\\`, which type is \\`single\\`. The \\`defaultValue\\` prop must be:\n  - a string\n  - \\`undefined\\`\n\nDefaulting to \\`undefined\\`.`\n    );\n    return;\n  }\n}\nfunction Rn(o2, t) {\n  const e = Y(o2, \"modelValue\", t, {\n    defaultValue: Rs(o2),\n    passive: o2.modelValue === void 0\n  });\n  U(\n    () => [o2.type, o2.modelValue],\n    () => {\n      const s = As(o2.type, e.value);\n      e.value !== s && (e.value = s);\n    },\n    { immediate: true }\n  );\n  function a(s) {\n    if (o2.type === \"single\")\n      e.value = s === e.value ? void 0 : s;\n    else {\n      const r = e.value || [];\n      if (r.includes(s)) {\n        const l = r.findIndex((i) => i === s);\n        r.splice(l, 1);\n      } else\n        r.push(s);\n      e.value = r, t(\"update:modelValue\", e.value);\n    }\n  }\n  return {\n    modelValue: e,\n    changeModelValue: a\n  };\n}\nconst [It, Ms] = H(\"AccordionRoot\"), ou = /* @__PURE__ */ b({\n  __name: \"AccordionRoot\",\n  props: {\n    type: {},\n    modelValue: {},\n    defaultValue: {},\n    collapsible: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    dir: {},\n    orientation: { default: \"vertical\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { dir: s, disabled: r } = z(e), l = de(s), { modelValue: i, changeModelValue: u } = Rn(e, a), { forwardRef: d, currentElement: p } = $();\n    return Ms({\n      disabled: r,\n      direction: l,\n      orientation: e.orientation,\n      parentElement: p,\n      isSingle: S(() => e.type === \"single\"),\n      collapsible: e.collapsible,\n      modelValue: i,\n      changeModelValue: u\n    }), (c, f) => (h(), C(n(D), {\n      ref: n(d),\n      \"as-child\": c.asChild,\n      as: c.as\n    }, {\n      default: m(() => [\n        y(c.$slots, \"default\", { modelValue: n(i) })\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), [_o, ks] = H(\"AccordionItem\"), nu = /* @__PURE__ */ b({\n  __name: \"AccordionItem\",\n  props: {\n    disabled: { type: Boolean },\n    value: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2, { expose: t }) {\n    const e = o2, a = It(), s = S(\n      () => a.isSingle.value ? e.value === a.modelValue.value : Array.isArray(a.modelValue.value) && a.modelValue.value.includes(e.value)\n    ), r = S(() => a.disabled.value || e.disabled || a.isSingle.value && s.value && !a.collapsible), l = S(() => r.value ? \"\" : void 0), i = S(\n      () => s.value ? \"open\" : \"closed\"\n      /* Closed */\n    );\n    t({ open: s, dataDisabled: l });\n    const { currentRef: u, currentElement: d } = $();\n    ks({\n      open: s,\n      dataState: i,\n      disabled: r,\n      dataDisabled: l,\n      triggerId: te(),\n      currentRef: u,\n      currentElement: d,\n      value: S(() => e.value)\n    });\n    function p(c) {\n      Je(\n        c,\n        d.value,\n        a.parentElement.value,\n        {\n          arrowKeyOptions: a.orientation,\n          dir: a.direction.value,\n          focus: true\n        }\n      );\n    }\n    return (c, f) => (h(), C(n(Ts), {\n      \"data-orientation\": n(a).orientation,\n      \"data-disabled\": l.value,\n      \"data-state\": i.value,\n      disabled: r.value,\n      open: s.value,\n      \"as-child\": e.asChild,\n      onKeydown: ie(p, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\"])\n    }, {\n      default: m(() => [\n        y(c.$slots, \"default\", { open: s.value })\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"data-disabled\", \"data-state\", \"disabled\", \"open\", \"as-child\"]));\n  }\n}), au = /* @__PURE__ */ b({\n  __name: \"AccordionContent\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = It(), a = _o();\n    return $(), (s, r) => (h(), C(n(Is), {\n      role: \"region\",\n      open: n(a).open.value,\n      hidden: !n(a).open.value,\n      \"as-child\": t.asChild,\n      \"aria-labelledby\": n(a).triggerId,\n      \"data-state\": n(a).dataState.value,\n      \"data-disabled\": n(a).dataDisabled.value,\n      \"data-orientation\": n(e).orientation,\n      style: { \"--radix-accordion-content-width\": \"var(--radix-collapsible-content-width)\", \"--radix-accordion-content-height\": \"var(--radix-collapsible-content-height)\" }\n    }, {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"hidden\", \"as-child\", \"aria-labelledby\", \"data-state\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), su = /* @__PURE__ */ b({\n  __name: \"AccordionHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h3\" }\n  },\n  setup(o2) {\n    const t = o2, e = It(), a = _o();\n    return $(), (s, r) => (h(), C(n(D), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-orientation\": n(e).orientation,\n      \"data-state\": n(a).dataState.value,\n      \"data-disabled\": n(a).dataDisabled.value\n    }, {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"data-state\", \"data-disabled\"]));\n  }\n}), ru = /* @__PURE__ */ b({\n  __name: \"AccordionTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = It(), a = _o();\n    function s() {\n      a.disabled.value || e.changeModelValue(a.value.value);\n    }\n    return (r, l) => (h(), C(n(Ds), {\n      id: n(a).triggerId,\n      ref: n(a).currentRef,\n      \"data-radix-vue-collection-item\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"aria-disabled\": n(a).disabled.value || void 0,\n      \"aria-expanded\": n(a).open.value || false,\n      \"data-disabled\": n(a).dataDisabled.value,\n      \"data-orientation\": n(e).orientation,\n      \"data-state\": n(a).dataState.value,\n      disabled: n(a).disabled.value,\n      onClick: s\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"as\", \"as-child\", \"aria-disabled\", \"aria-expanded\", \"data-disabled\", \"data-orientation\", \"data-state\", \"disabled\"]));\n  }\n}), [ye, Vs] = H(\"DialogRoot\"), Fs = /* @__PURE__ */ b({\n  __name: \"DialogRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean, default: false },\n    modal: { type: Boolean, default: true }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = Y(e, \"open\", t, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = P(), l = P(), { modal: i } = z(e);\n    return Vs({\n      open: s,\n      modal: i,\n      openModal: () => {\n        s.value = true;\n      },\n      onOpenChange: (u) => {\n        s.value = u;\n      },\n      onOpenToggle: () => {\n        s.value = !s.value;\n      },\n      contentId: te(),\n      titleId: te(),\n      descriptionId: te(),\n      triggerElement: r,\n      contentElement: l\n    }), (u, d) => y(u.$slots, \"default\");\n  }\n}), Ls = /* @__PURE__ */ b({\n  __name: \"DialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = ye(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.triggerElement = s;\n    }), (r, l) => (h(), C(n(D), T(t, {\n      ref: n(a),\n      type: r.as === \"button\" ? \"button\" : void 0,\n      \"aria-haspopup\": \"dialog\",\n      \"aria-expanded\": n(e).open.value || false,\n      \"aria-controls\": n(e).contentId,\n      \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n      onClick: n(e).onOpenToggle\n    }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"onClick\"]));\n  }\n}), Te = /* @__PURE__ */ b({\n  __name: \"Teleport\",\n  props: {\n    to: { default: \"body\" },\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = Dt();\n    return (e, a) => n(t) || e.forceMount ? (h(), C(Ye, {\n      key: 0,\n      to: e.to,\n      disabled: e.disabled\n    }, [\n      y(e.$slots, \"default\")\n    ], 8, [\"to\", \"disabled\"])) : X(\"\", true);\n  }\n}), lu = /* @__PURE__ */ b({\n  __name: \"DialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ks = \"dismissableLayer.pointerDownOutside\", Ns = \"dismissableLayer.focusOutside\";\nfunction Mn(o2, t) {\n  const e = t.closest(\n    \"[data-dismissable-layer]\"\n  ), a = o2.querySelector(\n    \"[data-dismissable-layer]\"\n  ), s = Array.from(\n    o2.ownerDocument.querySelectorAll(\"[data-dismissable-layer]\")\n  );\n  return !!(e && a === e || s.indexOf(a) < s.indexOf(e));\n}\nfunction Hs(o2, t) {\n  var r;\n  const e = ((r = t == null ? void 0 : t.value) == null ? void 0 : r.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), a = P(false), s = P(() => {\n  });\n  return ee((l) => {\n    if (!_e)\n      return;\n    const i = async (d) => {\n      const p = d.target;\n      if (t != null && t.value) {\n        if (Mn(t.value, p)) {\n          a.value = false;\n          return;\n        }\n        if (d.target && !a.value) {\n          let c = function() {\n            vo(\n              Ks,\n              o2,\n              f\n            );\n          };\n          const f = { originalEvent: d };\n          d.pointerType === \"touch\" ? (e.removeEventListener(\"click\", s.value), s.value = c, e.addEventListener(\"click\", s.value, {\n            once: true\n          })) : c();\n        } else\n          e.removeEventListener(\"click\", s.value);\n        a.value = false;\n      }\n    }, u = window.setTimeout(() => {\n      e.addEventListener(\"pointerdown\", i);\n    }, 0);\n    l(() => {\n      window.clearTimeout(u), e.removeEventListener(\"pointerdown\", i), e.removeEventListener(\"click\", s.value);\n    });\n  }), {\n    onPointerDownCapture: () => a.value = true\n  };\n}\nfunction js(o2, t) {\n  var s;\n  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), a = P(false);\n  return ee((r) => {\n    if (!_e)\n      return;\n    const l = async (i) => {\n      t != null && t.value && (await G(), !(!t.value || Mn(t.value, i.target)) && i.target && !a.value && vo(\n        Ns,\n        o2,\n        { originalEvent: i }\n      ));\n    };\n    e.addEventListener(\"focusin\", l), r(() => e.removeEventListener(\"focusin\", l));\n  }), {\n    onFocusCapture: () => a.value = true,\n    onBlurCapture: () => a.value = false\n  };\n}\nconst he = Cn({\n  layersRoot: /* @__PURE__ */ new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),\n  branches: /* @__PURE__ */ new Set()\n}), De = /* @__PURE__ */ b({\n  __name: \"DismissableLayer\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean, default: false },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { forwardRef: s, currentElement: r } = $(), l = S(\n      () => {\n        var g;\n        return ((g = r.value) == null ? void 0 : g.ownerDocument) ?? globalThis.document;\n      }\n    ), i = S(() => he.layersRoot), u = S(() => r.value ? Array.from(i.value).indexOf(r.value) : -1), d = S(() => he.layersWithOutsidePointerEventsDisabled.size > 0), p = S(() => {\n      const g = Array.from(i.value), [w] = [...he.layersWithOutsidePointerEventsDisabled].slice(-1), E = g.indexOf(w);\n      return u.value >= E;\n    }), c = Hs(async (g) => {\n      const w = [...he.branches].some(\n        (E) => E.contains(g.target)\n      );\n      !p.value || w || (a(\"pointerDownOutside\", g), a(\"interactOutside\", g), await G(), g.defaultPrevented || a(\"dismiss\"));\n    }, r), f = js((g) => {\n      [...he.branches].some(\n        (E) => E.contains(g.target)\n      ) || (a(\"focusOutside\", g), a(\"interactOutside\", g), g.defaultPrevented || a(\"dismiss\"));\n    }, r);\n    go(\"Escape\", (g) => {\n      u.value === i.value.size - 1 && (a(\"escapeKeyDown\", g), g.defaultPrevented || a(\"dismiss\"));\n    });\n    let v;\n    return ee((g) => {\n      r.value && (e.disableOutsidePointerEvents && (he.layersWithOutsidePointerEventsDisabled.size === 0 && (v = l.value.body.style.pointerEvents, l.value.body.style.pointerEvents = \"none\"), he.layersWithOutsidePointerEventsDisabled.add(r.value)), i.value.add(r.value), g(() => {\n        e.disableOutsidePointerEvents && he.layersWithOutsidePointerEventsDisabled.size === 1 && (l.value.body.style.pointerEvents = v);\n      }));\n    }), ee((g) => {\n      g(() => {\n        r.value && (i.value.delete(r.value), he.layersWithOutsidePointerEventsDisabled.delete(r.value));\n      });\n    }), (g, w) => (h(), C(n(D), {\n      ref: n(s),\n      \"as-child\": g.asChild,\n      as: g.as,\n      \"data-dismissable-layer\": \"\",\n      style: re({\n        pointerEvents: d.value ? p.value ? \"auto\" : \"none\" : void 0\n      }),\n      onFocusCapture: n(f).onFocusCapture,\n      onBlurCapture: n(f).onBlurCapture,\n      onPointerdownCapture: n(c).onPointerDownCapture\n    }, {\n      default: m(() => [\n        y(g.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"style\", \"onFocusCapture\", \"onBlurCapture\", \"onPointerdownCapture\"]));\n  }\n}), Ws = /* @__PURE__ */ b({\n  __name: \"DismissableLayerBranch\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e, currentElement: a } = $();\n    return q(() => {\n      he.branches.add(a.value);\n    }), fe(() => {\n      he.branches.delete(a.value);\n    }), (s, r) => (h(), C(n(D), T({ ref: n(e) }, t), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), eo = \"focusScope.autoFocusOnMount\", to = \"focusScope.autoFocusOnUnmount\", sn = { bubbles: false, cancelable: true };\nfunction xt(o2, { select: t = false } = {}) {\n  const e = document.activeElement;\n  for (const a of o2)\n    if (Pe(a, { select: t }), document.activeElement !== e)\n      return true;\n}\nfunction zs(o2) {\n  const t = $o(o2), e = rn(t, o2), a = rn(t.reverse(), o2);\n  return [e, a];\n}\nfunction $o(o2) {\n  const t = [], e = document.createTreeWalker(o2, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (a) => {\n      const s = a.tagName === \"INPUT\" && a.type === \"hidden\";\n      return a.disabled || a.hidden || s ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); )\n    t.push(e.currentNode);\n  return t;\n}\nfunction rn(o2, t) {\n  for (const e of o2)\n    if (!Us(e, { upTo: t }))\n      return e;\n}\nfunction Us(o2, { upTo: t }) {\n  if (getComputedStyle(o2).visibility === \"hidden\")\n    return true;\n  for (; o2; ) {\n    if (t !== void 0 && o2 === t)\n      return false;\n    if (getComputedStyle(o2).display === \"none\")\n      return true;\n    o2 = o2.parentElement;\n  }\n  return false;\n}\nfunction qs(o2) {\n  return o2 instanceof HTMLInputElement && \"select\" in o2;\n}\nfunction Pe(o2, { select: t = false } = {}) {\n  if (o2 && o2.focus) {\n    const e = document.activeElement;\n    o2.focus({ preventScroll: true }), o2 !== e && qs(o2) && t && o2.select();\n  }\n}\nconst Gs = En(() => P([]));\nfunction Ys() {\n  const o2 = Gs();\n  return {\n    add(t) {\n      const e = o2.value[0];\n      t !== e && (e == null || e.pause()), o2.value = ln(o2.value, t), o2.value.unshift(t);\n    },\n    remove(t) {\n      var e;\n      o2.value = ln(o2.value, t), (e = o2.value[0]) == null || e.resume();\n    }\n  };\n}\nfunction ln(o2, t) {\n  const e = [...o2], a = e.indexOf(t);\n  return a !== -1 && e.splice(a, 1), e;\n}\nfunction Xs(o2) {\n  return o2.filter((t) => t.tagName !== \"A\");\n}\nconst At = /* @__PURE__ */ b({\n  __name: \"FocusScope\",\n  props: {\n    loop: { type: Boolean, default: false },\n    trapped: { type: Boolean, default: false },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"mountAutoFocus\", \"unmountAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { currentRef: s, currentElement: r } = $(), l = P(null), i = Ys(), u = Cn({\n      paused: false,\n      pause() {\n        this.paused = true;\n      },\n      resume() {\n        this.paused = false;\n      }\n    });\n    ee((p) => {\n      if (!_e)\n        return;\n      const c = r.value;\n      if (!e.trapped)\n        return;\n      function f(E) {\n        if (u.paused || !c)\n          return;\n        const _ = E.target;\n        c.contains(_) ? l.value = _ : Pe(l.value, { select: true });\n      }\n      function v(E) {\n        if (u.paused || !c)\n          return;\n        const _ = E.relatedTarget;\n        _ !== null && (c.contains(_) || Pe(l.value, { select: true }));\n      }\n      function g(E) {\n        c.contains(l.value) || Pe(c);\n      }\n      document.addEventListener(\"focusin\", f), document.addEventListener(\"focusout\", v);\n      const w = new MutationObserver(g);\n      c && w.observe(c, { childList: true, subtree: true }), p(() => {\n        document.removeEventListener(\"focusin\", f), document.removeEventListener(\"focusout\", v), w.disconnect();\n      });\n    }), ee(async (p) => {\n      const c = r.value;\n      if (await G(), !c)\n        return;\n      i.add(u);\n      const f = document.activeElement;\n      if (!c.contains(f)) {\n        const g = new CustomEvent(eo, sn);\n        c.addEventListener(\n          eo,\n          (w) => a(\"mountAutoFocus\", w)\n        ), c.dispatchEvent(g), g.defaultPrevented || (xt(Xs($o(c)), {\n          select: true\n        }), document.activeElement === f && Pe(c));\n      }\n      p(() => {\n        c.removeEventListener(\n          eo,\n          (E) => a(\"mountAutoFocus\", E)\n        );\n        const g = new CustomEvent(to, sn), w = (E) => {\n          a(\"unmountAutoFocus\", E);\n        };\n        c.addEventListener(to, w), c.dispatchEvent(g), setTimeout(() => {\n          g.defaultPrevented || Pe(f ?? document.body, { select: true }), c.removeEventListener(to, w), i.remove(u);\n        }, 0);\n      });\n    });\n    function d(p) {\n      if (!e.loop && !e.trapped || u.paused)\n        return;\n      const c = p.key === \"Tab\" && !p.altKey && !p.ctrlKey && !p.metaKey, f = document.activeElement;\n      if (c && f) {\n        const v = p.currentTarget, [g, w] = zs(v);\n        g && w ? !p.shiftKey && f === w ? (p.preventDefault(), e.loop && Pe(g, { select: true })) : p.shiftKey && f === g && (p.preventDefault(), e.loop && Pe(w, { select: true })) : f === v && p.preventDefault();\n      }\n    }\n    return (p, c) => (h(), C(n(D), {\n      ref_key: \"currentRef\",\n      ref: s,\n      tabindex: \"-1\",\n      \"as-child\": p.asChild,\n      as: p.as,\n      onKeydown: d\n    }, {\n      default: m(() => [\n        y(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), Js = \"menu.itemSelect\", no = [\"Enter\", \" \"], Zs = [\"ArrowDown\", \"PageUp\", \"Home\"], kn = [\"ArrowUp\", \"PageDown\", \"End\"], Qs = [...Zs, ...kn], er = {\n  ltr: [...no, \"ArrowRight\"],\n  rtl: [...no, \"ArrowLeft\"]\n}, tr = {\n  ltr: [\"ArrowLeft\"],\n  rtl: [\"ArrowRight\"]\n};\nfunction xo(o2) {\n  return o2 ? \"open\" : \"closed\";\n}\nfunction Pt(o2) {\n  return o2 === \"indeterminate\";\n}\nfunction Eo(o2) {\n  return Pt(o2) ? \"indeterminate\" : o2 ? \"checked\" : \"unchecked\";\n}\nfunction ao(o2) {\n  const t = document.activeElement;\n  for (const e of o2)\n    if (e === t || (e.focus(), document.activeElement !== t))\n      return;\n}\nfunction or(o2, t) {\n  const { x: e, y: a } = o2;\n  let s = false;\n  for (let r = 0, l = t.length - 1; r < t.length; l = r++) {\n    const i = t[r].x, u = t[r].y, d = t[l].x, p = t[l].y;\n    u > a != p > a && e < (d - i) * (a - u) / (p - u) + i && (s = !s);\n  }\n  return s;\n}\nfunction nr(o2, t) {\n  if (!t)\n    return false;\n  const e = { x: o2.clientX, y: o2.clientY };\n  return or(e, t);\n}\nfunction rt(o2) {\n  return o2.pointerType === \"mouse\";\n}\nfunction ar() {\n  const o2 = \"DialogContent\", t = \"DialogTitle\", e = ye(), a = `Warning: \\`${o2}\\` requires a \\`${t}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${t}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://www.radix-vue.com/components/dialog.html#title;`, s = `Warning: Missing \\`Description\\` or \\`aria-describedby=\"undefined\"\\` for ${o2}.`;\n  q(() => {\n    var i;\n    document.getElementById(e.titleId) || console.warn(a);\n    const l = (i = e.contentElement.value) == null ? void 0 : i.getAttribute(\"aria-describedby\");\n    e.descriptionId && l && (document.getElementById(e.descriptionId) || console.warn(s));\n  });\n}\nconst Vn = /* @__PURE__ */ b({\n  __name: \"DialogContentImpl\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = ye(), { forwardRef: r, currentElement: l } = $();\n    return q(() => {\n      s.contentElement = l;\n    }), false, (i, u) => (h(), C(n(At), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: e.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => a(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => a(\"closeAutoFocus\", d))\n    }, {\n      default: m(() => [\n        k(n(De), T({\n          id: n(s).contentId,\n          ref: n(r),\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          role: \"dialog\",\n          \"aria-describedby\": n(s).descriptionId,\n          \"aria-labelledby\": n(s).titleId,\n          \"data-state\": n(xo)(n(s).open.value)\n        }, i.$attrs, {\n          onDismiss: u[0] || (u[0] = (d) => n(s).onOpenChange(false)),\n          onEscapeKeyDown: u[1] || (u[1] = (d) => a(\"escapeKeyDown\", d)),\n          onFocusOutside: u[2] || (u[2] = (d) => a(\"focusOutside\", d)),\n          onInteractOutside: u[3] || (u[3] = (d) => a(\"interactOutside\", d)),\n          onPointerDownOutside: u[4] || (u[4] = (d) => a(\"pointerDownOutside\", d))\n        }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"as\", \"as-child\", \"disable-outside-pointer-events\", \"aria-describedby\", \"aria-labelledby\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), sr = /* @__PURE__ */ b({\n  __name: \"DialogContentModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = ye(), r = ce(a), { forwardRef: l, currentElement: i } = $();\n    return pt(i), (u, d) => (h(), C(Vn, T({ ...e, ...n(r) }, {\n      ref: n(l),\n      \"trap-focus\": n(s).open.value,\n      \"disable-outside-pointer-events\": true,\n      onCloseAutoFocus: d[0] || (d[0] = (p) => {\n        var c;\n        a(\"closeAutoFocus\", p), p.defaultPrevented || (p.preventDefault(), (c = n(s).triggerElement.value) == null || c.focus());\n      }),\n      onPointerDownOutside: d[1] || (d[1] = (p) => {\n        const c = p.detail.originalEvent, f = c.button === 0 && c.ctrlKey === true;\n        (c.button === 2 || f) && p.preventDefault();\n      }),\n      onFocusOutside: d[2] || (d[2] = (p) => {\n        p.preventDefault();\n      }),\n      onOpenAutoFocus: d[3] || (d[3] = (p) => a(\"openAutoFocus\", p))\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), rr = /* @__PURE__ */ b({\n  __name: \"DialogContentNonModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = ce(a);\n    $();\n    const r = ye(), l = P(false), i = P(false);\n    return (u, d) => (h(), C(Vn, T({ ...e, ...n(s) }, {\n      \"trap-focus\": false,\n      \"disable-outside-pointer-events\": false,\n      onCloseAutoFocus: d[0] || (d[0] = (p) => {\n        var c;\n        a(\"closeAutoFocus\", p), p.defaultPrevented || (l.value || (c = n(r).triggerElement.value) == null || c.focus(), p.preventDefault()), l.value = false, i.value = false;\n      }),\n      onInteractOutside: d[1] || (d[1] = (p) => {\n        var v;\n        p.defaultPrevented || (l.value = true, p.detail.originalEvent.type === \"pointerdown\" && (i.value = true));\n        const c = p.target;\n        ((v = n(r).triggerElement.value) == null ? void 0 : v.contains(c)) && p.preventDefault(), p.detail.originalEvent.type === \"focusin\" && i.value && p.preventDefault();\n      })\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lr = /* @__PURE__ */ b({\n  __name: \"DialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = ye(), r = ce(a), { forwardRef: l } = $();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(s).open.value\n    }, {\n      default: m(() => [\n        n(s).modal.value ? (h(), C(sr, T({\n          key: 0,\n          ref: n(l)\n        }, { ...e, ...n(r), ...i.$attrs }, {\n          onOpenAutoFocus: u[0] || (u[0] = (d) => a(\"openAutoFocus\", d))\n        }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (h(), C(rr, T({\n          key: 1,\n          ref: n(l)\n        }, { ...e, ...n(r), ...i.$attrs }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), ir = /* @__PURE__ */ b({\n  __name: \"DialogOverlayImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = ye();\n    return ct(true), $(), (e, a) => (h(), C(n(D), {\n      as: e.as,\n      \"as-child\": e.asChild,\n      \"data-state\": n(t).open.value ? \"open\" : \"closed\",\n      style: { \"pointer-events\": \"auto\" }\n    }, {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\"]));\n  }\n}), ur = /* @__PURE__ */ b({\n  __name: \"DialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = ye(), { forwardRef: e } = $();\n    return (a, s) => {\n      var r;\n      return (r = n(t)) != null && r.modal.value ? (h(), C(n(se), {\n        key: 0,\n        present: a.forceMount || n(t).open.value\n      }, {\n        default: m(() => [\n          k(ir, T(a.$attrs, {\n            ref: n(e),\n            as: a.as,\n            \"as-child\": a.asChild\n          }), {\n            default: m(() => [\n              y(a.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])) : X(\"\", true);\n    };\n  }\n}), Fn = /* @__PURE__ */ b({\n  __name: \"DialogClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = ye();\n    return (a, s) => (h(), C(n(D), T(t, {\n      type: a.as === \"button\" ? \"button\" : void 0,\n      onClick: s[0] || (s[0] = (r) => n(e).onOpenChange(false))\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), dr = /* @__PURE__ */ b({\n  __name: \"DialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h2\" }\n  },\n  setup(o2) {\n    const t = o2, e = ye();\n    return $(), (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).titleId\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), cr = /* @__PURE__ */ b({\n  __name: \"DialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = ye();\n    return (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).descriptionId\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), iu = /* @__PURE__ */ b({\n  __name: \"AlertDialogRoot\",\n  props: {\n    open: { type: Boolean },\n    defaultOpen: { type: Boolean }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t);\n    return $(), (r, l) => (h(), C(n(Fs), T(n(s), { modal: true }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), uu = /* @__PURE__ */ b({\n  __name: \"AlertDialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Ls), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), du = /* @__PURE__ */ b({\n  __name: \"AlertDialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [pr, fr] = H(\"AlertDialogContent\"), cu = /* @__PURE__ */ b({\n  __name: \"AlertDialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    $();\n    const r = P();\n    return fr({\n      onCancelElementChange: (l) => {\n        r.value = l;\n      }\n    }), (l, i) => (h(), C(n(lr), T({ ...e, ...n(s) }, {\n      role: \"alertdialog\",\n      onPointerDownOutside: i[0] || (i[0] = oe(() => {\n      }, [\"prevent\"])),\n      onInteractOutside: i[1] || (i[1] = oe(() => {\n      }, [\"prevent\"])),\n      onOpenAutoFocus: i[2] || (i[2] = () => {\n        G(() => {\n          var u;\n          (u = r.value) == null || u.focus({\n            preventScroll: true\n          });\n        });\n      })\n    }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), pu = /* @__PURE__ */ b({\n  __name: \"AlertDialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(ur), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fu = /* @__PURE__ */ b({\n  __name: \"AlertDialogCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = pr(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.onCancelElementChange(s.value);\n    }), (r, l) => (h(), C(n(Fn), T(t, { ref: n(a) }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vu = /* @__PURE__ */ b({\n  __name: \"AlertDialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(dr), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), mu = /* @__PURE__ */ b({\n  __name: \"AlertDialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(cr), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), hu = /* @__PURE__ */ b({\n  __name: \"AlertDialogAction\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Fn), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gu = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"AspectRatio\",\n  props: {\n    ratio: { default: 1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $(), a = S(() => 1 / t.ratio * 100);\n    return (s, r) => (h(), Q(\"div\", {\n      style: re(`position: relative; width: 100%; padding-bottom: ${a.value}%`),\n      \"data-radix-aspect-ratio-wrapper\": \"\"\n    }, [\n      k(n(D), T({\n        ref: n(e),\n        \"as-child\": s.asChild,\n        as: s.as,\n        style: { position: \"absolute\", inset: \"0px\" }\n      }, s.$attrs), {\n        default: m(() => [\n          y(s.$slots, \"default\", { aspect: a.value })\n        ]),\n        _: 3\n      }, 16, [\"as-child\", \"as\"])\n    ], 4));\n  }\n}), [Ln, vr] = H(\"AvatarRoot\"), yu = /* @__PURE__ */ b({\n  __name: \"AvatarRoot\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    return $(), vr({\n      imageLoadingStatus: P(\"loading\")\n    }), (t, e) => (h(), C(n(D), {\n      \"as-child\": t.asChild,\n      as: t.as\n    }, {\n      default: m(() => [\n        y(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n});\nfunction mr(o2) {\n  const t = P(\"idle\"), e = P(false), a = (s) => () => {\n    e.value && (t.value = s);\n  };\n  return q(() => {\n    e.value = true, U(o2, (s) => {\n      if (!s)\n        t.value = \"error\";\n      else {\n        const r = new window.Image();\n        t.value = \"loading\", r.onload = a(\"loaded\"), r.onerror = a(\"error\"), r.src = s;\n      }\n    }, { immediate: true });\n  }), fe(() => {\n    e.value = false;\n  }), t;\n}\nconst bu = /* @__PURE__ */ b({\n  __name: \"AvatarImage\",\n  props: {\n    src: {},\n    asChild: { type: Boolean },\n    as: { default: \"img\" }\n  },\n  emits: [\"loadingStatusChange\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { src: s } = z(e);\n    $();\n    const r = Ln(), l = mr(s);\n    return U(\n      l,\n      (i) => {\n        a(\"loadingStatusChange\", i), i !== \"idle\" && (r.imageLoadingStatus.value = i);\n      },\n      { immediate: true }\n    ), (i, u) => n(l) === \"loaded\" ? (h(), C(n(D), {\n      key: 0,\n      role: \"img\",\n      \"as-child\": i.asChild,\n      as: i.as,\n      src: n(s)\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"src\"])) : X(\"\", true);\n  }\n}), Cu = /* @__PURE__ */ b({\n  __name: \"AvatarFallback\",\n  props: {\n    delayMs: { default: 0 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = o2, e = Ln();\n    $();\n    const a = P(false);\n    let s;\n    return U(e.imageLoadingStatus, (r) => {\n      r === \"loading\" && (a.value = false, t.delayMs ? s = setTimeout(() => {\n        a.value = true, clearTimeout(s);\n      }, t.delayMs) : a.value = true);\n    }, { immediate: true }), (r, l) => a.value && n(e).imageLoadingStatus.value !== \"loaded\" ? (h(), C(n(D), {\n      key: 0,\n      \"as-child\": r.asChild,\n      as: r.as\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"])) : X(\"\", true);\n  }\n});\nfunction Bt(o2) {\n  return o2 === \"indeterminate\";\n}\nfunction Kn(o2) {\n  return Bt(o2) ? \"indeterminate\" : o2 ? \"checked\" : \"unchecked\";\n}\nconst hr = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], [gr, yr] = H(\"CheckboxRoot\"), wu = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"CheckboxRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: [Boolean, String], default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    value: { default: \"on\" },\n    id: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { disabled: s } = z(e), r = Y(e, \"checked\", a, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    }), { forwardRef: l, currentElement: i } = $(), u = Ne(i), d = S(() => {\n      var p;\n      return e.id && i.value ? (p = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : p.innerText : void 0;\n    });\n    return yr({\n      disabled: s,\n      state: r\n    }), (p, c) => (h(), Q(le, null, [\n      k(n(D), T(p.$attrs, {\n        id: p.id,\n        ref: n(l),\n        role: \"checkbox\",\n        \"as-child\": e.asChild,\n        as: p.as,\n        type: p.as === \"button\" ? \"button\" : void 0,\n        \"aria-checked\": n(Bt)(n(r)) ? \"mixed\" : n(r),\n        \"aria-required\": false,\n        \"aria-label\": p.$attrs[\"aria-label\"] || d.value,\n        \"data-state\": n(Kn)(n(r)),\n        \"data-disabled\": n(s) ? \"\" : void 0,\n        disabled: n(s),\n        onKeydown: ie(oe(() => {\n        }, [\"prevent\"]), [\"enter\"]),\n        onClick: c[0] || (c[0] = (f) => r.value = n(Bt)(n(r)) ? true : !n(r))\n      }), {\n        default: m(() => [\n          y(p.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"as-child\", \"as\", \"type\", \"aria-checked\", \"aria-label\", \"data-state\", \"data-disabled\", \"disabled\", \"onKeydown\"]),\n      n(u) ? (h(), Q(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: p.value,\n        checked: !!n(r),\n        name: e.name,\n        disabled: e.disabled,\n        required: e.required,\n        style: re({\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        })\n      }, null, 12, hr)) : X(\"\", true)\n    ], 64));\n  }\n}), _u = /* @__PURE__ */ b({\n  __name: \"CheckboxIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const { forwardRef: t } = $(), e = gr();\n    return (a, s) => (h(), C(n(se), {\n      present: a.forceMount || n(Bt)(n(e).state.value) || n(e).state.value === true\n    }, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(t),\n          \"data-state\": n(Kn)(n(e).state.value),\n          \"data-disabled\": n(e).disabled.value ? \"\" : void 0,\n          style: { pointerEvents: \"none\" },\n          \"as-child\": a.asChild,\n          as: a.as\n        }, a.$attrs), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [Nn, br] = H(\"PopperRoot\"), je = /* @__PURE__ */ b({\n  __name: \"PopperRoot\",\n  setup(o2) {\n    const t = P();\n    return br({\n      anchor: t,\n      onAnchorChange: (e) => t.value = e\n    }), (e, a) => y(e.$slots, \"default\");\n  }\n}), We = /* @__PURE__ */ b({\n  __name: \"PopperAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e, currentElement: a } = $(), s = Nn();\n    return U(a, () => {\n      s.onAnchorChange(t.element ?? a.value);\n    }), (r, l) => (h(), C(n(D), {\n      ref: n(e),\n      as: r.as,\n      \"as-child\": r.asChild\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n});\nfunction Cr(o2) {\n  return o2 !== null;\n}\nfunction wr(o2) {\n  return {\n    name: \"transformOrigin\",\n    options: o2,\n    fn(t) {\n      var E, _, x;\n      const { placement: e, rects: a, middlewareData: s } = t, l = ((E = s.arrow) == null ? void 0 : E.centerOffset) !== 0, i = l ? 0 : o2.arrowWidth, u = l ? 0 : o2.arrowHeight, [d, p] = so(e), c = { start: \"0%\", center: \"50%\", end: \"100%\" }[p], f = (((_ = s.arrow) == null ? void 0 : _.x) ?? 0) + i / 2, v = (((x = s.arrow) == null ? void 0 : x.y) ?? 0) + u / 2;\n      let g = \"\", w = \"\";\n      return d === \"bottom\" ? (g = l ? c : `${f}px`, w = `${-u}px`) : d === \"top\" ? (g = l ? c : `${f}px`, w = `${a.floating.height + u}px`) : d === \"right\" ? (g = `${-u}px`, w = l ? c : `${v}px`) : d === \"left\" && (g = `${a.floating.width + u}px`, w = l ? c : `${v}px`), { data: { x: g, y: w } };\n    }\n  };\n}\nfunction so(o2) {\n  const [t, e = \"center\"] = o2.split(\"-\");\n  return [t, e];\n}\nconst Hn = {\n  side: \"bottom\",\n  sideOffset: 0,\n  align: \"center\",\n  alignOffset: 0,\n  arrowPadding: 0,\n  avoidCollisions: true,\n  collisionBoundary: () => [],\n  collisionPadding: 0,\n  sticky: \"partial\",\n  hideWhenDetached: false,\n  updatePositionStrategy: \"optimized\",\n  prioritizePosition: false\n}, [_r, $r] = H(\"PopperContent\"), Fe = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"PopperContent\",\n  props: /* @__PURE__ */ wn({\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...Hn\n  }),\n  emits: [\"placed\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = Nn(), { forwardRef: r, currentElement: l } = $(), i = P(), u = P(), { width: d, height: p } = Dn(u), c = S(\n      () => e.side + (e.align !== \"center\" ? `-${e.align}` : \"\")\n    ), f = S(() => typeof e.collisionPadding == \"number\" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), v = S(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), g = S(() => ({\n      padding: f.value,\n      boundary: v.value.filter(Cr),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: v.value.length > 0\n    })), w = Ga(() => [\n      Ha({\n        mainAxis: e.sideOffset + p.value,\n        alignmentAxis: e.alignOffset\n      }),\n      e.prioritizePosition && e.avoidCollisions && tn({\n        ...g.value\n      }),\n      e.avoidCollisions && ja({\n        mainAxis: true,\n        crossAxis: !!e.prioritizePosition,\n        limiter: e.sticky === \"partial\" ? Wa() : void 0,\n        ...g.value\n      }),\n      !e.prioritizePosition && e.avoidCollisions && tn({\n        ...g.value\n      }),\n      za({\n        ...g.value,\n        apply: ({ elements: I, rects: F, availableWidth: W, availableHeight: J }) => {\n          const { width: K, height: Z } = F.reference, ne = I.floating.style;\n          Object.assign(I.floating.style, {\n            maxWidth: `${W}px`,\n            maxHeight: `${J}px`\n          }), ne.setProperty(\n            \"--radix-popper-available-width\",\n            `${W}px`\n          ), ne.setProperty(\n            \"--radix-popper-available-height\",\n            `${J}px`\n          ), ne.setProperty(\n            \"--radix-popper-anchor-width\",\n            `${K}px`\n          ), ne.setProperty(\n            \"--radix-popper-anchor-height\",\n            `${Z}px`\n          );\n        }\n      }),\n      u.value && Ua({ element: u.value, padding: e.arrowPadding }),\n      wr({\n        arrowWidth: d.value,\n        arrowHeight: p.value\n      }),\n      e.hideWhenDetached && qa({ strategy: \"referenceHidden\", ...g.value })\n    ]), { floatingStyles: E, placement: _, isPositioned: x, middlewareData: B } = Ka(\n      s.anchor,\n      i,\n      {\n        strategy: \"fixed\",\n        placement: c,\n        whileElementsMounted: (...I) => Na(...I, {\n          animationFrame: e.updatePositionStrategy === \"always\"\n        }),\n        middleware: w\n      }\n    ), O = S(\n      () => so(_.value)[0]\n    ), A = S(\n      () => so(_.value)[1]\n    );\n    ee(() => {\n      x.value && a(\"placed\");\n    });\n    const M = S(\n      () => {\n        var I;\n        return ((I = B.value.arrow) == null ? void 0 : I.centerOffset) !== 0;\n      }\n    ), R = P(\"\");\n    ee(() => {\n      l.value && (R.value = window.getComputedStyle(l.value).zIndex);\n    });\n    const V = S(() => {\n      var I;\n      return ((I = B.value.arrow) == null ? void 0 : I.x) ?? 0;\n    }), j = S(() => {\n      var I;\n      return ((I = B.value.arrow) == null ? void 0 : I.y) ?? 0;\n    });\n    return $r({\n      placedSide: O,\n      onArrowChange: (I) => u.value = I,\n      arrowX: V,\n      arrowY: j,\n      shouldHideArrow: M\n    }), (I, F) => {\n      var W, J, K;\n      return h(), Q(\"div\", {\n        ref_key: \"floatingRef\",\n        ref: i,\n        \"data-radix-popper-content-wrapper\": \"\",\n        style: re({\n          ...n(E),\n          transform: n(x) ? n(E).transform : \"translate(0, -200%)\",\n          // keep off the page when measuring\n          minWidth: \"max-content\",\n          zIndex: R.value,\n          \"--radix-popper-transform-origin\": [\n            (W = n(B).transformOrigin) == null ? void 0 : W.x,\n            (J = n(B).transformOrigin) == null ? void 0 : J.y\n          ].join(\" \")\n        })\n      }, [\n        k(n(D), T({ ref: n(r) }, I.$attrs, {\n          \"as-child\": e.asChild,\n          as: I.as,\n          \"data-side\": O.value,\n          \"data-align\": A.value,\n          style: {\n            // if the PopperContent hasn't been placed yet (not all measurements done)\n            // we prevent animations so that users's animation don't kick in too early referring wrong sides\n            animation: n(x) ? void 0 : \"none\",\n            // hide the content if using the hide middleware and should be hidden\n            opacity: (K = n(B).hide) != null && K.referenceHidden ? 0 : void 0\n          }\n        }), {\n          default: m(() => [\n            y(I.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-side\", \"data-align\", \"style\"])\n      ], 4);\n    };\n  }\n}), xr = /* @__PURE__ */ ut(\"polygon\", { points: \"0,0 30,0 15,10\" }, null, -1), Er = /* @__PURE__ */ b({\n  __name: \"Arrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(D), T(t, {\n      width: e.width,\n      height: e.height,\n      viewBox: e.asChild ? void 0 : \"0 0 30 10\",\n      preserveAspectRatio: e.asChild ? void 0 : \"none\"\n    }), {\n      default: m(() => [\n        y(e.$slots, \"default\", {}, () => [\n          xr\n        ])\n      ]),\n      _: 3\n    }, 16, [\"width\", \"height\", \"viewBox\", \"preserveAspectRatio\"]));\n  }\n}), Pr = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n}, Ze = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"PopperArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const { forwardRef: t } = $(), e = _r(), a = S(() => Pr[e.placedSide.value]);\n    return (s, r) => {\n      var l, i, u, d;\n      return h(), Q(\"span\", {\n        ref: (p) => {\n          n(e).onArrowChange(p);\n        },\n        style: re({\n          position: \"absolute\",\n          left: (l = n(e).arrowX) != null && l.value ? `${(i = n(e).arrowX) == null ? void 0 : i.value}px` : void 0,\n          top: (u = n(e).arrowY) != null && u.value ? `${(d = n(e).arrowY) == null ? void 0 : d.value}px` : void 0,\n          [a.value]: 0,\n          transformOrigin: {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\"\n          }[n(e).placedSide.value],\n          transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: \"rotate(180deg)\",\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n          }[n(e).placedSide.value],\n          visibility: n(e).shouldHideArrow.value ? \"hidden\" : void 0\n        })\n      }, [\n        k(Er, T(s.$attrs, {\n          ref: n(t),\n          style: {\n            display: \"block\"\n          },\n          as: s.as,\n          \"as-child\": s.asChild,\n          width: s.width,\n          height: s.height\n        }), {\n          default: m(() => [\n            y(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"width\", \"height\"])\n      ], 4);\n    };\n  }\n}), Qe = /* @__PURE__ */ b({\n  __name: \"VisuallyHidden\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    return $(), (t, e) => (h(), C(n(D), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      style: re({\n        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n        position: \"absolute\",\n        border: 0,\n        width: \"1px\",\n        display: \"inline-block\",\n        height: \"1px\",\n        padding: 0,\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        clip: \"rect(0, 0, 0, 0)\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n      })\n    }, {\n      default: m(() => [\n        y(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"style\"]));\n  }\n}), jn = /* @__PURE__ */ b({\n  __name: \"VisuallyHiddenInput\",\n  props: {\n    name: {},\n    value: {},\n    required: { type: Boolean },\n    disabled: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2, e = S(() => typeof t.value == \"string\" || typeof t.value == \"number\" || typeof t.value == \"boolean\" ? [{ name: t.name, value: t.value }] : typeof t.value == \"object\" && Array.isArray(t.value) ? t.value.flatMap((a, s) => typeof a == \"object\" ? Object.entries(a).map(([r, l]) => ({ name: `[${s}][${t.name}][${r}]`, value: l })) : { name: `[${t.name}][${s}]`, value: a }) : typeof t.value == \"object\" && !Array.isArray(t.value) ? Object.entries(t.value).map(([a, s]) => ({ name: `[${t.name}][${a}]`, value: s })) : []);\n    return (a, s) => (h(true), Q(le, null, po(e.value, (r) => (h(), C(Qe, {\n      key: r.name,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: \"\",\n      readonly: \"\",\n      name: r.name,\n      value: r.value,\n      required: a.required,\n      disabled: a.disabled\n    }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"]))), 128));\n  }\n});\nfunction Br(o2) {\n  return o2 && o2.__esModule && Object.prototype.hasOwnProperty.call(o2, \"default\") ? o2.default : o2;\n}\nvar Sr = function o(t, e) {\n  if (t === e)\n    return true;\n  if (t && e && typeof t == \"object\" && typeof e == \"object\") {\n    if (t.constructor !== e.constructor)\n      return false;\n    var a, s, r;\n    if (Array.isArray(t)) {\n      if (a = t.length, a != e.length)\n        return false;\n      for (s = a; s-- !== 0; )\n        if (!o(t[s], e[s]))\n          return false;\n      return true;\n    }\n    if (t.constructor === RegExp)\n      return t.source === e.source && t.flags === e.flags;\n    if (t.valueOf !== Object.prototype.valueOf)\n      return t.valueOf() === e.valueOf();\n    if (t.toString !== Object.prototype.toString)\n      return t.toString() === e.toString();\n    if (r = Object.keys(t), a = r.length, a !== Object.keys(e).length)\n      return false;\n    for (s = a; s-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(e, r[s]))\n        return false;\n    for (s = a; s-- !== 0; ) {\n      var l = r[s];\n      if (!o(t[l], e[l]))\n        return false;\n    }\n    return true;\n  }\n  return t !== t && e !== e;\n};\nconst Ge = /* @__PURE__ */ Br(Sr), Tr = \"data-radix-vue-collection-item\", [Po, Dr] = H(\"CollectionProvider\");\nfunction Bo(o2 = Tr) {\n  const t = P(/* @__PURE__ */ new Map()), e = P(), a = Dr({\n    collectionRef: e,\n    itemMap: t,\n    attrName: o2\n  }), { getItems: s } = Wn(a), r = S(() => Array.from(a.itemMap.value.values())), l = S(() => a.itemMap.value.size);\n  return { getItems: s, reactiveItems: r, itemMapSize: l };\n}\nconst So = b({\n  name: \"CollectionSlot\",\n  setup(o2, { slots: t }) {\n    const e = Po(), { primitiveElement: a, currentElement: s } = In();\n    return U(s, () => {\n      e.collectionRef.value = s.value;\n    }), () => Ve(wo, { ref: a }, t);\n  }\n}), To = b({\n  name: \"CollectionItem\",\n  setup(o2, { slots: t, attrs: e }) {\n    const a = Po(), { primitiveElement: s, currentElement: r } = In(), l = Se();\n    return ee((i) => {\n      var u;\n      if (r.value) {\n        const d = en(r.value);\n        a.itemMap.value.set(d, { ref: r.value, ...en(((u = l == null ? void 0 : l.parent) == null ? void 0 : u.props) ?? {}) }), i(() => a.itemMap.value.delete(d));\n      }\n    }), () => Ve(wo, { ...e, [a.attrName]: \"\", ref: s }, t);\n  }\n});\nfunction Wn(o2) {\n  const t = o2 ?? Po();\n  return { getItems: () => {\n    const a = t.collectionRef.value;\n    if (!a)\n      return [];\n    const s = Array.from(a.querySelectorAll(`[${t.attrName}]`));\n    return Array.from(t.itemMap.value.values()).sort(\n      (i, u) => s.indexOf(i.ref) - s.indexOf(u.ref)\n    );\n  } };\n}\nconst [$e, Or] = H(\"ComboboxRoot\"), $u = /* @__PURE__ */ b({\n  __name: \"ComboboxRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    searchTerm: {},\n    multiple: { type: Boolean },\n    disabled: { type: Boolean },\n    name: {},\n    dir: {},\n    filterFunction: {},\n    displayValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:open\", \"update:searchTerm\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { multiple: s, disabled: r, dir: l } = z(e), i = de(l), u = Y(e, \"searchTerm\", a, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: \"\",\n      passive: e.searchTerm === void 0\n    }), d = Y(e, \"modelValue\", a, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: e.defaultValue ?? s.value ? [] : void 0,\n      passive: e.modelValue === void 0,\n      deep: true\n    }), p = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), c = P();\n    async function f(K) {\n      var Z, ne;\n      p.value = K, await G(), K ? (d.value && (Array.isArray(d.value) && s.value ? c.value = (Z = B().find((Ut) => {\n        var at, mt;\n        return ((mt = (at = Ut.ref) == null ? void 0 : at.dataset) == null ? void 0 : mt.state) === \"checked\";\n      })) == null ? void 0 : Z.value : c.value = d.value), (ne = w.value) == null || ne.focus(), J()) : (g.value = false, V());\n    }\n    function v(K) {\n      if (Array.isArray(d.value) && s.value) {\n        const Z = d.value.findIndex((ne) => Ge(ne, K));\n        Z === -1 ? d.value.push(K) : d.value.splice(Z, 1);\n      } else\n        d.value = K, f(false);\n    }\n    const g = P(false), w = P(), E = P(), { forwardRef: _, currentElement: x } = $(), { getItems: B, reactiveItems: O, itemMapSize: A } = Bo(\"data-radix-vue-combobox-item\"), M = P([]);\n    U(() => A.value, () => {\n      M.value = B().map((K) => K.value);\n    }, { immediate: true });\n    const R = S(() => {\n      if (g.value) {\n        if (e.filterFunction)\n          return e.filterFunction(M.value, u.value);\n        const K = M.value.filter((Z) => typeof Z == \"string\");\n        if (K.length)\n          return K.filter((Z) => {\n            var ne;\n            return Z.toLowerCase().includes((ne = u.value) == null ? void 0 : ne.toLowerCase());\n          });\n      }\n      return M.value;\n    });\n    function V() {\n      !s.value && d.value && !Array.isArray(d.value) ? e.displayValue ? u.value = e.displayValue(d.value) : typeof d.value != \"object\" ? u.value = d.value.toString() : u.value = \"\" : u.value = \"\";\n    }\n    const j = S(() => R.value.findIndex((K) => Ge(K, c.value))), I = S(() => {\n      var K;\n      return (K = O.value.find((Z) => Z.value === c.value)) == null ? void 0 : K.ref;\n    }), F = S(() => JSON.stringify(d.value));\n    U(F, async () => {\n      await G(), await G(), V();\n    }, { immediate: true }), U(() => R.value.length, async (K) => {\n      await G(), await G(), K && j.value === -1 && (c.value = R.value[0]);\n    });\n    const W = Ne(x);\n    function J() {\n      I.value instanceof Element && I.value.scrollIntoView({ block: \"nearest\" });\n    }\n    return Or({\n      searchTerm: u,\n      modelValue: d,\n      // @ts-expect-error igoring\n      onValueChange: v,\n      isUserInputted: g,\n      multiple: s,\n      disabled: r,\n      open: p,\n      onOpenChange: f,\n      filteredOptions: R,\n      contentId: te(),\n      inputElement: w,\n      onInputElementChange: (K) => w.value = K,\n      onInputNavigation: async (K) => {\n        const Z = j.value;\n        Z === 0 && K === \"up\" || Z === R.value.length - 1 && K === \"down\" || (Z === -1 && R.value.length || K === \"home\" ? c.value = R.value[0] : K === \"end\" ? c.value = R.value[R.value.length - 1] : c.value = R.value[K === \"up\" ? Z - 1 : Z + 1], J());\n      },\n      onInputEnter: async () => {\n        var K;\n        R.value.length && c.value && I.value instanceof Element && ((K = I.value) == null || K.click());\n      },\n      selectedValue: c,\n      onSelectedValueChange: (K) => c.value = K,\n      parentElement: x,\n      contentElement: E,\n      onContentElementChange: (K) => E.value = K\n    }), (K, Z) => (h(), C(n(je), null, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(_),\n          style: {\n            pointerEvents: n(p) ? \"auto\" : void 0\n          },\n          as: K.as,\n          \"as-child\": K.asChild,\n          dir: n(i)\n        }, K.$attrs), {\n          default: m(() => [\n            y(K.$slots, \"default\", {\n              open: n(p),\n              modelValue: n(d)\n            }),\n            n(W) && e.name ? (h(), C(n(jn), {\n              key: 0,\n              name: e.name,\n              value: n(d)\n            }, null, 8, [\"name\", \"value\"])) : X(\"\", true)\n          ]),\n          _: 3\n        }, 16, [\"style\", \"as\", \"as-child\", \"dir\"])\n      ]),\n      _: 3\n    }));\n  }\n}), xu = /* @__PURE__ */ b({\n  __name: \"ComboboxInput\",\n  props: {\n    type: { default: \"text\" },\n    disabled: { type: Boolean },\n    autoFocus: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(o2) {\n    const t = o2, e = $e(), { forwardRef: a, currentElement: s } = $();\n    q(() => {\n      const d = s.value.nodeName === \"INPUT\" ? s.value : s.value.querySelector(\"input\");\n      d && (e.onInputElementChange(d), setTimeout(() => {\n        t.autoFocus && (d == null || d.focus());\n      }, 1));\n    });\n    const r = S(() => t.disabled || e.disabled.value || false);\n    function l(d) {\n      e.open.value ? e.onInputNavigation(d.key === \"ArrowUp\" ? \"up\" : \"down\") : e.onOpenChange(true);\n    }\n    function i(d) {\n      e.open.value && e.onInputNavigation(d.key === \"Home\" ? \"home\" : \"end\");\n    }\n    function u(d) {\n      var p;\n      e.searchTerm.value = (p = d.target) == null ? void 0 : p.value, e.open.value || e.onOpenChange(true), e.isUserInputted.value = true;\n    }\n    return (d, p) => (h(), C(n(D), {\n      ref: n(a),\n      as: d.as,\n      \"as-child\": d.asChild,\n      type: d.type,\n      disabled: r.value,\n      value: n(e).searchTerm.value,\n      \"aria-expanded\": n(e).open.value,\n      \"aria-controls\": n(e).contentId,\n      \"aria-disabled\": r.value ?? void 0,\n      \"aria-autocomplete\": \"list\",\n      role: \"combobox\",\n      autocomplete: \"false\",\n      onInput: u,\n      onKeydown: [\n        ie(oe(l, [\"prevent\"]), [\"down\", \"up\"]),\n        ie(n(e).onInputEnter, [\"enter\"]),\n        ie(oe(i, [\"prevent\"]), [\"home\", \"end\"])\n      ]\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"disabled\", \"value\", \"aria-expanded\", \"aria-controls\", \"aria-disabled\", \"onKeydown\"]));\n  }\n}), Eu = /* @__PURE__ */ b({\n  __name: \"ComboboxAnchor\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const { forwardRef: t } = $();\n    return (e, a) => (h(), C(n(We), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(t),\n          \"as-child\": e.asChild,\n          as: e.as\n        }, e.$attrs), {\n          default: m(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Pu = /* @__PURE__ */ b({\n  __name: \"ComboboxTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = $e(), a = S(() => t.disabled || e.disabled.value || false);\n    return (s, r) => (h(), C(n(D), T(t, {\n      type: s.as === \"button\" ? \"button\" : void 0,\n      tabindex: \"-1\",\n      \"aria-label\": \"Show popup\",\n      \"aria-haspopup\": \"listbox\",\n      \"aria-expanded\": n(e).open.value,\n      \"aria-controls\": n(e).contentId,\n      \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n      disabled: a.value,\n      \"data-disabled\": a.value ? \"\" : void 0,\n      \"aria-disabled\": a.value ?? void 0,\n      onClick: r[0] || (r[0] = (l) => n(e).onOpenChange(!n(e).open.value))\n    }), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"aria-disabled\"]));\n  }\n}), Bu = /* @__PURE__ */ b({\n  __name: \"ComboboxCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = $e();\n    function a() {\n      var s;\n      e.searchTerm.value = \"\", (s = e.inputElement.value) == null || s.focus();\n    }\n    return (s, r) => (h(), C(n(D), T({\n      type: s.as === \"button\" ? \"button\" : void 0\n    }, t, {\n      tabindex: \"-1\",\n      onClick: a\n    }), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), [zn, Ir] = H(\"ComboboxGroup\"), Su = /* @__PURE__ */ b({\n  __name: \"ComboboxGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { currentRef: e, currentElement: a } = $(), s = te(), r = $e(), l = P(false);\n    function i() {\n      if (!a.value)\n        return;\n      const u = a.value.querySelectorAll(\"[data-radix-vue-combobox-item]:not([data-hidden])\");\n      l.value = !!u.length;\n    }\n    return fs(a, () => {\n      i();\n    }, { childList: true }), U(() => r.searchTerm.value, () => {\n      G(() => {\n        i();\n      });\n    }, { immediate: true }), Ir({\n      id: s\n    }), (u, d) => fo((h(), C(n(D), T(t, {\n      ref_key: \"currentRef\",\n      ref: e,\n      role: \"group\",\n      \"aria-labelledby\": n(s)\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"])), [\n      [_n, l.value]\n    ]);\n  }\n}), Tu = /* @__PURE__ */ b({\n  __name: \"ComboboxLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = zn({ id: \"\" });\n    return (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).id\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), [Ar, Rr] = H(\"ComboboxContent\"), Mr = /* @__PURE__ */ b({\n  __name: \"ComboboxContentImpl\",\n  props: {\n    position: { default: \"inline\" },\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean, default: true },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { position: s } = z(e), r = $e();\n    ct(e.bodyLock);\n    const { forwardRef: l, currentElement: i } = $();\n    pt(i);\n    const u = S(() => e.position === \"popper\" ? e : {}), d = He(u.value);\n    function p(f) {\n      r.onSelectedValueChange(\"\");\n    }\n    q(() => {\n      r.onContentElementChange(i.value);\n    });\n    const c = {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-combobox-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-combobox-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-combobox-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-combobox-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-combobox-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    };\n    return Rr({ position: s }), (f, v) => (h(), C(n(So), null, {\n      default: m(() => [\n        f.dismissable ? (h(), C(n(De), {\n          key: 0,\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": f.disableOutsidePointerEvents,\n          onDismiss: v[0] || (v[0] = (g) => n(r).onOpenChange(false)),\n          onFocusOutside: v[1] || (v[1] = (g) => {\n            var w;\n            (w = n(r).parentElement.value) != null && w.contains(g.target) && g.preventDefault(), a(\"focusOutside\", g);\n          }),\n          onInteractOutside: v[2] || (v[2] = (g) => a(\"interactOutside\", g)),\n          onEscapeKeyDown: v[3] || (v[3] = (g) => a(\"escapeKeyDown\", g)),\n          onPointerDownOutside: v[4] || (v[4] = (g) => {\n            var w;\n            (w = n(r).parentElement.value) != null && w.contains(g.target) && g.preventDefault(), a(\"pointerDownOutside\", g);\n          })\n        }, {\n          default: m(() => [\n            (h(), C(we(n(s) === \"popper\" ? n(Fe) : n(D)), T({ ...f.$attrs, ...n(d) }, {\n              id: n(r).contentId,\n              ref: n(l),\n              role: \"listbox\",\n              \"data-state\": n(r).open.value ? \"open\" : \"closed\",\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\",\n                ...n(s) === \"popper\" ? c : {}\n              },\n              onPointerleave: p\n            }), {\n              default: m(() => [\n                y(f.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"style\"]))\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])) : (h(), C(we(n(s) === \"popper\" ? n(Fe) : n(D)), T({ key: 1 }, { ...f.$attrs, ...u.value }, {\n          id: n(r).contentId,\n          ref: n(l),\n          role: \"listbox\",\n          \"data-state\": n(r).open.value ? \"open\" : \"closed\",\n          style: {\n            // flex layout so we can place the scroll buttons properly\n            display: \"flex\",\n            flexDirection: \"column\",\n            // reset the outline by default as the content MAY get focused\n            outline: \"none\",\n            ...n(s) === \"popper\" ? c : {}\n          },\n          onPointerleave: p\n        }), {\n          default: m(() => [\n            y(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"data-state\", \"style\"]))\n      ]),\n      _: 3\n    }));\n  }\n}), Du = /* @__PURE__ */ b({\n  __name: \"ComboboxContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t), { forwardRef: r } = $(), l = $e();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(l).open.value\n    }, {\n      default: m(() => [\n        k(Mr, T({ ...n(s), ...i.$attrs }, { ref: n(r) }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Ou = /* @__PURE__ */ b({\n  __name: \"ComboboxEmpty\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = $e(), a = S(() => e.filteredOptions.value.length === 0);\n    return (s, r) => a.value ? (h(), C(n(D), L(T({ key: 0 }, t)), {\n      default: m(() => [\n        y(s.$slots, \"default\", {}, () => [\n          ue(\"No options\")\n        ])\n      ]),\n      _: 3\n    }, 16)) : X(\"\", true);\n  }\n}), Iu = /* @__PURE__ */ b({\n  __name: \"ComboboxViewport\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $();\n    return (a, s) => (h(), Q(le, null, [\n      k(n(D), T({ ...a.$attrs, ...t }, {\n        ref: n(e),\n        \"data-radix-combobox-viewport\": \"\",\n        role: \"presentation\",\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        }\n      }), {\n        default: m(() => [\n          y(a.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"]),\n      k(n(D), { as: \"style\" }, {\n        default: m(() => [\n          ue(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-combobox-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      })\n    ], 64));\n  }\n}), [kr, Vr] = H(\"ComboboxItem\"), Fr = \"combobox.select\", Au = /* @__PURE__ */ b({\n  __name: \"ComboboxItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { disabled: s } = z(e), r = $e();\n    zn({ id: \"\", options: P([]) });\n    const { forwardRef: l } = $(), i = S(\n      () => {\n        var g, w;\n        return r.multiple.value && Array.isArray(r.modelValue.value) ? (g = r.modelValue.value) == null ? void 0 : g.some((E) => Ge(E, e.value)) : Ge((w = r.modelValue) == null ? void 0 : w.value, e.value);\n      }\n    ), u = S(() => Ge(r.selectedValue.value, e.value)), d = te(), p = S(() => r.isUserInputted.value ? r.searchTerm.value === \"\" || !!r.filteredOptions.value.find((g) => Ge(g, e.value)) : true);\n    async function c(g) {\n      a(\"select\", g), !(g != null && g.defaultPrevented) && !s.value && g && r.onValueChange(e.value);\n    }\n    function f(g) {\n      if (!g)\n        return;\n      const w = { originalEvent: g, value: e.value };\n      vo(Fr, c, w);\n    }\n    async function v(g) {\n      await G(), !g.defaultPrevented && r.onSelectedValueChange(e.value);\n    }\n    if (e.value === \"\")\n      throw new Error(\n        \"A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return Vr({\n      isSelected: i\n    }), (g, w) => (h(), C(n(To), null, {\n      default: m(() => [\n        fo(k(n(D), {\n          ref: n(l),\n          role: \"option\",\n          tabindex: \"-1\",\n          \"aria-labelledby\": n(d),\n          \"data-highlighted\": u.value ? \"\" : void 0,\n          \"aria-selected\": i.value,\n          \"data-state\": i.value ? \"checked\" : \"unchecked\",\n          \"aria-disabled\": n(s) || void 0,\n          \"data-disabled\": n(s) ? \"\" : void 0,\n          as: g.as,\n          \"as-child\": g.asChild,\n          \"data-hidden\": p.value ? void 0 : true,\n          onClick: f,\n          onPointermove: v\n        }, {\n          default: m(() => [\n            y(g.$slots, \"default\", {}, () => [\n              ue(Le(g.value), 1)\n            ])\n          ]),\n          _: 3\n        }, 8, [\"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"as\", \"as-child\", \"data-hidden\"]), [\n          [_n, p.value]\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), Ru = /* @__PURE__ */ b({\n  __name: \"ComboboxItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = kr();\n    return (a, s) => n(e).isSelected.value ? (h(), C(n(D), T({\n      key: 0,\n      \"aria-hidden\": \"\"\n    }, t), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", true);\n  }\n}), Mu = /* @__PURE__ */ b({\n  __name: \"ComboboxSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(D), T(t, { \"aria-hidden\": \"\" }), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ku = /* @__PURE__ */ b({\n  __name: \"ComboboxArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const t = o2, e = $e(), a = Ar();\n    return $(), (s, r) => n(e).open.value && n(a).position.value === \"popper\" ? (h(), C(n(Ze), L(T({ key: 0 }, t)), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", true);\n  }\n}), Vu = /* @__PURE__ */ b({\n  __name: \"ComboboxPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Rt = /* @__PURE__ */ b({\n  __name: \"MenuAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(We), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Do = /* @__PURE__ */ b({\n  __name: \"MenuArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Ze), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [ze, Un] = H([\"MenuRoot\", \"MenuSub\"], \"MenuContext\"), [ft, Lr] = H(\"MenuRoot\"), Oo = /* @__PURE__ */ b({\n  __name: \"MenuRoot\",\n  props: {\n    open: { type: Boolean, default: false },\n    dir: {},\n    modal: { type: Boolean, default: true }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { modal: s, dir: r } = z(e), l = de(r), i = Y(e, \"open\", a), u = P(), d = P(false);\n    return ee((p) => {\n      if (!_e)\n        return;\n      const c = () => {\n        d.value = true, document.addEventListener(\"pointerdown\", f, {\n          capture: true,\n          once: true\n        }), document.addEventListener(\"pointermove\", f, {\n          capture: true,\n          once: true\n        });\n      }, f = () => d.value = false;\n      document.addEventListener(\"keydown\", c, { capture: true }), p(() => {\n        document.removeEventListener(\"keydown\", c, { capture: true }), document.removeEventListener(\"pointerdown\", f, {\n          capture: true\n        }), document.removeEventListener(\"pointermove\", f, {\n          capture: true\n        });\n      });\n    }), Un({\n      open: i,\n      onOpenChange: (p) => {\n        i.value = p;\n      },\n      content: u,\n      onContentChange: (p) => {\n        u.value = p;\n      }\n    }), Lr({\n      onClose: () => {\n        i.value = false;\n      },\n      isUsingKeyboardRef: d,\n      dir: l,\n      modal: s\n    }), (p, c) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(p.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Kr = \"rovingFocusGroup.onEntryFocus\", Nr = { bubbles: false, cancelable: true }, Hr = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction jr(o2, t) {\n  return t !== \"rtl\" ? o2 : o2 === \"ArrowLeft\" ? \"ArrowRight\" : o2 === \"ArrowRight\" ? \"ArrowLeft\" : o2;\n}\nfunction Wr(o2, t, e) {\n  const a = jr(o2.key, e);\n  if (!(t === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(a)) && !(t === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(a)))\n    return Hr[a];\n}\nfunction qn(o2) {\n  const t = document.activeElement;\n  for (const e of o2)\n    if (e === t || (e.focus(), document.activeElement !== t))\n      return;\n}\nfunction zr(o2, t) {\n  return o2.map((e, a) => o2[(t + a) % o2.length]);\n}\nconst [Ur, qr] = H(\"RovingFocusGroup\"), et = /* @__PURE__ */ b({\n  __name: \"RovingFocusGroup\",\n  props: {\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: false },\n    currentTabStopId: {},\n    defaultCurrentTabStopId: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"entryFocus\", \"update:currentTabStopId\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { loop: s, orientation: r, dir: l } = z(e), i = de(l), u = Y(e, \"currentTabStopId\", a, {\n      defaultValue: e.defaultCurrentTabStopId,\n      passive: e.currentTabStopId === void 0\n    }), d = P(false), p = P(false), c = P(0), { forwardRef: f, currentElement: v } = $(), { createCollection: g } = ve(\"rovingFocus\"), w = g(v);\n    function E(_) {\n      const x = !p.value;\n      if (_.currentTarget && _.target === _.currentTarget && x && !d.value) {\n        const B = new CustomEvent(Kr, Nr);\n        if (_.currentTarget.dispatchEvent(B), a(\"entryFocus\", B), !B.defaultPrevented) {\n          const O = w.value, A = O.find((V) => V.getAttribute(\"data-active\") === \"true\"), M = O.find(\n            (V) => V.id === u.value\n          ), R = [A, M, ...O].filter(\n            Boolean\n          );\n          qn(R);\n        }\n      }\n      p.value = false;\n    }\n    return qr({\n      loop: s,\n      dir: i,\n      orientation: r,\n      currentTabStopId: u,\n      onItemFocus: (_) => {\n        u.value = _;\n      },\n      onItemShiftTab: () => {\n        d.value = true;\n      },\n      onFocusableItemAdd: () => {\n        c.value++;\n      },\n      onFocusableItemRemove: () => {\n        c.value--;\n      }\n    }), (_, x) => (h(), C(n(D), {\n      ref: n(f),\n      tabindex: d.value || c.value === 0 ? -1 : 0,\n      \"data-orientation\": n(r),\n      as: _.as,\n      \"as-child\": _.asChild,\n      dir: n(i),\n      style: { outline: \"none\" },\n      onMousedown: x[0] || (x[0] = (B) => p.value = true),\n      onFocus: E,\n      onBlur: x[1] || (x[1] = (B) => d.value = false)\n    }, {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"tabindex\", \"data-orientation\", \"as\", \"as-child\", \"dir\"]));\n  }\n}), tt = /* @__PURE__ */ b({\n  __name: \"RovingFocusItem\",\n  props: {\n    tabStopId: {},\n    focusable: { type: Boolean, default: true },\n    active: { type: Boolean, default: true },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = o2, e = Ur(), a = te(), s = S(() => t.tabStopId || a), r = S(\n      () => e.currentTabStopId.value === s.value\n    ), { injectCollection: l } = ve(\"rovingFocus\"), i = l();\n    q(() => {\n      t.focusable && e.onFocusableItemAdd();\n    }), fe(() => {\n      t.focusable && e.onFocusableItemRemove();\n    });\n    function u(d) {\n      if (d.key === \"Tab\" && d.shiftKey) {\n        e.onItemShiftTab();\n        return;\n      }\n      if (d.target !== d.currentTarget)\n        return;\n      const p = Wr(\n        d,\n        e.orientation.value,\n        e.dir.value\n      );\n      if (p !== void 0) {\n        d.preventDefault();\n        let c = [...i.value];\n        if (p === \"last\")\n          c.reverse();\n        else if (p === \"prev\" || p === \"next\") {\n          p === \"prev\" && c.reverse();\n          const f = c.indexOf(\n            d.currentTarget\n          );\n          c = e.loop.value ? zr(c, f + 1) : c.slice(f + 1);\n        }\n        G(() => qn(c));\n      }\n    }\n    return (d, p) => (h(), C(n(D), {\n      \"data-radix-vue-collection-item\": \"\",\n      tabindex: r.value ? 0 : -1,\n      \"data-orientation\": n(e).orientation.value,\n      \"data-active\": d.active,\n      \"data-disabled\": !d.focusable || void 0,\n      as: d.as,\n      \"as-child\": d.asChild,\n      onMousedown: p[0] || (p[0] = (c) => {\n        d.focusable ? n(e).onItemFocus(s.value) : c.preventDefault();\n      }),\n      onFocus: p[1] || (p[1] = (c) => n(e).onItemFocus(s.value)),\n      onKeydown: u\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"tabindex\", \"data-orientation\", \"data-active\", \"data-disabled\", \"as\", \"as-child\"]));\n  }\n}), [Io, Gr] = H(\"MenuContent\"), Ao = /* @__PURE__ */ b({\n  __name: \"MenuContentImpl\",\n  props: /* @__PURE__ */ wn({\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...Hn\n  }),\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\", \"dismiss\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = ze(), r = ft(), { trapFocus: l, disableOutsidePointerEvents: i, loop: u } = z(e);\n    yo(), ct(i.value);\n    const d = P(\"\"), p = P(0), c = P(0), f = P(null), v = P(\"right\"), g = P(0), w = P(null), { createCollection: E } = ve(), { forwardRef: _, currentElement: x } = $(), B = E(x);\n    U(x, (I) => {\n      s.onContentChange(I);\n    });\n    const { handleTypeaheadSearch: O } = bo(B);\n    fe(() => {\n      window.clearTimeout(p.value);\n    });\n    function A(I) {\n      var W, J;\n      return v.value === ((W = f.value) == null ? void 0 : W.side) && nr(I, (J = f.value) == null ? void 0 : J.area);\n    }\n    async function M(I) {\n      var F;\n      a(\"openAutoFocus\", I), !I.defaultPrevented && (I.preventDefault(), (F = x.value) == null || F.focus());\n    }\n    function R(I) {\n      if (I.defaultPrevented)\n        return;\n      const W = I.target.closest(\"[data-radix-menu-content]\") === I.currentTarget, J = I.ctrlKey || I.altKey || I.metaKey, K = I.key.length === 1, Z = Je(\n        I,\n        document.activeElement,\n        x.value,\n        {\n          loop: u.value,\n          arrowKeyOptions: \"vertical\",\n          dir: r == null ? void 0 : r.dir.value,\n          focus: true,\n          attributeName: \"[data-radix-vue-collection-item]:not([data-disabled])\"\n        }\n      );\n      if (Z)\n        return Z == null ? void 0 : Z.focus();\n      if (I.code === \"Space\" || (W && (I.key === \"Tab\" && I.preventDefault(), !J && K && O(I.key)), I.target !== x.value) || !Qs.includes(I.key))\n        return;\n      I.preventDefault();\n      const ne = B.value;\n      kn.includes(I.key) && ne.reverse(), ao(ne);\n    }\n    function V(I) {\n      var F, W;\n      (W = (F = I == null ? void 0 : I.currentTarget) == null ? void 0 : F.contains) != null && W.call(F, I.target) || (window.clearTimeout(p.value), d.value = \"\");\n    }\n    function j(I) {\n      var J;\n      if (!rt(I))\n        return;\n      const F = I.target, W = g.value !== I.clientX;\n      if ((J = I == null ? void 0 : I.currentTarget) != null && J.contains(F) && W) {\n        const K = I.clientX > g.value ? \"right\" : \"left\";\n        v.value = K, g.value = I.clientX;\n      }\n    }\n    return Gr({\n      onItemEnter: (I) => !!A(I),\n      onItemLeave: (I) => {\n        var F;\n        A(I) || ((F = x.value) == null || F.focus(), w.value = null);\n      },\n      onTriggerLeave: (I) => !!A(I),\n      searchRef: d,\n      pointerGraceTimerRef: c,\n      onPointerGraceIntentChange: (I) => {\n        f.value = I;\n      }\n    }), (I, F) => (h(), C(n(At), {\n      \"as-child\": \"\",\n      trapped: n(l),\n      onMountAutoFocus: M,\n      onUnmountAutoFocus: F[7] || (F[7] = (W) => a(\"closeAutoFocus\", W))\n    }, {\n      default: m(() => [\n        k(n(De), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": n(i),\n          onEscapeKeyDown: F[2] || (F[2] = (W) => a(\"escapeKeyDown\", W)),\n          onPointerDownOutside: F[3] || (F[3] = (W) => a(\"pointerDownOutside\", W)),\n          onFocusOutside: F[4] || (F[4] = (W) => a(\"focusOutside\", W)),\n          onInteractOutside: F[5] || (F[5] = (W) => a(\"interactOutside\", W)),\n          onDismiss: F[6] || (F[6] = (W) => a(\"dismiss\"))\n        }, {\n          default: m(() => [\n            k(n(et), {\n              \"current-tab-stop-id\": w.value,\n              \"onUpdate:currentTabStopId\": F[0] || (F[0] = (W) => w.value = W),\n              \"as-child\": \"\",\n              orientation: \"vertical\",\n              dir: n(r).dir.value,\n              loop: n(u),\n              onEntryFocus: F[1] || (F[1] = (W) => {\n                a(\"entryFocus\", W), n(r).isUsingKeyboardRef.value || W.preventDefault();\n              })\n            }, {\n              default: m(() => [\n                k(n(Fe), {\n                  ref: n(_),\n                  role: \"menu\",\n                  as: I.as,\n                  \"as-child\": I.asChild,\n                  \"aria-orientation\": \"vertical\",\n                  \"data-radix-menu-content\": \"\",\n                  \"data-state\": n(xo)(n(s).open.value),\n                  dir: n(r).dir.value,\n                  side: I.side,\n                  \"side-offset\": I.sideOffset,\n                  align: I.align,\n                  \"align-offset\": I.alignOffset,\n                  \"avoid-collisions\": I.avoidCollisions,\n                  \"collision-boundary\": I.collisionBoundary,\n                  \"collision-padding\": I.collisionPadding,\n                  \"arrow-padding\": I.arrowPadding,\n                  \"prioritize-position\": I.prioritizePosition,\n                  sticky: I.sticky,\n                  \"hide-when-detached\": I.hideWhenDetached,\n                  onKeydown: R,\n                  onBlur: V,\n                  onPointermove: j\n                }, {\n                  default: m(() => [\n                    y(I.$slots, \"default\")\n                  ]),\n                  _: 3\n                }, 8, [\"as\", \"as-child\", \"data-state\", \"dir\", \"side\", \"side-offset\", \"align\", \"align-offset\", \"avoid-collisions\", \"collision-boundary\", \"collision-padding\", \"arrow-padding\", \"prioritize-position\", \"sticky\", \"hide-when-detached\"])\n              ]),\n              _: 3\n            }, 8, [\"current-tab-stop-id\", \"dir\", \"loop\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), Gn = /* @__PURE__ */ b({\n  __name: \"MenuItemImpl\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = Io(), a = P(false);\n    async function s(l) {\n      if (!l.defaultPrevented && rt(l)) {\n        if (t.disabled)\n          e.onItemLeave(l);\n        else if (!e.onItemEnter(l)) {\n          const u = l.currentTarget;\n          u == null || u.focus();\n        }\n      }\n    }\n    async function r(l) {\n      await G(), !l.defaultPrevented && rt(l) && e.onItemLeave(l);\n    }\n    return (l, i) => (h(), C(n(D), {\n      role: \"menuitem\",\n      tabindex: \"-1\",\n      as: l.as,\n      \"as-child\": l.asChild,\n      \"data-radix-vue-collection-item\": \"\",\n      \"aria-disabled\": l.disabled || void 0,\n      \"data-disabled\": l.disabled ? \"\" : void 0,\n      \"data-highlighted\": a.value ? \"\" : void 0,\n      onPointermove: s,\n      onPointerleave: r,\n      onFocus: i[0] || (i[0] = async (u) => {\n        await G(), !(u.defaultPrevented || l.disabled) && (a.value = true);\n      }),\n      onBlur: i[1] || (i[1] = async (u) => {\n        await G(), !u.defaultPrevented && (a.value = false);\n      })\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-disabled\", \"data-disabled\", \"data-highlighted\"]));\n  }\n}), vt = /* @__PURE__ */ b({\n  __name: \"MenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { forwardRef: s, currentElement: r } = $(), l = ft(), i = Io(), u = P(false);\n    async function d() {\n      const p = r.value;\n      if (!e.disabled && p) {\n        const c = new CustomEvent(Js, {\n          bubbles: true,\n          cancelable: true\n        });\n        a(\"select\", c), await G(), c.defaultPrevented ? u.value = false : l.onClose();\n      }\n    }\n    return (p, c) => (h(), C(Gn, T(e, {\n      ref: n(s),\n      onClick: d,\n      onPointerdown: c[0] || (c[0] = () => {\n        u.value = true;\n      }),\n      onPointerup: c[1] || (c[1] = async (f) => {\n        var v;\n        await G(), !f.defaultPrevented && (u.value || (v = f.currentTarget) == null || v.click());\n      }),\n      onKeydown: c[2] || (c[2] = async (f) => {\n        const v = n(i).searchRef.value !== \"\";\n        p.disabled || v && f.key === \" \" || n(no).includes(f.key) && (f.currentTarget.click(), f.preventDefault());\n      })\n    }), {\n      default: m(() => [\n        y(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Yr, Yn] = H(\n  [\"MenuCheckboxItem\", \"MenuRadioItem\"],\n  \"MenuItemIndicatorContext\"\n), Ro = /* @__PURE__ */ b({\n  __name: \"MenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = Yr({\n      checked: P(false)\n    });\n    return (e, a) => (h(), C(n(se), {\n      present: e.forceMount || n(Pt)(n(t).checked.value) || n(t).checked.value === true\n    }, {\n      default: m(() => [\n        k(n(D), {\n          as: e.as,\n          \"as-child\": e.asChild,\n          \"data-state\": n(Eo)(n(t).checked.value)\n        }, {\n          default: m(() => [\n            y(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Mo = /* @__PURE__ */ b({\n  __name: \"MenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String], default: false },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = Y(e, \"checked\", a);\n    return Yn({ checked: s }), (r, l) => (h(), C(vt, T({ role: \"menuitemcheckbox\" }, e, {\n      \"aria-checked\": n(Pt)(n(s)) ? \"mixed\" : n(s),\n      \"data-state\": n(Eo)(n(s)),\n      onSelect: l[0] || (l[0] = async (i) => {\n        a(\"select\", i), n(Pt)(n(s)) ? s.value = true : s.value = !n(s);\n      })\n    }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), Xr = /* @__PURE__ */ b({\n  __name: \"MenuRootContentModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = ae(e, a), r = ze(), { forwardRef: l, currentElement: i } = $();\n    return pt(i), (u, d) => (h(), C(Ao, T(n(s), {\n      ref: n(l),\n      \"trap-focus\": n(r).open.value,\n      \"disable-outside-pointer-events\": n(r).open.value,\n      \"disable-outside-scroll\": true,\n      onDismiss: d[0] || (d[0] = (p) => n(r).onOpenChange(false)),\n      onFocusOutside: d[1] || (d[1] = oe((p) => a(\"focusOutside\", p), [\"prevent\"]))\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\", \"disable-outside-pointer-events\"]));\n  }\n}), Jr = /* @__PURE__ */ b({\n  __name: \"MenuRootContentNonModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t), r = ze();\n    return (l, i) => (h(), C(Ao, T(n(s), {\n      \"trap-focus\": false,\n      \"disable-outside-pointer-events\": false,\n      \"disable-outside-scroll\": false,\n      onDismiss: i[0] || (i[0] = (u) => n(r).onOpenChange(false))\n    }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ko = /* @__PURE__ */ b({\n  __name: \"MenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t), r = ze(), l = ft();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(r).open.value\n    }, {\n      default: m(() => [\n        n(l).modal.value ? (h(), C(Xr, L(T({ key: 0 }, { ...i.$attrs, ...n(s) })), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (h(), C(Jr, L(T({ key: 1 }, { ...i.$attrs, ...n(s) })), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Mt = /* @__PURE__ */ b({\n  __name: \"MenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(D), T({ role: \"group\" }, t), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vo = /* @__PURE__ */ b({\n  __name: \"MenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(D), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Fo = /* @__PURE__ */ b({\n  __name: \"MenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Zr, Qr] = H(\"MenuRadioGroup\"), Lo = /* @__PURE__ */ b({\n  __name: \"MenuRadioGroup\",\n  props: {\n    modelValue: { default: \"\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = Y(e, \"modelValue\", t);\n    return Qr({\n      modelValue: s,\n      onValueChange: (r) => {\n        s.value = r;\n      }\n    }), (r, l) => (h(), C(Mt, L(N(e)), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ko = /* @__PURE__ */ b({\n  __name: \"MenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { value: s } = z(e), r = Zr(), l = S(\n      () => r.modelValue.value === (s == null ? void 0 : s.value)\n    );\n    return Yn({ checked: l }), (i, u) => (h(), C(vt, T({ role: \"menuitemradio\" }, e, {\n      \"aria-checked\": l.value,\n      \"data-state\": n(Eo)(l.value),\n      onSelect: u[0] || (u[0] = async (d) => {\n        a(\"select\", d), n(r).onValueChange(n(s));\n      })\n    }), {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), No = /* @__PURE__ */ b({\n  __name: \"MenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(D), T(t, {\n      role: \"separator\",\n      \"aria-orientation\": \"horizontal\"\n    }), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Xn, el] = H(\"MenuSub\"), Ho = /* @__PURE__ */ b({\n  __name: \"MenuSub\",\n  props: {\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = Y(e, \"open\", t, {\n      defaultValue: false,\n      passive: e.open === void 0\n    }), r = ze(), l = P(), i = P();\n    return ee((u) => {\n      (r == null ? void 0 : r.open.value) === false && (s.value = false), u(() => s.value = false);\n    }), Un({\n      open: s,\n      onOpenChange: (u) => {\n        s.value = u;\n      },\n      content: i,\n      onContentChange: (u) => {\n        i.value = u;\n      }\n    }), el({\n      triggerId: te(),\n      contentId: te(),\n      trigger: l,\n      onTriggerChange: (u) => {\n        l.value = u;\n      }\n    }), (u, d) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), jo = /* @__PURE__ */ b({\n  __name: \"MenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean, default: true },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t), r = ze(), l = ft(), i = Xn(), { forwardRef: u, currentElement: d } = $();\n    return (p, c) => (h(), C(n(se), {\n      present: p.forceMount || n(r).open.value\n    }, {\n      default: m(() => [\n        k(Ao, T(n(s), {\n          id: n(i).contentId,\n          ref: n(u),\n          \"aria-labelledby\": n(i).triggerId,\n          align: \"start\",\n          side: n(l).dir.value === \"rtl\" ? \"left\" : \"right\",\n          \"disable-outside-pointer-events\": false,\n          \"disable-outside-scroll\": false,\n          \"trap-focus\": false,\n          onOpenAutoFocus: c[0] || (c[0] = oe((f) => {\n            var v;\n            n(l).isUsingKeyboardRef.value && ((v = n(d)) == null || v.focus());\n          }, [\"prevent\"])),\n          onCloseAutoFocus: c[1] || (c[1] = oe(() => {\n          }, [\"prevent\"])),\n          onFocusOutside: c[2] || (c[2] = (f) => {\n            f.defaultPrevented || f.target !== n(i).trigger.value && n(r).onOpenChange(false);\n          }),\n          onEscapeKeyDown: c[3] || (c[3] = (f) => {\n            n(l).onClose(), f.preventDefault();\n          }),\n          onKeydown: c[4] || (c[4] = (f) => {\n            var w, E;\n            const v = (w = f.currentTarget) == null ? void 0 : w.contains(f.target), g = n(tr)[n(l).dir.value].includes(f.key);\n            v && g && (n(r).onOpenChange(false), (E = n(i).trigger.value) == null || E.focus(), f.preventDefault());\n          })\n        }), {\n          default: m(() => [\n            y(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-labelledby\", \"side\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Wo = /* @__PURE__ */ b({\n  __name: \"MenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = ze(), a = ft(), s = Xn(), r = Io(), l = P(null);\n    function i() {\n      l.value && window.clearTimeout(l.value), l.value = null;\n    }\n    fe(() => {\n      i();\n    });\n    function u(c) {\n      !rt(c) || r.onItemEnter(c) || !t.disabled && !e.open.value && !l.value && (r.onPointerGraceIntentChange(null), l.value = window.setTimeout(() => {\n        e.onOpenChange(true), i();\n      }, 100));\n    }\n    async function d(c) {\n      var v, g;\n      if (!rt(c))\n        return;\n      i();\n      const f = (v = e.content.value) == null ? void 0 : v.getBoundingClientRect();\n      if (f != null && f.width) {\n        const w = (g = e.content.value) == null ? void 0 : g.dataset.side, E = w === \"right\", _ = E ? -5 : 5, x = f[E ? \"left\" : \"right\"], B = f[E ? \"right\" : \"left\"];\n        r.onPointerGraceIntentChange({\n          area: [\n            // Apply a bleed on clientX to ensure that our exit point is\n            // consistently within polygon bounds\n            { x: c.clientX + _, y: c.clientY },\n            { x, y: f.top },\n            { x: B, y: f.top },\n            { x: B, y: f.bottom },\n            { x, y: f.bottom }\n          ],\n          side: w\n        }), window.clearTimeout(r.pointerGraceTimerRef.value), r.pointerGraceTimerRef.value = window.setTimeout(\n          () => r.onPointerGraceIntentChange(null),\n          300\n        );\n      } else {\n        if (r.onTriggerLeave(c))\n          return;\n        r.onPointerGraceIntentChange(null);\n      }\n    }\n    async function p(c) {\n      var v;\n      const f = r.searchRef.value !== \"\";\n      t.disabled || f && c.key === \" \" || er[a.dir.value].includes(c.key) && (e.onOpenChange(true), await G(), (v = e.content.value) == null || v.focus(), c.preventDefault());\n    }\n    return (c, f) => (h(), C(Rt, { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(Gn, T(t, {\n          id: n(s).triggerId,\n          ref: (v) => {\n            var g;\n            (g = n(s)) == null || g.onTriggerChange(v == null ? void 0 : v.$el);\n          },\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": n(e).open.value,\n          \"aria-controls\": n(s).contentId,\n          \"data-state\": n(xo)(n(e).open.value),\n          onClick: f[0] || (f[0] = async (v) => {\n            t.disabled || v.defaultPrevented || (v.currentTarget.focus(), n(e).open.value || n(e).onOpenChange(true));\n          }),\n          onPointermove: u,\n          onPointerleave: d,\n          onKeydown: p\n        }), {\n          default: m(() => [\n            y(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-expanded\", \"aria-controls\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), [Jn, tl] = H(\"ContextMenuRoot\"), Fu = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"ContextMenuRoot\",\n  props: {\n    dir: {},\n    modal: { type: Boolean, default: true }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { dir: s, modal: r } = z(e);\n    $();\n    const l = de(s), i = P(false);\n    return tl({\n      open: i,\n      onOpenChange: (u) => {\n        i.value = u;\n      },\n      dir: l,\n      modal: r\n    }), U(i, (u) => {\n      a(\"update:open\", u);\n    }), (u, d) => (h(), C(n(Oo), {\n      open: i.value,\n      \"onUpdate:open\": d[0] || (d[0] = (p) => i.value = p),\n      dir: n(l),\n      modal: n(r)\n    }, {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n});\nfunction un(o2) {\n  return o2.pointerType !== \"mouse\";\n}\nconst Lu = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"ContextMenuTrigger\",\n  props: {\n    disabled: { type: Boolean, default: false },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = o2, { disabled: e } = z(t), { forwardRef: a } = $(), s = Jn(), r = P({ x: 0, y: 0 }), l = S(() => ({\n      getBoundingClientRect: () => ({\n        width: 0,\n        height: 0,\n        left: r.value.x,\n        right: r.value.x,\n        top: r.value.y,\n        bottom: r.value.y,\n        ...r.value\n      })\n    })), i = P(0);\n    function u() {\n      window.clearTimeout(i.value);\n    }\n    function d(v) {\n      r.value = { x: v.clientX, y: v.clientY }, s.onOpenChange(true);\n    }\n    async function p(v) {\n      e.value || (await G(), v.defaultPrevented || (u(), d(v), v.preventDefault()));\n    }\n    async function c(v) {\n      e.value || (await G(), un(v) && !v.defaultPrevented && (u(), i.value = window.setTimeout(() => d(v), 700)));\n    }\n    async function f(v) {\n      e.value || (await G(), un(v) && !v.defaultPrevented && u());\n    }\n    return (v, g) => (h(), Q(le, null, [\n      k(n(Rt), {\n        as: \"template\",\n        element: l.value\n      }, null, 8, [\"element\"]),\n      k(n(D), T({\n        ref: n(a),\n        as: v.as,\n        \"as-child\": v.asChild,\n        \"data-state\": n(s).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": n(e) ? \"\" : void 0,\n        style: {\n          WebkitTouchCallout: \"none\"\n        }\n      }, v.$attrs, {\n        onContextmenu: p,\n        onPointerdown: c,\n        onPointermove: f,\n        onPointercancel: f,\n        onPointerup: f\n      }), {\n        default: m(() => [\n          y(v.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"])\n    ], 64));\n  }\n}), Ku = /* @__PURE__ */ b({\n  __name: \"ContextMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Fo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nu = /* @__PURE__ */ b({\n  __name: \"ContextMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    alignOffset: { default: 0 },\n    avoidCollisions: { type: Boolean, default: true },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: false },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t);\n    $();\n    const r = Jn(), l = P(false);\n    return (i, u) => (h(), C(n(ko), T(n(s), {\n      side: \"right\",\n      \"side-offset\": 2,\n      align: \"start\",\n      style: {\n        \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: u[0] || (u[0] = (d) => {\n        !d.defaultPrevented && l.value && d.preventDefault(), l.value = false;\n      }),\n      onInteractOutside: u[1] || (u[1] = (d) => {\n        !d.defaultPrevented && !n(r).modal.value && (l.value = true);\n      })\n    }), {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), Hu = /* @__PURE__ */ b({\n  __name: \"ContextMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Do), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ju = /* @__PURE__ */ b({\n  __name: \"ContextMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(vt), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Wu = /* @__PURE__ */ b({\n  __name: \"ContextMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Mt), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), zu = /* @__PURE__ */ b({\n  __name: \"ContextMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(No), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Uu = /* @__PURE__ */ b({\n  __name: \"ContextMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Mo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), qu = /* @__PURE__ */ b({\n  __name: \"ContextMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Ro), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Gu = /* @__PURE__ */ b({\n  __name: \"ContextMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Vo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Yu = /* @__PURE__ */ b({\n  __name: \"ContextMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Lo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xu = /* @__PURE__ */ b({\n  __name: \"ContextMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Ko), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ju = /* @__PURE__ */ b({\n  __name: \"ContextMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t;\n    $();\n    const s = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (r, l) => (h(), C(n(Ho), {\n      open: n(s),\n      \"onUpdate:open\": l[0] || (l[0] = (i) => dt(s) ? s.value = i : null)\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), Zu = /* @__PURE__ */ b({\n  __name: \"ContextMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t);\n    return $(), (r, l) => (h(), C(n(jo), T(n(s), { style: {\n      \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), Qu = /* @__PURE__ */ b({\n  __name: \"ContextMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Wo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Zn, ol] = H(\"DropdownMenuRoot\"), ed = /* @__PURE__ */ b({\n  __name: \"DropdownMenuRoot\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 },\n    dir: {},\n    modal: { type: Boolean, default: true }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t;\n    $();\n    const s = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = P(), { modal: l, dir: i } = z(e), u = de(i);\n    return ol({\n      open: s,\n      onOpenChange: (d) => {\n        s.value = d;\n      },\n      onOpenToggle: () => {\n        s.value = !s.value;\n      },\n      triggerId: te(),\n      triggerElement: r,\n      contentId: te(),\n      modal: l,\n      dir: u\n    }), (d, p) => (h(), C(n(Oo), {\n      open: n(s),\n      \"onUpdate:open\": p[0] || (p[0] = (c) => dt(s) ? s.value = c : null),\n      dir: n(u),\n      modal: n(l)\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n}), td = /* @__PURE__ */ b({\n  __name: \"DropdownMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = Zn(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.triggerElement = s;\n    }), (r, l) => (h(), C(n(Rt), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), {\n          id: n(e).triggerId,\n          ref: n(a),\n          type: r.as === \"button\" ? \"button\" : void 0,\n          \"as-child\": t.asChild,\n          as: r.as,\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": n(e).open.value,\n          \"aria-controls\": n(e).open.value ? n(e).contentId : void 0,\n          \"data-disabled\": r.disabled ? \"\" : void 0,\n          disabled: r.disabled,\n          \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n          onClick: l[0] || (l[0] = async (i) => {\n            var u;\n            !r.disabled && i.button === 0 && i.ctrlKey === false && ((u = n(e)) == null || u.onOpenToggle(), await G(), n(e).open.value && i.preventDefault());\n          }),\n          onKeydown: l[1] || (l[1] = ie(\n            (i) => {\n              r.disabled || ([\"Enter\", \" \"].includes(i.key) && n(e).onOpenToggle(), i.key === \"ArrowDown\" && n(e).onOpenChange(true), [\"Enter\", \" \", \"ArrowDown\"].includes(i.key) && i.preventDefault());\n            },\n            [\"enter\", \"space\", \"arrow-down\"]\n          ))\n        }, {\n          default: m(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as-child\", \"as\", \"aria-expanded\", \"aria-controls\", \"data-disabled\", \"disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), od = /* @__PURE__ */ b({\n  __name: \"DropdownMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Fo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), nd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t);\n    $();\n    const r = Zn(), l = P(false);\n    function i(u) {\n      u.defaultPrevented || (l.value || setTimeout(() => {\n        var d;\n        (d = r.triggerElement.value) == null || d.focus();\n      }, 0), l.value = false, u.preventDefault());\n    }\n    return (u, d) => {\n      var p;\n      return h(), C(n(ko), T(n(s), {\n        id: n(r).contentId,\n        \"aria-labelledby\": (p = n(r)) == null ? void 0 : p.triggerId,\n        style: {\n          \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        },\n        onCloseAutoFocus: i,\n        onInteractOutside: d[0] || (d[0] = (c) => {\n          var w;\n          if (c.defaultPrevented)\n            return;\n          const f = c.detail.originalEvent, v = f.button === 0 && f.ctrlKey === true, g = f.button === 2 || v;\n          (!n(r).modal.value || g) && (l.value = true), (w = n(r).triggerElement.value) != null && w.contains(c.target) && c.preventDefault();\n        })\n      }), {\n        default: m(() => [\n          y(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"aria-labelledby\", \"style\"]);\n    };\n  }\n}), ad = /* @__PURE__ */ b({\n  __name: \"DropdownMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Do), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(vt), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Mt), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ld = /* @__PURE__ */ b({\n  __name: \"DropdownMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(No), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), id = /* @__PURE__ */ b({\n  __name: \"DropdownMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Mo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ud = /* @__PURE__ */ b({\n  __name: \"DropdownMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Ro), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Vo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), cd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Lo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), pd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t);\n    return $(), (r, l) => (h(), C(n(Ko), L(N(n(s))), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = Y(e, \"open\", t, {\n      passive: e.open === void 0,\n      defaultValue: e.defaultOpen ?? false\n    });\n    return $(), (r, l) => (h(), C(n(Ho), {\n      open: n(s),\n      \"onUpdate:open\": l[0] || (l[0] = (i) => dt(s) ? s.value = i : null)\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), vd = /* @__PURE__ */ b({\n  __name: \"DropdownMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t);\n    return $(), (r, l) => (h(), C(n(jo), T(n(s), { style: {\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), md = /* @__PURE__ */ b({\n  __name: \"DropdownMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Wo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [zo, nl] = H(\"HoverCardRoot\"), hd = /* @__PURE__ */ b({\n  __name: \"HoverCardRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: false },\n    open: { type: Boolean, default: void 0 },\n    openDelay: { default: 700 },\n    closeDelay: { default: 300 }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { openDelay: s, closeDelay: r } = z(e);\n    $();\n    const l = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), i = P(0), u = P(0), d = P(false), p = P(false);\n    function c() {\n      clearTimeout(u.value), i.value = window.setTimeout(() => l.value = true, s.value);\n    }\n    function f() {\n      clearTimeout(i.value), !d.value && !p.value && (u.value = window.setTimeout(() => l.value = false, r.value));\n    }\n    function v() {\n      l.value = false;\n    }\n    return nl({\n      open: l,\n      onOpenChange(g) {\n        l.value = g;\n      },\n      onOpen: c,\n      onClose: f,\n      onDismiss: v,\n      hasSelectionRef: d,\n      isPointerDownOnContentRef: p\n    }), (g, w) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(g.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n});\nfunction St(o2) {\n  return (t) => t.pointerType === \"touch\" ? void 0 : o2();\n}\nfunction al(o2) {\n  const t = [], e = document.createTreeWalker(o2, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (a) => a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  });\n  for (; e.nextNode(); )\n    t.push(e.currentNode);\n  return t;\n}\nconst gd = /* @__PURE__ */ b({\n  __name: \"HoverCardTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(o2) {\n    const { forwardRef: t } = $(), e = zo();\n    return (a, s) => (h(), C(n(We), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(t),\n          \"as-child\": a.asChild,\n          as: a.as,\n          \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n          onPointerenter: s[0] || (s[0] = (r) => n(St)(n(e).onOpen)(r)),\n          onPointerleave: s[1] || (s[1] = (r) => n(St)(n(e).onClose)(r)),\n          onFocus: s[2] || (s[2] = (r) => n(e).onOpen()),\n          onBlur: n(e).onClose,\n          onTouchstart: oe(() => {\n          }, [\"prevent\"])\n        }, {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"data-state\", \"onBlur\"])\n      ]),\n      _: 3\n    }));\n  }\n}), yd = /* @__PURE__ */ b({\n  __name: \"HoverCardPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sl = /* @__PURE__ */ b({\n  __name: \"HoverCardContentImpl\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = He(e), { forwardRef: r, currentElement: l } = $(), i = zo(), u = P(false);\n    let d;\n    ee((c) => {\n      if (u.value) {\n        const f = document.body;\n        d = f.style.userSelect || f.style.webkitUserSelect, f.style.userSelect = \"none\", f.style.webkitUserSelect = \"none\", c(() => {\n          f.style.userSelect = d, f.style.webkitUserSelect = d;\n        });\n      }\n    });\n    function p() {\n      u.value = false, i.isPointerDownOnContentRef.value = false, G(() => {\n        var f;\n        ((f = document.getSelection()) == null ? void 0 : f.toString()) !== \"\" && (i.hasSelectionRef.value = true);\n      });\n    }\n    return q(() => {\n      l.value && (document.addEventListener(\"pointerup\", p), al(l.value).forEach((f) => f.setAttribute(\"tabindex\", \"-1\")));\n    }), fe(() => {\n      document.removeEventListener(\"pointerup\", p), i.hasSelectionRef.value = false, i.isPointerDownOnContentRef.value = false;\n    }), (c, f) => (h(), C(n(De), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": false,\n      onEscapeKeyDown: f[1] || (f[1] = (v) => a(\"escapeKeyDown\", v)),\n      onPointerDownOutside: f[2] || (f[2] = (v) => a(\"pointerDownOutside\", v)),\n      onFocusOutside: f[3] || (f[3] = oe((v) => a(\"focusOutside\", v), [\"prevent\"])),\n      onDismiss: n(i).onDismiss\n    }, {\n      default: m(() => [\n        k(n(Fe), T({ ...n(s), ...c.$attrs }, {\n          ref: n(r),\n          \"data-state\": n(i).open.value ? \"open\" : \"closed\",\n          style: {\n            userSelect: u.value ? \"text\" : void 0,\n            // Safari requires prefix\n            WebkitUserSelect: u.value ? \"text\" : void 0,\n            // re-namespace exposed content custom properties\n            \"--radix-hover-card-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n            \"--radix-hover-card-content-available-width\": \"var(--radix-popper-available-width)\",\n            \"--radix-hover-card-content-available-height\": \"var(--radix-popper-available-height)\",\n            \"--radix-hover-card-trigger-width\": \"var(--radix-popper-anchor-width)\",\n            \"--radix-hover-card-trigger-height\": \"var(--radix-popper-anchor-height)\"\n          },\n          onPointerdown: f[0] || (f[0] = (v) => {\n            v.currentTarget.contains(v.target) && (u.value = true), n(i).hasSelectionRef.value = false, n(i).isPointerDownOnContentRef.value = true;\n          })\n        }), {\n          default: m(() => [\n            y(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"onDismiss\"]));\n  }\n}), bd = /* @__PURE__ */ b({\n  __name: \"HoverCardContent\",\n  props: {\n    forceMount: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t), { forwardRef: r } = $(), l = zo();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(l).open.value\n    }, {\n      default: m(() => [\n        k(sl, T(n(s), {\n          ref: n(r),\n          onPointerenter: u[0] || (u[0] = (d) => n(St)(n(l).onOpen)(d)),\n          onPointerleave: u[1] || (u[1] = (d) => n(St)(n(l).onClose)(d))\n        }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Cd = /* @__PURE__ */ b({\n  __name: \"HoverCardArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Ze), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), wd = /* @__PURE__ */ b({\n  __name: \"Label\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"label\" }\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(D), T(t, {\n      onMousedown: a[0] || (a[0] = (s) => {\n        !s.defaultPrevented && s.detail > 1 && s.preventDefault();\n      })\n    }), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [kt, rl] = H(\"MenubarRoot\"), _d = /* @__PURE__ */ b({\n  __name: \"MenubarRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    dir: {},\n    loop: { type: Boolean, default: false }\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { forwardRef: s, currentElement: r } = $(), { createCollection: l } = ve(\"menubar\");\n    l(r);\n    const i = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), u = P(null), { dir: d, loop: p } = z(e), c = de(d);\n    return rl({\n      modelValue: i,\n      dir: c,\n      loop: p,\n      onMenuOpen: (f) => {\n        i.value = f, u.value = f;\n      },\n      onMenuClose: () => {\n        i.value = \"\";\n      },\n      onMenuToggle: (f) => {\n        i.value = i.value ? \"\" : f, u.value = f;\n      }\n    }), (f, v) => (h(), C(n(et), {\n      \"current-tab-stop-id\": u.value,\n      \"onUpdate:currentTabStopId\": v[0] || (v[0] = (g) => u.value = g),\n      orientation: \"horizontal\",\n      loop: n(p),\n      dir: n(c),\n      \"as-child\": \"\"\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(s),\n          role: \"menubar\"\n        }, {\n          default: m(() => [\n            y(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 512)\n      ]),\n      _: 3\n    }, 8, [\"current-tab-stop-id\", \"loop\", \"dir\"]));\n  }\n}), [Uo, ll] = H(\"MenubarMenu\"), $d = /* @__PURE__ */ b({\n  __name: \"MenubarMenu\",\n  props: {\n    value: {}\n  },\n  setup(o2) {\n    const e = o2.value ?? te(), a = kt();\n    $();\n    const s = P(), r = P(false), l = S(() => a.modelValue.value === e);\n    return U(l, () => {\n      l.value || (r.value = false);\n    }), ll({\n      value: e,\n      triggerElement: s,\n      triggerId: e,\n      contentId: te(),\n      wasKeyboardTriggerOpenRef: r\n    }), (i, u) => (h(), C(n(Oo), {\n      open: l.value,\n      modal: false,\n      dir: n(a).dir.value,\n      \"onUpdate:open\": u[0] || (u[0] = (d) => {\n        d || n(a).onMenuClose();\n      })\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\"]));\n  }\n}), xd = /* @__PURE__ */ b({\n  __name: \"MenubarTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = kt(), e = Uo(), { forwardRef: a, currentElement: s } = $(), r = P(false), l = S(() => t.modelValue.value === e.value);\n    return q(() => {\n      e.triggerElement = s;\n    }), (i, u) => (h(), C(n(tt), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      \"tab-stop-id\": n(e).value\n    }, {\n      default: m(() => [\n        k(n(Rt), { \"as-child\": \"\" }, {\n          default: m(() => [\n            k(n(D), {\n              id: n(e).triggerId,\n              ref: n(a),\n              as: i.as,\n              type: i.as === \"button\" ? \"button\" : void 0,\n              role: \"menuitem\",\n              \"aria-haspopup\": \"menu\",\n              \"aria-expanded\": l.value,\n              \"aria-controls\": l.value ? n(e).contentId : void 0,\n              \"data-highlighted\": r.value ? \"\" : void 0,\n              \"data-state\": l.value ? \"open\" : \"closed\",\n              \"data-disabled\": i.disabled ? \"\" : void 0,\n              disabled: i.disabled,\n              \"data-value\": n(e).value,\n              \"data-radix-vue-collection-item\": \"\",\n              onPointerdown: u[0] || (u[0] = (d) => {\n                !i.disabled && d.button === 0 && d.ctrlKey === false && (n(t).onMenuOpen(n(e).value), l.value || d.preventDefault());\n              }),\n              onPointerenter: u[1] || (u[1] = () => {\n                var p;\n                !!n(t).modelValue.value && !l.value && (n(t).onMenuOpen(n(e).value), (p = n(s)) == null || p.focus());\n              }),\n              onKeydown: u[2] || (u[2] = ie((d) => {\n                i.disabled || ([\"Enter\", \" \"].includes(d.key) && n(t).onMenuToggle(n(e).value), d.key === \"ArrowDown\" && n(t).onMenuOpen(n(e).value), [\"Enter\", \" \", \"ArrowDown\"].includes(d.key) && (n(e).wasKeyboardTriggerOpenRef.value = true, d.preventDefault()));\n              }, [\"enter\", \"space\", \"arrow-down\"])),\n              onFocus: u[3] || (u[3] = (d) => r.value = true),\n              onBlur: u[4] || (u[4] = (d) => r.value = false)\n            }, {\n              default: m(() => [\n                y(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 8, [\"id\", \"as\", \"type\", \"aria-expanded\", \"aria-controls\", \"data-highlighted\", \"data-state\", \"data-disabled\", \"disabled\", \"data-value\"])\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"tab-stop-id\"]));\n  }\n}), Ed = /* @__PURE__ */ b({\n  __name: \"MenubarPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Fo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Pd = /* @__PURE__ */ b({\n  __name: \"MenubarContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t);\n    $();\n    const r = kt(), l = Uo(), { injectCollection: i } = ve(\"menubar\"), u = i(), d = P(false);\n    function p(c) {\n      const v = c.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ), w = (r.dir.value === \"rtl\" ? \"ArrowRight\" : \"ArrowLeft\") === c.key;\n      if (!w && v)\n        return;\n      let _ = u.value.map((O) => O.dataset.value);\n      w && _.reverse();\n      const x = _.indexOf(l.value);\n      _ = r.loop.value ? Co(_, x + 1) : _.slice(x + 1);\n      const [B] = _;\n      B && r.onMenuOpen(B);\n    }\n    return (c, f) => (h(), C(n(ko), T({\n      id: n(l).contentId\n    }, n(s), {\n      \"aria-labelledby\": n(l).triggerId,\n      \"data-radix-menubar-content\": \"\",\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: f[0] || (f[0] = (v) => {\n        var w;\n        !!!n(r).modelValue.value && !d.value && ((w = n(l).triggerElement.value) == null || w.focus()), d.value = false, v.preventDefault();\n      }),\n      onFocusOutside: f[1] || (f[1] = (v) => {\n        const g = v.target;\n        n(u).some((E) => E.contains(g)) && v.preventDefault();\n      }),\n      onInteractOutside: f[2] || (f[2] = (v) => {\n        d.value = true;\n      }),\n      onEntryFocus: f[3] || (f[3] = (v) => {\n        n(l).wasKeyboardTriggerOpenRef.value || v.preventDefault();\n      }),\n      onKeydown: ie(p, [\"arrow-right\", \"arrow-left\"])\n    }), {\n      default: m(() => [\n        y(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\", \"style\"]));\n  }\n}), Bd = /* @__PURE__ */ b({\n  __name: \"MenubarArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Do), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sd = /* @__PURE__ */ b({\n  __name: \"MenubarItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(vt), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Td = /* @__PURE__ */ b({\n  __name: \"MenubarGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Mt), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Dd = /* @__PURE__ */ b({\n  __name: \"MenubarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(No), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Od = /* @__PURE__ */ b({\n  __name: \"MenubarCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Mo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Id = /* @__PURE__ */ b({\n  __name: \"MenubarItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Ro), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ad = /* @__PURE__ */ b({\n  __name: \"MenubarLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Vo), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Rd = /* @__PURE__ */ b({\n  __name: \"MenubarRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = ce(t);\n    return $(), (r, l) => (h(), C(n(Lo), L(N({ ...e, ...n(s) })), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Md = /* @__PURE__ */ b({\n  __name: \"MenubarRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t);\n    return $(), (r, l) => (h(), C(n(Ko), L(N(n(s))), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), kd = /* @__PURE__ */ b({\n  __name: \"MenubarSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t;\n    $();\n    const s = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen ?? false,\n      passive: e.open === void 0\n    });\n    return (r, l) => (h(), C(n(Ho), {\n      open: n(s),\n      \"onUpdate:open\": l[0] || (l[0] = (i) => dt(s) ? s.value = i : null)\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), Vd = /* @__PURE__ */ b({\n  __name: \"MenubarSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t);\n    $();\n    const { injectCollection: r } = ve(\"menubar\"), l = kt(), i = Uo(), u = r();\n    function d(p) {\n      if (p.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ))\n        return;\n      let v = u.value.map((E) => E.dataset.value);\n      const g = v.indexOf(i.value);\n      v = l.loop.value ? Co(v, g + 1) : v.slice(g + 1);\n      const [w] = v;\n      w && l.onMenuOpen(w);\n    }\n    return (p, c) => (h(), C(n(jo), T(n(s), {\n      \"data-radix-menubar-content\": \"\",\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onKeydown: ie(d, [\"arrow-right\"])\n    }), {\n      default: m(() => [\n        y(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), Fd = /* @__PURE__ */ b({\n  __name: \"MenubarSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Wo), T(t, { \"data-radix-menubar-subtrigger\": \"\" }), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Oe, Qn] = H([\"NavigationMenuRoot\", \"NavigationMenuSub\"], \"NavigationMenuContext\"), Ld = /* @__PURE__ */ b({\n  __name: \"NavigationMenuRoot\",\n  props: {\n    modelValue: { default: void 0 },\n    defaultValue: {},\n    dir: {},\n    orientation: { default: \"horizontal\" },\n    delayDuration: { default: 200 },\n    skipDelayDuration: { default: 300 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = Y(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), r = P(\"\"), { forwardRef: l, currentElement: i } = $(), u = P(), d = P(), { createCollection: p } = ve(\"nav\");\n    p(u);\n    const { delayDuration: c, skipDelayDuration: f, dir: v } = z(e), g = de(v), w = Tt(false, f), E = S(() => s.value !== \"\" || w.value ? 150 : c.value), _ = mo((x) => {\n      r.value = s.value, s.value = x;\n    }, E);\n    return Qn({\n      isRootMenu: true,\n      modelValue: s,\n      previousValue: r,\n      baseId: te(),\n      dir: g,\n      orientation: e.orientation,\n      rootNavigationMenu: i,\n      indicatorTrack: u,\n      onIndicatorTrackChange: (x) => {\n        u.value = x;\n      },\n      viewport: d,\n      onViewportChange: (x) => {\n        d.value = x;\n      },\n      onTriggerEnter: (x) => {\n        _(x);\n      },\n      onTriggerLeave: () => {\n        w.value = true, _(\"\");\n      },\n      onContentEnter: (x) => {\n        _(x);\n      },\n      onContentLeave: () => {\n        _(\"\");\n      },\n      onItemSelect: (x) => {\n        r.value = s.value, s.value = x;\n      },\n      onItemDismiss: () => {\n        r.value = s.value, s.value = \"\";\n      }\n    }), (x, B) => (h(), C(n(D), {\n      ref: n(l),\n      \"aria-label\": \"Main\",\n      as: x.as,\n      \"as-child\": x.asChild,\n      \"data-orientation\": x.orientation,\n      dir: n(g)\n    }, {\n      default: m(() => [\n        y(x.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"dir\"]));\n  }\n});\nfunction Vt(o2) {\n  return o2 ? \"open\" : \"closed\";\n}\nfunction ea(o2, t) {\n  return `${o2}-trigger-${t}`;\n}\nfunction qo(o2, t) {\n  return `${o2}-content-${t}`;\n}\nconst Et = \"navigationMenu.rootContentDismiss\";\nfunction ro(o2) {\n  const t = [], e = document.createTreeWalker(o2, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (a) => {\n      const s = a.tagName === \"INPUT\" && a.type === \"hidden\";\n      return a.disabled || a.hidden || s ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); )\n    t.push(e.currentNode);\n  return t;\n}\nfunction ta(o2) {\n  const t = document.activeElement;\n  return o2.some((e) => e === t ? true : (e.focus(), document.activeElement !== t));\n}\nfunction il(o2) {\n  return o2.forEach((t) => {\n    t.dataset.tabindex = t.getAttribute(\"tabindex\") || \"\", t.setAttribute(\"tabindex\", \"-1\");\n  }), () => {\n    o2.forEach((t) => {\n      const e = t.dataset.tabindex;\n      t.setAttribute(\"tabindex\", e);\n    });\n  };\n}\nconst [Go, ul] = H(\"NavigationMenuItem\"), Kd = /* @__PURE__ */ b({\n  __name: \"NavigationMenuItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const { injectCollection: e } = ve(\"nav\"), a = e(), s = Oe(), r = t.value || te(), l = P(), i = P(), u = qo(s.baseId, r);\n    let d = () => ({});\n    const p = P(false);\n    async function c(w = \"start\") {\n      const E = document.getElementById(u);\n      if (E) {\n        d();\n        const _ = ro(E);\n        _.length && ta(w === \"start\" ? _ : _.reverse());\n      }\n    }\n    function f() {\n      const w = document.getElementById(u);\n      if (w) {\n        const E = ro(w);\n        E.length && (d = il(E));\n      }\n    }\n    ul({\n      value: r,\n      contentId: u,\n      triggerRef: l,\n      focusProxyRef: i,\n      wasEscapeCloseRef: p,\n      onEntryKeyDown: c,\n      onFocusProxyEnter: c,\n      onContentFocusOutside: f,\n      onRootContentClose: f\n    });\n    function v() {\n      var w;\n      s.onItemDismiss(), (w = l.value) == null || w.focus();\n    }\n    function g(w) {\n      const E = document.activeElement;\n      if (w.keyCode === 32 || w.key === \"Enter\")\n        if (s.modelValue.value === r) {\n          v(), w.preventDefault();\n          return;\n        } else {\n          w.target.click(), w.preventDefault();\n          return;\n        }\n      const _ = a.value.filter(\n        (B) => {\n          var O;\n          return (O = B.parentElement) == null ? void 0 : O.hasAttribute(\"data-menu-item\");\n        }\n      ), x = Je(w, E, void 0, {\n        itemsArray: _,\n        loop: false\n      });\n      x && (x == null || x.focus()), w.preventDefault(), w.stopPropagation();\n    }\n    return (w, E) => (h(), C(n(D), {\n      \"as-child\": w.asChild,\n      as: w.as,\n      \"data-menu-item\": \"\",\n      onKeydown: ie(g, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\", \"space\"])\n    }, {\n      default: m(() => [\n        y(w.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), dl = /* @__PURE__ */ b({\n  __name: \"NavigationMenuContentImpl\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { injectCollection: s } = ve(\"nav\"), r = s(), { forwardRef: l, currentElement: i } = $(), u = Oe(), d = Go(), p = ea(u.baseId, d.value), c = qo(u.baseId, d.value), f = P(null), v = S(() => {\n      const O = r.value.map((I) => I.id.split(\"trigger-\")[1]);\n      u.dir.value === \"rtl\" && O.reverse();\n      const A = O.indexOf(u.modelValue.value), M = O.indexOf(u.previousValue.value), R = d.value === u.modelValue.value, V = M === O.indexOf(d.value);\n      if (!R && !V)\n        return f.value;\n      const j = (() => {\n        if (A !== M) {\n          if (R && M !== -1)\n            return A > M ? \"from-end\" : \"from-start\";\n          if (V && A !== -1)\n            return A > M ? \"to-start\" : \"to-end\";\n        }\n        return null;\n      })();\n      return f.value = j, j;\n    });\n    function g(B) {\n      var O, A;\n      if (a(\"focusOutside\", B), a(\"interactOutside\", B), !B.defaultPrevented) {\n        d.onContentFocusOutside();\n        const M = B.target;\n        (A = (O = u.rootNavigationMenu) == null ? void 0 : O.value) != null && A.contains(M) && B.preventDefault();\n      }\n    }\n    function w(B) {\n      var O;\n      if (a(\"pointerDownOutside\", B), !B.defaultPrevented) {\n        const A = B.target, M = r.value.some(\n          (V) => V.contains(A)\n        ), R = u.isRootMenu && ((O = u.viewport.value) == null ? void 0 : O.contains(A));\n        (M || R || !u.isRootMenu) && B.preventDefault();\n      }\n    }\n    ee((B) => {\n      const O = i.value;\n      if (u.isRootMenu && O) {\n        const A = () => {\n          var M;\n          d.onRootContentClose(), O.contains(document.activeElement) && ((M = d.triggerRef.value) == null || M.focus());\n        };\n        O.addEventListener(Et, A), B(\n          () => O.removeEventListener(Et, A)\n        );\n      }\n    });\n    function E(B) {\n      var O, A;\n      a(\"escapeKeyDown\", B), B.defaultPrevented || (u.onItemDismiss(), (A = (O = d.triggerRef) == null ? void 0 : O.value) == null || A.focus(), d.wasEscapeCloseRef.value = true);\n    }\n    function _(B) {\n      var V;\n      const O = B.altKey || B.ctrlKey || B.metaKey, A = B.key === \"Tab\" && !O, M = ro(B.currentTarget);\n      if (A) {\n        const j = document.activeElement, I = M.findIndex(\n          (J) => J === j\n        ), W = B.shiftKey ? M.slice(0, I).reverse() : M.slice(I + 1, M.length);\n        if (ta(W))\n          B.preventDefault();\n        else {\n          (V = d.focusProxyRef.value) == null || V.focus();\n          return;\n        }\n      }\n      const R = Je(\n        B,\n        document.activeElement,\n        void 0,\n        { itemsArray: M, loop: false, enableIgnoredElement: true }\n      );\n      R == null || R.focus();\n    }\n    function x() {\n      var O;\n      const B = new Event(Et, {\n        bubbles: true,\n        cancelable: true\n      });\n      (O = i.value) == null || O.dispatchEvent(B);\n    }\n    return (B, O) => (h(), C(n(De), T({\n      id: n(c),\n      ref: n(l),\n      \"aria-labelledby\": n(p),\n      \"data-motion\": v.value,\n      \"data-state\": n(Vt)(n(u).modelValue.value === n(d).value),\n      \"data-orientation\": n(u).orientation\n    }, e, {\n      onKeydown: _,\n      onEscapeKeyDown: E,\n      onPointerDownOutside: w,\n      onFocusOutside: g,\n      onDismiss: x\n    }), {\n      default: m(() => [\n        y(B.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\", \"data-motion\", \"data-state\", \"data-orientation\"]));\n  }\n}), Nd = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"NavigationMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = ce(a), { forwardRef: r } = $(), l = Dt(), i = Oe(), u = Go(), d = S(() => u.value === i.modelValue.value), p = S(() => !i.modelValue.value && i.previousValue.value ? i.previousValue.value === u.value : false);\n    function c(f) {\n      a(\"pointerDownOutside\", f), f.preventDefault || i.onContentLeave();\n    }\n    return (f, v) => n(l) ? (h(), C(Ye, {\n      key: 0,\n      to: n(i).viewport.value,\n      disabled: !n(i).viewport.value\n    }, [\n      k(n(se), {\n        present: f.forceMount || d.value || p.value\n      }, {\n        default: m(() => [\n          k(dl, T({\n            ref: n(r),\n            \"data-state\": n(Vt)(d.value),\n            style: {\n              pointerEvents: !d.value && n(i).isRootMenu ? \"none\" : void 0\n            }\n          }, { ...f.$attrs, ...e, ...n(s) }, {\n            onPointerenter: v[0] || (v[0] = (g) => n(i).onContentEnter(n(u).value)),\n            onPointerleave: v[1] || (v[1] = (g) => n(i).onContentLeave()),\n            onPointerdown: c,\n            onFocusOutside: v[2] || (v[2] = (g) => a(\"focusOutside\", g)),\n            onInteractOutside: v[3] || (v[3] = (g) => a(\"interactOutside\", g))\n          }), {\n            default: m(() => [\n              y(f.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"data-state\", \"style\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\", \"disabled\"])) : X(\"\", true);\n  }\n}), Hd = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"NavigationMenuIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $(), { injectCollection: a } = ve(\"nav\"), s = a(), r = Oe(), l = P(), i = S(() => r.orientation === \"horizontal\"), u = S(() => !!r.modelValue.value), d = P();\n    function p() {\n      d.value && (l.value = {\n        size: i.value ? d.value.offsetWidth : d.value.offsetHeight,\n        offset: i.value ? d.value.offsetLeft : d.value.offsetTop\n      });\n    }\n    return ee(() => {\n      if (!r.modelValue.value) {\n        l.value = void 0;\n        return;\n      }\n      const c = s.value;\n      d.value = c.find(\n        (f) => f.id.includes(r.modelValue.value)\n      ), p();\n    }), be(d, p), be(r.indicatorTrack, p), (c, f) => n(r).indicatorTrack.value ? (h(), C(Ye, {\n      key: 0,\n      to: n(r).indicatorTrack.value\n    }, [\n      k(n(se), {\n        present: c.forceMount || u.value\n      }, {\n        default: m(() => {\n          var v, g, w, E;\n          return [\n            k(n(D), T({\n              ref: n(e),\n              \"aria-hidden\": \"\",\n              \"data-state\": u.value ? \"visible\" : \"hidden\",\n              \"data-orientation\": n(r).orientation,\n              \"as-child\": t.asChild,\n              as: c.as,\n              style: {\n                position: \"absolute\",\n                ...i.value ? {\n                  left: 0,\n                  width: `${(v = l.value) == null ? void 0 : v.size}px`,\n                  transform: `translateX(${(g = l.value) == null ? void 0 : g.offset}px)`\n                } : {\n                  top: 0,\n                  height: `${(w = l.value) == null ? void 0 : w.size}px`,\n                  transform: `translateY(${(E = l.value) == null ? void 0 : E.offset}px)`\n                }\n              }\n            }, c.$attrs), {\n              default: m(() => [\n                y(c.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"data-state\", \"data-orientation\", \"as-child\", \"as\", \"style\"])\n          ];\n        }),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\"])) : X(\"\", true);\n  }\n}), jd = /* @__PURE__ */ b({\n  __name: \"NavigationMenuLink\",\n  props: {\n    active: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  emits: [\"select\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t;\n    $();\n    async function s(r) {\n      var l;\n      if (a(\"select\", r), await G(), !r.defaultPrevented && !r.metaKey) {\n        const i = new CustomEvent(\n          Et,\n          {\n            bubbles: true,\n            cancelable: true\n          }\n        );\n        (l = r.target) == null || l.dispatchEvent(i);\n      }\n    }\n    return (r, l) => (h(), C(n(D), {\n      as: r.as,\n      \"data-active\": r.active ? \"\" : void 0,\n      \"aria-current\": r.active ? \"page\" : void 0,\n      \"as-child\": e.asChild,\n      \"data-radix-vue-collection-item\": \"\",\n      onClick: s\n    }, {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"data-active\", \"aria-current\", \"as-child\"]));\n  }\n}), Wd = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"NavigationMenuList\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"ul\" }\n  },\n  setup(o2) {\n    const t = o2, e = Oe(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.onIndicatorTrackChange(s.value);\n    }), (r, l) => (h(), C(n(D), {\n      ref: n(a),\n      style: { position: \"relative\" }\n    }, {\n      default: m(() => [\n        k(n(D), T(r.$attrs, {\n          \"as-child\": t.asChild,\n          as: r.as,\n          \"data-orientation\": n(e).orientation\n        }), {\n          default: m(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 512));\n  }\n}), zd = /* @__PURE__ */ b({\n  __name: \"NavigationMenuSub\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = Y(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), r = P(\"\"), l = Oe(), { forwardRef: i, currentElement: u } = $(), d = P(), p = P(), { createCollection: c } = ve(\"nav\");\n    return c(d), Qn({\n      ...l,\n      isRootMenu: false,\n      modelValue: s,\n      previousValue: r,\n      orientation: e.orientation,\n      rootNavigationMenu: u,\n      indicatorTrack: d,\n      onIndicatorTrackChange: (f) => {\n        d.value = f;\n      },\n      viewport: p,\n      onViewportChange: (f) => {\n        p.value = f;\n      },\n      onTriggerEnter: (f) => {\n        s.value = f;\n      },\n      onTriggerLeave: () => {\n      },\n      onContentEnter: () => {\n      },\n      onContentLeave: () => {\n      },\n      onItemSelect: (f) => {\n        s.value = f;\n      },\n      onItemDismiss: () => {\n        s.value = \"\";\n      }\n    }), (f, v) => (h(), C(n(D), {\n      ref: n(i),\n      \"data-orientation\": f.orientation,\n      \"as-child\": e.asChild,\n      as: f.as\n    }, {\n      default: m(() => [\n        y(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), cl = [\"aria-owns\"], Ud = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"NavigationMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = Oe(), a = Go(), { forwardRef: s, currentElement: r } = $(), l = P(\"\"), i = P(\"\"), u = Tt(false, 300), d = P(false), p = S(() => a.value === e.modelValue.value);\n    q(() => {\n      a.triggerRef = r, l.value = ea(e.baseId, a.value), i.value = qo(e.baseId, a.value);\n    });\n    function c() {\n      d.value = false, a.wasEscapeCloseRef.value = false;\n    }\n    function f(x) {\n      if (x.pointerType === \"mouse\") {\n        if (t.disabled || d.value || a.wasEscapeCloseRef.value || u.value)\n          return;\n        e.onTriggerEnter(a.value), u.value = true;\n      }\n    }\n    function v(x) {\n      if (x.pointerType === \"mouse\") {\n        if (t.disabled)\n          return;\n        e.onTriggerLeave(), u.value = false;\n      }\n    }\n    function g() {\n      u.value || (p.value ? e.onItemSelect(\"\") : e.onItemSelect(a.value), d.value = p.value);\n    }\n    function w(x) {\n      const O = { horizontal: \"ArrowDown\", vertical: e.dir.value === \"rtl\" ? \"ArrowLeft\" : \"ArrowRight\" }[e.orientation];\n      p.value && x.key === O && (a.onEntryKeyDown(), x.preventDefault(), x.stopPropagation());\n    }\n    function E(x) {\n      a.focusProxyRef.value = pe(x);\n    }\n    function _(x) {\n      const B = document.getElementById(a.contentId), O = x.relatedTarget, A = O === r.value, M = B == null ? void 0 : B.contains(O);\n      (A || !M) && a.onFocusProxyEnter(A ? \"start\" : \"end\");\n    }\n    return (x, B) => (h(), Q(le, null, [\n      k(n(D), T({\n        id: l.value,\n        ref: n(s),\n        disabled: x.disabled,\n        \"data-disabled\": x.disabled ? \"\" : void 0,\n        \"data-state\": n(Vt)(p.value),\n        \"aria-expanded\": p.value,\n        \"aria-controls\": i.value,\n        \"as-child\": t.asChild,\n        as: x.as\n      }, x.$attrs, {\n        \"data-radix-vue-collection-item\": \"\",\n        onPointerenter: c,\n        onPointermove: f,\n        onPointerleave: v,\n        onClick: g,\n        onKeydown: w\n      }), {\n        default: m(() => [\n          y(x.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"disabled\", \"data-disabled\", \"data-state\", \"aria-expanded\", \"aria-controls\", \"as-child\", \"as\"]),\n      p.value ? (h(), Q(le, { key: 0 }, [\n        k(n(Qe), {\n          ref: E,\n          \"aria-hidden\": \"\",\n          tabindex: 0,\n          onFocus: _\n        }),\n        n(e).viewport ? (h(), Q(\"span\", {\n          key: 0,\n          \"aria-owns\": i.value\n        }, null, 8, cl)) : X(\"\", true)\n      ], 64)) : X(\"\", true)\n    ], 64));\n  }\n}), qd = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"NavigationMenuViewport\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const { forwardRef: t, currentElement: e } = $(), a = Oe(), s = P(), r = S(() => !!a.modelValue.value), l = S(() => a.modelValue.value);\n    U(e, () => {\n      e.value && a.onViewportChange(e.value);\n    });\n    const i = P();\n    return U([l, r], async () => {\n      var d, p;\n      if (await G(), !e.value)\n        return;\n      const u = (p = (d = e.value.querySelector(\"[data-state=open]\")) == null ? void 0 : d.children) == null ? void 0 : p[0];\n      i.value = u;\n    }, { immediate: true }), be(i, () => {\n      i.value && (s.value = {\n        width: i.value.offsetWidth,\n        height: i.value.offsetHeight\n      });\n    }), (u, d) => (h(), C(n(se), {\n      present: u.forceMount || r.value\n    }, {\n      default: m(() => {\n        var p, c;\n        return [\n          k(n(D), T(u.$attrs, {\n            ref: n(t),\n            as: u.as,\n            \"as-child\": u.asChild,\n            \"data-state\": n(Vt)(r.value),\n            \"data-orientation\": n(a).orientation,\n            style: {\n              // Prevent interaction when animating out\n              pointerEvents: !r.value && n(a).isRootMenu ? \"none\" : void 0,\n              \"--radix-navigation-menu-viewport-width\": s.value ? `${(p = s.value) == null ? void 0 : p.width}px` : void 0,\n              \"--radix-navigation-menu-viewport-height\": s.value ? `${(c = s.value) == null ? void 0 : c.height}px` : void 0\n            },\n            onPointerenter: d[0] || (d[0] = (f) => n(a).onContentEnter(n(a).modelValue.value)),\n            onPointerleave: d[1] || (d[1] = (f) => n(a).onContentLeave())\n          }), {\n            default: m(() => [\n              y(u.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\", \"data-state\", \"data-orientation\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [ot, pl] = H(\"PaginationRoot\"), Gd = /* @__PURE__ */ b({\n  __name: \"PaginationRoot\",\n  props: {\n    page: {},\n    defaultPage: { default: 1 },\n    itemsPerPage: { default: 10 },\n    total: { default: 0 },\n    siblingCount: { default: 2 },\n    disabled: { type: Boolean },\n    showEdges: { type: Boolean, default: false },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:page\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { siblingCount: s, disabled: r, showEdges: l } = z(e);\n    $();\n    const i = Y(e, \"page\", a, {\n      defaultValue: e.defaultPage,\n      passive: e.page === void 0\n    }), u = S(() => Math.ceil(e.total / e.itemsPerPage));\n    return pl({\n      page: i,\n      onPageChange(d) {\n        i.value = d;\n      },\n      pageCount: u,\n      siblingCount: s,\n      disabled: r,\n      showEdges: l\n    }), (d, p) => (h(), C(n(D), {\n      as: d.as,\n      \"as-child\": d.asChild\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\", {\n          page: n(i),\n          pageCount: u.value\n        })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), Yd = /* @__PURE__ */ b({\n  __name: \"PaginationEllipsis\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(D), T(t, { \"data-type\": \"ellipsis\" }), {\n      default: m(() => [\n        y(e.$slots, \"default\", {}, () => [\n          ue(\"\")\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xd = /* @__PURE__ */ b({\n  __name: \"PaginationFirst\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = ot();\n    return $(), (a, s) => (h(), C(n(D), T(t, {\n      \"aria-label\": \"First Page\",\n      type: a.as === \"button\" ? \"button\" : void 0,\n      disabled: n(e).page.value === 1 || n(e).disabled.value,\n      onClick: s[0] || (s[0] = (r) => n(e).onPageChange(1))\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\", {}, () => [\n          ue(\"First page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), Jd = /* @__PURE__ */ b({\n  __name: \"PaginationLast\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = ot();\n    return $(), (a, s) => (h(), C(n(D), T(t, {\n      \"aria-label\": \"Last Page\",\n      type: a.as === \"button\" ? \"button\" : void 0,\n      disabled: n(e).page.value === n(e).pageCount.value || n(e).disabled.value,\n      onClick: s[0] || (s[0] = (r) => n(e).onPageChange(n(e).pageCount.value))\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\", {}, () => [\n          ue(\"Last page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n});\nfunction Ee(o2, t) {\n  const e = t - o2 + 1;\n  return Array.from({ length: e }, (a, s) => s + o2);\n}\nfunction fl(o2) {\n  return o2.map((t) => typeof t == \"number\" ? { type: \"page\", value: t } : { type: \"ellipsis\" });\n}\nconst wt = \"ellipsis\";\nfunction vl(o2, t, e, a) {\n  const r = t, l = Math.max(o2 - e, 1), i = Math.min(o2 + e, r), u = l > 1 + 2, d = i < r - 2;\n  if (a) {\n    const c = Math.min(2 * e + 5, t) - 2;\n    if (!u && d)\n      return [...Ee(1, c), wt, r];\n    if (u && !d) {\n      const v = Ee(r - c + 1, r);\n      return [1, wt, ...v];\n    }\n    if (u && d) {\n      const v = Ee(l, i);\n      return [1, wt, ...v, wt, r];\n    }\n    return Ee(1, r);\n  } else {\n    const p = e * 2 + 1;\n    return t < p ? Ee(1, r) : o2 <= e + 1 ? Ee(1, p) : t - o2 <= e ? Ee(t - p + 1, r) : Ee(l, i);\n  }\n}\nconst Zd = /* @__PURE__ */ b({\n  __name: \"PaginationList\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = ot(), a = S(() => fl(\n      vl(\n        e.page.value,\n        e.pageCount.value,\n        e.siblingCount.value,\n        e.showEdges.value\n      )\n    ));\n    return (s, r) => (h(), C(n(D), L(N(t)), {\n      default: m(() => [\n        y(s.$slots, \"default\", { items: a.value })\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qd = /* @__PURE__ */ b({\n  __name: \"PaginationListItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = ot(), a = S(() => e.page.value === t.value);\n    return (s, r) => (h(), C(n(D), T(t, {\n      \"data-type\": \"page\",\n      \"aria-label\": `Page ${s.value}`,\n      \"aria-current\": a.value ? \"page\" : void 0,\n      \"data-selected\": a.value ? \"true\" : void 0,\n      disabled: n(e).disabled.value,\n      type: s.as === \"button\" ? \"button\" : void 0,\n      onClick: r[0] || (r[0] = (l) => n(e).onPageChange(s.value))\n    }), {\n      default: m(() => [\n        y(s.$slots, \"default\", {}, () => [\n          ue(Le(s.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-current\", \"data-selected\", \"disabled\", \"type\"]));\n  }\n}), ec = /* @__PURE__ */ b({\n  __name: \"PaginationNext\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = ot();\n    return (a, s) => (h(), C(n(D), T(t, {\n      \"aria-label\": \"Next Page\",\n      type: a.as === \"button\" ? \"button\" : void 0,\n      disabled: n(e).page.value === n(e).pageCount.value || n(e).disabled.value,\n      onClick: s[0] || (s[0] = (r) => n(e).onPageChange(n(e).page.value + 1))\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\", {}, () => [\n          ue(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), tc = /* @__PURE__ */ b({\n  __name: \"PaginationPrev\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = ot();\n    return (a, s) => {\n      var r;\n      return h(), C(n(D), T(t, {\n        \"aria-label\": \"Previous Page\",\n        type: a.as === \"button\" ? \"button\" : void 0,\n        disabled: n(e).page.value === 1 || ((r = n(e).disabled) == null ? void 0 : r.value),\n        onClick: s[0] || (s[0] = (l) => n(e).onPageChange(n(e).page.value - 1))\n      }), {\n        default: m(() => [\n          y(a.$slots, \"default\", {}, () => [\n            ue(\"Prev page\")\n          ])\n        ]),\n        _: 3\n      }, 16, [\"type\", \"disabled\"]);\n    };\n  }\n}), ml = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [hl, gl] = H(\"PinInputRoot\"), oc = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"PinInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    placeholder: { default: \"\" },\n    mask: { type: Boolean },\n    otp: { type: Boolean },\n    type: { default: \"text\" },\n    dir: {},\n    name: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    id: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"complete\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { mask: s, otp: r, placeholder: l, type: i, disabled: u, dir: d } = z(e), { forwardRef: p } = $(), c = de(d), f = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue ?? [],\n      passive: e.modelValue === void 0\n    }), v = P(/* @__PURE__ */ new Set());\n    function g(E) {\n      v.value.add(E);\n    }\n    const w = S(() => f.value.filter((_) => !!_).length === v.value.size);\n    return U(f, () => {\n      w.value && a(\"complete\", f.value);\n    }, { deep: true }), gl({\n      modelValue: f,\n      mask: s,\n      otp: r,\n      placeholder: l,\n      type: i,\n      dir: c,\n      disabled: u,\n      isCompleted: w,\n      inputElements: v,\n      onInputElementChange: g\n    }), (E, _) => (h(), Q(le, null, [\n      k(n(D), T(E.$attrs, {\n        ref: n(p),\n        dir: n(c),\n        \"data-complete\": w.value ? \"\" : void 0,\n        \"data-disabled\": n(u) ? \"\" : void 0\n      }), {\n        default: m(() => [\n          y(E.$slots, \"default\", { modelValue: n(f) })\n        ]),\n        _: 3\n      }, 16, [\"dir\", \"data-complete\", \"data-disabled\"]),\n      ut(\"input\", {\n        id: E.id,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        value: n(f).join(\"\"),\n        name: E.name,\n        disabled: n(u),\n        required: E.required,\n        style: re({\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }),\n        onFocus: _[0] || (_[0] = (x) => {\n          var B, O;\n          return (O = (B = Array.from(v.value)) == null ? void 0 : B[0]) == null ? void 0 : O.focus();\n        })\n      }, null, 44, ml)\n    ], 64));\n  }\n}), yl = [\"autocomplete\", \"type\", \"inputmode\", \"pattern\", \"placeholder\", \"value\", \"disabled\", \"data-disabled\", \"data-complete\", \"aria-label\"], nc = /* @__PURE__ */ b({\n  __name: \"PinInputInput\",\n  props: {\n    index: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(o2) {\n    const t = o2, e = hl(), a = S(() => Array.from(e.inputElements.value)), s = S(() => t.disabled || e.disabled.value), r = S(() => e.otp.value), l = S(() => e.type.value === \"number\"), i = S(() => e.mask.value), u = P();\n    function d(_) {\n      const x = _.target;\n      if (l.value && !/^[0-9]*$/.test(x.value)) {\n        x.value = x.value.replace(/\\D/g, \"\");\n        return;\n      }\n      x.value = x.value.slice(-1), E(t.index, x.value);\n      const B = a.value[t.index + 1];\n      B && B.focus();\n    }\n    function p(_) {\n      Je(_, document.activeElement, void 0, {\n        itemsArray: a.value,\n        focus: true,\n        loop: false,\n        arrowKeyOptions: \"horizontal\",\n        dir: e.dir.value\n      });\n    }\n    function c(_) {\n      if (_.preventDefault(), _.target.value)\n        E(t.index, \"\");\n      else {\n        const O = a.value[t.index - 1];\n        O && (O.focus(), E(t.index - 1, \"\"));\n      }\n    }\n    function f(_) {\n      _.key === \"Delete\" && (_.preventDefault(), E(t.index, \"\"));\n    }\n    function v(_) {\n      const x = _.target;\n      x.setSelectionRange(1, 1), x.value || (x.placeholder = \"\");\n    }\n    function g(_) {\n      const x = _.target;\n      G(() => {\n        x.value || (x.placeholder = e.placeholder.value);\n      });\n    }\n    function w(_) {\n      var R;\n      _.preventDefault();\n      const x = _.clipboardData;\n      if (!x)\n        return;\n      const B = [...e.modelValue.value], O = x.getData(\"text\"), A = O.length >= a.value.length ? 0 : t.index, M = Math.min(A + O.length, a.value.length);\n      for (let V = A; V < M; V++) {\n        const j = a.value[V], I = O[V - A];\n        l.value && !/^[0-9]*$/.test(I) || (B[V] = I, j.focus());\n      }\n      e.modelValue.value = B, (R = a.value[M]) == null || R.focus();\n    }\n    function E(_, x) {\n      const B = [...e.modelValue.value];\n      B[_] = x, e.modelValue.value = B;\n    }\n    return q(() => {\n      e.onInputElementChange(u.value);\n    }), fe(() => {\n      var _;\n      (_ = e.inputElements) == null || _.value.delete(u.value);\n    }), (_, x) => (h(), Q(\"input\", {\n      ref_key: \"inputRef\",\n      ref: u,\n      autocapitalize: \"none\",\n      autocomplete: r.value ? \"one-time-code\" : \"false\",\n      type: i.value ? \"password\" : \"text\",\n      inputmode: l.value ? \"numeric\" : \"text\",\n      pattern: l.value ? \"[0-9]*\" : void 0,\n      placeholder: n(e).placeholder.value,\n      value: n(e).modelValue.value.at(_.index),\n      disabled: s.value,\n      \"data-disabled\": s.value ? \"\" : void 0,\n      \"data-complete\": n(e).isCompleted.value ? \"\" : void 0,\n      \"aria-label\": `pin input ${_.index + 1} of ${a.value.length}`,\n      onInput: d,\n      onKeydown: [\n        ie(p, [\"left\", \"right\", \"up\", \"down\", \"home\", \"end\"]),\n        ie(c, [\"backspace\"]),\n        ie(f, [\"delete\"])\n      ],\n      onFocus: v,\n      onBlur: g,\n      onPaste: w\n    }, null, 40, yl));\n  }\n}), [Ue, bl] = H(\"PopoverRoot\"), ac = /* @__PURE__ */ b({\n  __name: \"PopoverRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: false },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: false }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { modal: s } = z(e), r = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), l = P(), i = P(false);\n    return bl({\n      contentId: te(),\n      modal: s,\n      open: r,\n      onOpenChange: (u) => {\n        r.value = u;\n      },\n      onOpenToggle: () => {\n        r.value = !r.value;\n      },\n      triggerElement: l,\n      hasCustomAnchor: i\n    }), (u, d) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), sc = /* @__PURE__ */ b({\n  __name: \"PopoverTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = Ue(), { forwardRef: a, currentElement: s } = $();\n    return q(() => {\n      e.triggerElement.value = s.value;\n    }), (r, l) => (h(), C(we(n(e).hasCustomAnchor.value ? n(D) : n(We)), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(a),\n          type: r.as === \"button\" ? \"button\" : void 0,\n          \"aria-haspopup\": \"dialog\",\n          \"aria-expanded\": n(e).open.value,\n          \"aria-controls\": n(e).contentId,\n          \"data-state\": n(e).open.value ? \"open\" : \"closed\",\n          as: r.as,\n          \"as-child\": t.asChild,\n          onClick: n(e).onOpenToggle\n        }, {\n          default: m(() => [\n            y(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"as\", \"as-child\", \"onClick\"])\n      ]),\n      _: 3\n    }));\n  }\n}), rc = /* @__PURE__ */ b({\n  __name: \"PopoverPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), oa = /* @__PURE__ */ b({\n  __name: \"PopoverContentImpl\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = He(e), { forwardRef: r } = $(), l = Ue();\n    return yo(), (i, u) => (h(), C(n(At), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: i.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => a(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => a(\"closeAutoFocus\", d))\n    }, {\n      default: m(() => [\n        k(n(De), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          onPointerDownOutside: u[0] || (u[0] = (d) => a(\"pointerDownOutside\", d)),\n          onInteractOutside: u[1] || (u[1] = (d) => a(\"interactOutside\", d)),\n          onEscapeKeyDown: u[2] || (u[2] = (d) => a(\"escapeKeyDown\", d)),\n          onFocusOutside: u[3] || (u[3] = (d) => a(\"focusOutside\", d)),\n          onDismiss: u[4] || (u[4] = (d) => n(l).onOpenChange(false))\n        }, {\n          default: m(() => [\n            k(n(Fe), T(n(s), {\n              id: n(l).contentId,\n              ref: n(r),\n              \"data-state\": n(l).open.value ? \"open\" : \"closed\",\n              role: \"dialog\",\n              style: {\n                \"--radix-popover-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n                \"--radix-popover-content-available-width\": \"var(--radix-popper-available-width)\",\n                \"--radix-popover-content-available-height\": \"var(--radix-popper-available-height)\",\n                \"--radix-popover-trigger-width\": \"var(--radix-popper-anchor-width)\",\n                \"--radix-popover-trigger-height\": \"var(--radix-popper-anchor-height)\"\n              }\n            }), {\n              default: m(() => [\n                y(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"style\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), Cl = /* @__PURE__ */ b({\n  __name: \"PopoverContentModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = Ue(), r = P(false);\n    ct(true);\n    const l = ae(e, a), { forwardRef: i, currentElement: u } = $();\n    return pt(u), (d, p) => (h(), C(oa, T(n(l), {\n      ref: n(i),\n      \"trap-focus\": n(s).open.value,\n      \"disable-outside-pointer-events\": \"\",\n      onCloseAutoFocus: p[0] || (p[0] = oe(\n        (c) => {\n          var f;\n          a(\"closeAutoFocus\", c), r.value || (f = n(s).triggerElement.value) == null || f.focus();\n        },\n        [\"prevent\"]\n      )),\n      onPointerDownOutside: p[1] || (p[1] = (c) => {\n        a(\"pointerDownOutside\", c);\n        const f = c.detail.originalEvent, v = f.button === 0 && f.ctrlKey === true, g = f.button === 2 || v;\n        r.value = g;\n      }),\n      onFocusOutside: p[2] || (p[2] = oe(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), wl = /* @__PURE__ */ b({\n  __name: \"PopoverContentNonModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = Ue(), r = P(false), l = P(false), i = ae(e, a);\n    return (u, d) => (h(), C(oa, T(n(i), {\n      \"trap-focus\": false,\n      \"disable-outside-pointer-events\": false,\n      onCloseAutoFocus: d[0] || (d[0] = (p) => {\n        var c;\n        a(\"closeAutoFocus\", p), p.defaultPrevented || (r.value || (c = n(s).triggerElement.value) == null || c.focus(), p.preventDefault()), r.value = false, l.value = false;\n      }),\n      onInteractOutside: d[1] || (d[1] = async (p) => {\n        var v;\n        a(\"interactOutside\", p), p.defaultPrevented || (r.value = true, p.detail.originalEvent.type === \"pointerdown\" && (l.value = true));\n        const c = p.target;\n        ((v = n(s).triggerElement.value) == null ? void 0 : v.contains(c)) && p.preventDefault(), p.detail.originalEvent.type === \"focusin\" && l.value && p.preventDefault();\n      })\n    }), {\n      default: m(() => [\n        y(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lc = /* @__PURE__ */ b({\n  __name: \"PopoverContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = Ue(), r = ae(e, a), { forwardRef: l } = $();\n    return (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(s).open.value\n    }, {\n      default: m(() => [\n        n(s).modal.value ? (h(), C(Cl, T({ key: 0 }, n(r), { ref: n(l) }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (h(), C(wl, T({ key: 1 }, n(r), { ref: n(l) }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), ic = /* @__PURE__ */ b({\n  __name: \"PopoverArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Ze), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), uc = /* @__PURE__ */ b({\n  __name: \"PopoverClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = Ue();\n    return (a, s) => (h(), C(n(D), {\n      type: a.as === \"button\" ? \"button\" : void 0,\n      as: a.as,\n      \"as-child\": t.asChild,\n      onClick: s[0] || (s[0] = (r) => n(e).onOpenChange(false))\n    }, {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as\", \"as-child\"]));\n  }\n}), dc = /* @__PURE__ */ b({\n  __name: \"PopoverAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = Ue();\n    return $n(() => {\n      e.hasCustomAnchor.value = true;\n    }), fe(() => {\n      e.hasCustomAnchor.value = false;\n    }), (a, s) => (h(), C(n(We), L(N(t)), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lt = 100, [_l, $l] = H(\"ProgressRoot\"), Yo = (o2) => typeof o2 == \"number\";\nfunction xl(o2, t) {\n  return o2 === null || Yo(o2) && !Number.isNaN(o2) && o2 <= t && o2 >= 0 ? o2 : (console.error(`Invalid prop \\`value\\` of value \\`${o2}\\` supplied to \\`ProgressRoot\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${lt} if no \\`max\\` prop is set)\n  - \\`null\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`), null);\n}\nfunction El(o2) {\n  return Yo(o2) && !Number.isNaN(o2) && o2 > 0 ? o2 : (console.error(\n    `Invalid prop \\`max\\` of value \\`${o2}\\` supplied to \\`ProgressRoot\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${lt}\\`.`\n  ), lt);\n}\nconst cc = /* @__PURE__ */ b({\n  __name: \"ProgressRoot\",\n  props: {\n    modelValue: {},\n    max: { default: lt },\n    getValueLabel: { type: Function, default: (o2, t) => `${Math.round(o2 / t * lt)}%` },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:max\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t;\n    $();\n    const s = Y(e, \"modelValue\", a, {\n      passive: e.modelValue === void 0\n    }), r = Y(e, \"max\", a, {\n      passive: e.max === void 0\n    });\n    U(\n      () => s.value,\n      async (i) => {\n        const u = xl(i, e.max);\n        u !== i && (await G(), s.value = u);\n      },\n      { immediate: true }\n    ), U(\n      () => e.max,\n      (i) => {\n        const u = El(e.max);\n        u !== i && (r.value = u);\n      },\n      { immediate: true }\n    );\n    const l = S(() => s.value ? s.value === r.value ? \"complete\" : \"loading\" : \"indeterminate\");\n    return $l({\n      modelValue: s,\n      max: r,\n      progressState: l\n    }), (i, u) => (h(), C(n(D), {\n      \"as-child\": i.asChild,\n      as: i.as,\n      \"aria-valuemax\": n(r),\n      \"aria-valuemin\": 0,\n      \"aria-valuenow\": Yo(n(s)) ? n(s) : void 0,\n      \"aria-valuetext\": i.getValueLabel(n(s), n(r)),\n      \"aria-label\": i.getValueLabel(n(s), n(r)),\n      role: \"progressbar\",\n      \"data-state\": l.value,\n      \"data-value\": n(s) ?? void 0,\n      \"data-max\": n(r)\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"aria-valuemax\", \"aria-valuenow\", \"aria-valuetext\", \"aria-label\", \"data-state\", \"data-value\", \"data-max\"]));\n  }\n}), pc = /* @__PURE__ */ b({\n  __name: \"ProgressIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = _l();\n    return $(), (a, s) => {\n      var r;\n      return h(), C(n(D), T(t, {\n        \"data-state\": n(e).progressState.value,\n        \"data-value\": ((r = n(e).modelValue) == null ? void 0 : r.value) ?? void 0,\n        \"data-max\": n(e).max.value\n      }), {\n        default: m(() => [\n          y(a.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"data-state\", \"data-value\", \"data-max\"]);\n    };\n  }\n}), [Pl, Bl] = H(\"RadioGroupRoot\"), fc = /* @__PURE__ */ b({\n  __name: \"RadioGroupRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    disabled: { type: Boolean, default: false },\n    name: {},\n    required: { type: Boolean, default: false },\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: true },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { forwardRef: s } = $(), r = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), { disabled: l, loop: i, orientation: u, name: d, required: p, dir: c } = z(e), f = de(c);\n    return Bl({\n      modelValue: r,\n      changeModelValue: (v) => {\n        r.value = v;\n      },\n      disabled: l,\n      loop: i,\n      orientation: u,\n      name: d == null ? void 0 : d.value,\n      required: p\n    }), (v, g) => (h(), C(n(et), {\n      \"as-child\": \"\",\n      orientation: n(u),\n      dir: n(f),\n      loop: n(i)\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(s),\n          role: \"radiogroup\",\n          \"data-disabled\": n(l) ? \"\" : void 0,\n          \"as-child\": v.asChild,\n          as: v.as,\n          required: n(p),\n          \"aria-orientation\": n(u),\n          \"aria-required\": n(p),\n          dir: n(f),\n          name: n(d)\n        }, {\n          default: m(() => [\n            y(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"data-disabled\", \"as-child\", \"as\", \"required\", \"aria-orientation\", \"aria-required\", \"dir\", \"name\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Sl = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], Tl = /* @__PURE__ */ b({\n  __name: \"Radio\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: false },\n    required: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(o2, { emit: t }) {\n    const e = o2, s = Y(e, \"checked\", t, {\n      passive: e.checked === void 0\n    }), { value: r } = z(e), { forwardRef: l, currentElement: i } = $(), u = Ne(i), d = S(() => {\n      var c;\n      return e.id && i.value ? ((c = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : c.innerText) ?? e.value : void 0;\n    });\n    function p(c) {\n      s.value = true, u.value && c.stopPropagation();\n    }\n    return (c, f) => (h(), C(n(D), T(c.$attrs, {\n      id: c.id,\n      ref: n(l),\n      role: \"radio\",\n      type: c.as === \"button\" ? \"button\" : void 0,\n      as: c.as,\n      \"aria-checked\": n(s),\n      \"aria-label\": d.value,\n      \"as-child\": c.asChild,\n      disabled: c.disabled ? true : void 0,\n      \"data-state\": n(s) ? \"checked\" : \"unchecked\",\n      \"data-disabled\": c.disabled ? \"\" : void 0,\n      value: n(r),\n      required: c.required,\n      name: c.name,\n      onClick: oe(p, [\"stop\"])\n    }), {\n      default: m(() => [\n        y(c.$slots, \"default\"),\n        n(u) ? (h(), Q(\"input\", {\n          key: 0,\n          type: \"radio\",\n          tabindex: \"-1\",\n          \"aria-hidden\": \"\",\n          value: n(r),\n          checked: !!n(s),\n          name: c.name,\n          disabled: c.disabled,\n          required: c.required,\n          style: re({\n            transform: \"translateX(-100%)\",\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            opacity: 0,\n            margin: 0\n          })\n        }, null, 12, Sl)) : X(\"\", true)\n      ]),\n      _: 3\n    }, 16, [\"id\", \"type\", \"as\", \"aria-checked\", \"aria-label\", \"as-child\", \"disabled\", \"data-state\", \"data-disabled\", \"value\", \"required\", \"name\"]));\n  }\n}), [Dl, Ol] = H(\"RadioGroupItem\"), vc = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"RadioGroupItem\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: false },\n    required: { type: Boolean },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e, currentElement: a } = $(), s = Pl(), r = S(() => s.disabled.value || t.disabled), l = S(() => s.required.value || t.required), i = S(() => {\n      var c;\n      return ((c = s.modelValue) == null ? void 0 : c.value) === t.value;\n    });\n    Ol({ disabled: r, checked: i });\n    const u = P(false), d = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\n    Be(\"keydown\", (c) => {\n      d.includes(c.key) && (u.value = true);\n    }), Be(\"keyup\", () => {\n      u.value = false;\n    });\n    function p() {\n      setTimeout(() => {\n        var c;\n        u.value && ((c = a.value) == null || c.click());\n      }, 0);\n    }\n    return (c, f) => (h(), C(n(tt), {\n      checked: i.value,\n      disabled: r.value,\n      \"as-child\": \"\",\n      focusable: !r.value,\n      active: i.value\n    }, {\n      default: m(() => [\n        k(Tl, T({ ...c.$attrs, ...t }, {\n          ref: n(e),\n          checked: i.value,\n          required: l.value,\n          \"onUpdate:checked\": f[0] || (f[0] = (v) => n(s).changeModelValue(c.value)),\n          onKeydown: f[1] || (f[1] = ie(oe(() => {\n          }, [\"prevent\"]), [\"enter\"])),\n          onFocus: p\n        }), {\n          default: m(() => [\n            y(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"checked\", \"required\"])\n      ]),\n      _: 3\n    }, 8, [\"checked\", \"disabled\", \"focusable\", \"active\"]));\n  }\n}), mc = /* @__PURE__ */ b({\n  __name: \"RadioGroupIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const { forwardRef: t } = $(), e = Dl();\n    return (a, s) => (h(), C(n(se), {\n      present: a.forceMount || n(e).checked.value\n    }, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(t),\n          \"data-state\": n(e).checked.value ? \"checked\" : \"unchecked\",\n          \"data-disabled\": n(e).disabled.value ? \"\" : void 0,\n          \"as-child\": a.asChild,\n          as: a.as\n        }, a.$attrs), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [me, Il] = H(\"ScrollAreaRoot\"), hc = /* @__PURE__ */ b({\n  __name: \"ScrollAreaRoot\",\n  props: {\n    type: { default: \"hover\" },\n    dir: {},\n    scrollHideDelay: { default: 600 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e, currentElement: a } = $(), s = P(0), r = P(0), l = P(), i = P(), u = P(), d = P(), p = P(false), c = P(false), { type: f, dir: v, scrollHideDelay: g } = z(t), w = de(v);\n    return Il({\n      type: f,\n      dir: w,\n      scrollHideDelay: g,\n      scrollArea: a,\n      viewport: l,\n      onViewportChange: (E) => {\n        l.value = E || void 0;\n      },\n      content: i,\n      onContentChange: (E) => {\n        i.value = E;\n      },\n      scrollbarX: u,\n      scrollbarXEnabled: p,\n      scrollbarY: d,\n      scrollbarYEnabled: c,\n      onScrollbarXChange: (E) => {\n        u.value = E || void 0;\n      },\n      onScrollbarYChange: (E) => {\n        d.value = E || void 0;\n      },\n      onScrollbarXEnabledChange: (E) => {\n        p.value = E;\n      },\n      onScrollbarYEnabledChange: (E) => {\n        c.value = E;\n      },\n      onCornerWidthChange: (E) => {\n        s.value = E;\n      },\n      onCornerHeightChange: (E) => {\n        r.value = E;\n      }\n    }), (E, _) => (h(), C(n(D), {\n      ref: n(e),\n      \"as-child\": t.asChild,\n      as: E.as,\n      dir: n(w),\n      style: re({\n        position: \"relative\",\n        // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n        \"--radix-scroll-area-corner-width\": `${s.value}px`,\n        \"--radix-scroll-area-corner-height\": `${r.value}px`\n      })\n    }, {\n      default: m(() => [\n        y(E.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"dir\", \"style\"]));\n  }\n}), gc = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"ScrollAreaViewport\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2, { expose: t }) {\n    const e = o2, a = me(), s = P();\n    q(() => {\n      a.onViewportChange(s.value), a.onContentChange(l.value);\n    }), t({\n      viewportElement: s\n    });\n    const { forwardRef: r, currentElement: l } = $();\n    return (i, u) => (h(), Q(le, null, [\n      ut(\"div\", T({\n        ref_key: \"viewportElement\",\n        ref: s,\n        \"data-radix-scroll-area-viewport\": \"\",\n        style: {\n          /**\n           * We don't support `visible` because the intention is to have at least one scrollbar\n           * if this component is used and `visible` will behave like `auto` in that case\n           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description\n           *\n           * We don't handle `auto` because the intention is for the native implementation\n           * to be hidden if using this component. We just want to ensure the node is scrollable\n           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n           * the browser from having to work out whether to render native scrollbars or not,\n           * we tell it to with the intention of hiding them in CSS.\n           */\n          overflowX: n(a).scrollbarXEnabled.value ? \"scroll\" : \"hidden\",\n          overflowY: n(a).scrollbarYEnabled.value ? \"scroll\" : \"hidden\"\n        }\n      }, i.$attrs, { tabindex: 0 }), [\n        k(n(D), {\n          ref: n(r),\n          style: { minWidth: \"100%\", display: \"table\" },\n          \"as-child\": e.asChild,\n          as: i.as\n        }, {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ], 16),\n      k(n(D), { as: \"style\" }, {\n        default: m(() => [\n          ue(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } \")\n        ]),\n        _: 1\n      })\n    ], 64));\n  }\n});\nfunction Al(o2, [t, e]) {\n  return Math.min(e, Math.max(t, o2));\n}\nfunction na(o2, t) {\n  return (e) => {\n    if (o2[0] === o2[1] || t[0] === t[1])\n      return t[0];\n    const a = (t[1] - t[0]) / (o2[1] - o2[0]);\n    return t[0] + a * (e - o2[0]);\n  };\n}\nfunction Ft(o2) {\n  const t = aa(o2.viewport, o2.content), e = o2.scrollbar.paddingStart + o2.scrollbar.paddingEnd, a = (o2.scrollbar.size - e) * t;\n  return Math.max(a, 18);\n}\nfunction aa(o2, t) {\n  const e = o2 / t;\n  return Number.isNaN(e) ? 0 : e;\n}\nfunction Rl(o2, t = () => {\n}) {\n  let e = { left: o2.scrollLeft, top: o2.scrollTop }, a = 0;\n  return function s() {\n    const r = { left: o2.scrollLeft, top: o2.scrollTop }, l = e.left !== r.left, i = e.top !== r.top;\n    (l || i) && t(), e = r, a = window.requestAnimationFrame(s);\n  }(), () => window.cancelAnimationFrame(a);\n}\nfunction dn(o2, t, e = \"ltr\") {\n  const a = Ft(t), s = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, r = t.scrollbar.size - s, l = t.content - t.viewport, i = r - a, u = e === \"ltr\" ? [0, l] : [l * -1, 0], d = Al(\n    o2,\n    u\n  );\n  return na([0, l], [0, i])(d);\n}\nfunction _t(o2) {\n  return o2 ? Number.parseInt(o2, 10) : 0;\n}\nfunction Ml(o2, t, e, a = \"ltr\") {\n  const s = Ft(e), r = s / 2, l = t || r, i = s - l, u = e.scrollbar.paddingStart + l, d = e.scrollbar.size - e.scrollbar.paddingEnd - i, p = e.content - e.viewport, c = a === \"ltr\" ? [0, p] : [p * -1, 0];\n  return na(\n    [u, d],\n    c\n  )(o2);\n}\nfunction cn(o2, t) {\n  return o2 > 0 && o2 < t;\n}\nconst sa = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarImpl\",\n  props: {\n    isHorizontal: { type: Boolean }\n  },\n  emits: [\"onDragScroll\", \"onWheelScroll\", \"onThumbPointerDown\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = me(), r = Lt(), l = Kt(), { forwardRef: i, currentElement: u } = $(), d = P(\"\"), p = P();\n    function c(_) {\n      var x, B;\n      if (p.value) {\n        const O = _.clientX - ((x = p.value) == null ? void 0 : x.left), A = _.clientY - ((B = p.value) == null ? void 0 : B.top);\n        a(\"onDragScroll\", { x: O, y: A });\n      }\n    }\n    function f(_) {\n      _.button === 0 && (_.target.setPointerCapture(_.pointerId), p.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = \"none\", s.viewport && (s.viewport.value.style.scrollBehavior = \"auto\"), c(_));\n    }\n    function v(_) {\n      c(_);\n    }\n    function g(_) {\n      const x = _.target;\n      x.hasPointerCapture(_.pointerId) && x.releasePointerCapture(_.pointerId), document.body.style.webkitUserSelect = d.value, s.viewport && (s.viewport.value.style.scrollBehavior = \"\"), p.value = void 0;\n    }\n    function w(_) {\n      var A;\n      const x = _.target, B = (A = u.value) == null ? void 0 : A.contains(x), O = r.sizes.value.content - r.sizes.value.viewport;\n      B && r.handleWheelScroll(_, O);\n    }\n    q(() => {\n      document.addEventListener(\"wheel\", w, { passive: false });\n    }), fe(() => {\n      document.removeEventListener(\"wheel\", w);\n    });\n    function E() {\n      var _, x, B, O, A;\n      u.value && (e.isHorizontal ? r.handleSizeChange({\n        content: ((_ = s.viewport.value) == null ? void 0 : _.scrollWidth) ?? 0,\n        viewport: ((x = s.viewport.value) == null ? void 0 : x.offsetWidth) ?? 0,\n        scrollbar: {\n          size: u.value.clientWidth ?? 0,\n          paddingStart: _t(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: _t(getComputedStyle(u.value).paddingRight)\n        }\n      }) : r.handleSizeChange({\n        content: ((B = s.viewport.value) == null ? void 0 : B.scrollHeight) ?? 0,\n        viewport: ((O = s.viewport.value) == null ? void 0 : O.offsetHeight) ?? 0,\n        scrollbar: {\n          size: ((A = u.value) == null ? void 0 : A.clientHeight) ?? 0,\n          paddingStart: _t(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: _t(getComputedStyle(u.value).paddingRight)\n        }\n      }));\n    }\n    return be(u, E), be(s.content, E), (_, x) => (h(), C(n(D), {\n      ref: n(i),\n      style: { position: \"absolute\" },\n      \"data-scrollbarimpl\": \"\",\n      as: n(l).as.value,\n      \"as-child\": n(l).asChild.value,\n      onPointerdown: f,\n      onPointermove: v,\n      onPointerup: g\n    }, {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), kl = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarX\",\n  setup(o2) {\n    const t = me(), e = Lt(), { forwardRef: a, currentElement: s } = $();\n    q(() => {\n      s.value && t.onScrollbarXChange(s.value);\n    });\n    const r = S(() => e.sizes.value);\n    return (l, i) => (h(), C(sa, {\n      ref: n(a),\n      \"is-horizontal\": true,\n      \"data-orientation\": \"horizontal\",\n      style: re({\n        bottom: 0,\n        left: n(t).dir.value === \"rtl\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        right: n(t).dir.value === \"ltr\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        \"--radix-scroll-area-thumb-width\": r.value ? `${n(Ft)(r.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => n(e).onDragScroll(u.x))\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), Vl = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarY\",\n  setup(o2) {\n    const t = me(), e = Lt(), { forwardRef: a, currentElement: s } = $();\n    q(() => {\n      s.value && t.onScrollbarYChange(s.value);\n    });\n    const r = S(() => e.sizes.value);\n    return (l, i) => (h(), C(sa, {\n      ref: n(a),\n      \"is-horizontal\": false,\n      \"data-orientation\": \"vertical\",\n      style: re({\n        top: 0,\n        right: n(t).dir.value === \"ltr\" ? 0 : void 0,\n        left: n(t).dir.value === \"rtl\" ? 0 : void 0,\n        bottom: \"var(--radix-scroll-area-corner-height)\",\n        \"--radix-scroll-area-thumb-height\": r.value ? `${n(Ft)(r.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => n(e).onDragScroll(u.y))\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), [Lt, Fl] = H(\"ScrollAreaScrollbarVisible\"), Xo = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarVisible\",\n  setup(o2) {\n    const t = me(), e = Kt(), { forwardRef: a } = $(), s = P({\n      content: 0,\n      viewport: 0,\n      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }\n    }), r = S(() => {\n      const _ = aa(s.value.viewport, s.value.content);\n      return _ > 0 && _ < 1;\n    }), l = P(), i = P(0);\n    function u(_, x) {\n      if (v.value) {\n        const B = t.viewport.value.scrollLeft + _.deltaY;\n        t.viewport.value.scrollLeft = B, cn(B, x) && _.preventDefault();\n      } else {\n        const B = t.viewport.value.scrollTop + _.deltaY;\n        t.viewport.value.scrollTop = B, cn(B, x) && _.preventDefault();\n      }\n    }\n    function d(_, x) {\n      v.value ? i.value = x.x : i.value = x.y;\n    }\n    function p(_) {\n      i.value = 0;\n    }\n    function c(_) {\n      s.value = _;\n    }\n    function f(_, x) {\n      return Ml(\n        _,\n        i.value,\n        s.value,\n        x\n      );\n    }\n    const v = S(\n      () => e.isHorizontal.value\n    );\n    function g(_) {\n      v.value ? t.viewport.value.scrollLeft = f(\n        _,\n        t.dir.value\n      ) : t.viewport.value.scrollTop = f(_);\n    }\n    function w() {\n      if (v.value) {\n        if (t.viewport.value && l.value) {\n          const _ = t.viewport.value.scrollLeft, x = dn(\n            _,\n            s.value,\n            t.dir.value\n          );\n          l.value.style.transform = `translate3d(${x}px, 0, 0)`;\n        }\n      } else if (t.viewport.value && l.value) {\n        const _ = t.viewport.value.scrollTop, x = dn(_, s.value);\n        l.value.style.transform = `translate3d(0, ${x}px, 0)`;\n      }\n    }\n    function E(_) {\n      l.value = _;\n    }\n    return Fl({\n      sizes: s,\n      hasThumb: r,\n      handleWheelScroll: u,\n      handleThumbDown: d,\n      handleThumbUp: p,\n      handleSizeChange: c,\n      onThumbPositionChange: w,\n      onThumbChange: E,\n      onDragScroll: g\n    }), (_, x) => v.value ? (h(), C(kl, T({ key: 0 }, _.$attrs, { ref: n(a) }), {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : (h(), C(Vl, T({ key: 1 }, _.$attrs, { ref: n(a) }), {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ra = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarAuto\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = me(), e = Kt(), { forwardRef: a } = $(), s = P(false), r = mo(() => {\n      if (t.viewport.value) {\n        const l = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;\n        s.value = e.isHorizontal.value ? l : i;\n      }\n    }, 10);\n    return q(() => r()), be(t.viewport, r), be(t.content, r), (l, i) => (h(), C(n(se), {\n      present: l.forceMount || s.value\n    }, {\n      default: m(() => [\n        k(Xo, T(l.$attrs, {\n          ref: n(a),\n          \"data-state\": s.value ? \"visible\" : \"hidden\"\n        }), {\n          default: m(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Ll = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"ScrollAreaScrollbarHover\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = me(), { forwardRef: e } = $();\n    let a;\n    const s = P(false);\n    function r() {\n      window.clearTimeout(a), s.value = true;\n    }\n    function l() {\n      a = window.setTimeout(() => {\n        s.value = false;\n      }, t.scrollHideDelay.value);\n    }\n    return q(() => {\n      const i = t.scrollArea.value;\n      i && (i.addEventListener(\"pointerenter\", r), i.addEventListener(\"pointerleave\", l));\n    }), fe(() => {\n      const i = t.scrollArea.value;\n      i && (window.clearTimeout(a), i.removeEventListener(\"pointerenter\", r), i.removeEventListener(\"pointerleave\", l));\n    }), (i, u) => (h(), C(n(se), {\n      present: i.forceMount || s.value\n    }, {\n      default: m(() => [\n        k(ra, T(i.$attrs, {\n          ref: n(e),\n          \"data-state\": s.value ? \"visible\" : \"hidden\"\n        }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Kl = /* @__PURE__ */ b({\n  __name: \"ScrollAreaScrollbarScroll\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = me(), e = Kt(), { forwardRef: a } = $(), { state: s, dispatch: r } = On(\"hidden\", {\n      hidden: {\n        SCROLL: \"scrolling\"\n      },\n      scrolling: {\n        SCROLL_END: \"idle\",\n        POINTER_ENTER: \"interacting\"\n      },\n      interacting: {\n        SCROLL: \"interacting\",\n        POINTER_LEAVE: \"idle\"\n      },\n      idle: {\n        HIDE: \"hidden\",\n        SCROLL: \"scrolling\",\n        POINTER_ENTER: \"interacting\"\n      }\n    });\n    ee((i) => {\n      if (s.value === \"idle\") {\n        const u = window.setTimeout(\n          () => r(\"HIDE\"),\n          t.scrollHideDelay.value\n        );\n        i(() => {\n          window.clearTimeout(u);\n        });\n      }\n    });\n    const l = mo(() => r(\"SCROLL_END\"), 100);\n    return ee((i) => {\n      const u = t.viewport.value, d = e.isHorizontal.value ? \"scrollLeft\" : \"scrollTop\";\n      if (u) {\n        let p = u[d];\n        const c = () => {\n          const f = u[d];\n          p !== f && (r(\"SCROLL\"), l()), p = f;\n        };\n        u.addEventListener(\"scroll\", c), i(() => {\n          u.removeEventListener(\"scroll\", c);\n        });\n      }\n    }), (i, u) => (h(), C(n(se), {\n      present: i.forceMount || n(s) !== \"hidden\"\n    }, {\n      default: m(() => [\n        k(Xo, T(i.$attrs, { ref: n(a) }), {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [Kt, Nl] = H(\"ScrollAreaScrollbar\"), yc = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"ScrollAreaScrollbar\",\n  props: {\n    orientation: { default: \"vertical\" },\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $(), a = me(), s = S(() => t.orientation === \"horizontal\");\n    U(\n      s,\n      () => {\n        s.value ? a.onScrollbarXEnabledChange(true) : a.onScrollbarYEnabledChange(true);\n      },\n      { immediate: true }\n    ), fe(() => {\n      a.onScrollbarXEnabledChange(false), a.onScrollbarYEnabledChange(false);\n    });\n    const { orientation: r, forceMount: l, asChild: i, as: u } = z(t);\n    return Nl({\n      orientation: r,\n      forceMount: l,\n      isHorizontal: s,\n      as: u,\n      asChild: i\n    }), (d, p) => n(a).type.value === \"hover\" ? (h(), C(Ll, T({ key: 0 }, d.$attrs, {\n      ref: n(e),\n      \"force-mount\": n(l)\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : n(a).type.value === \"scroll\" ? (h(), C(Kl, T({ key: 1 }, d.$attrs, {\n      ref: n(e),\n      \"force-mount\": n(l)\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : n(a).type.value === \"auto\" ? (h(), C(ra, T({ key: 2 }, d.$attrs, {\n      ref: n(e),\n      \"force-mount\": n(l)\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : n(a).type.value === \"always\" ? (h(), C(Xo, T({ key: 3 }, d.$attrs, {\n      ref: n(e),\n      \"data-state\": \"visible\"\n    }), {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", true);\n  }\n}), bc = /* @__PURE__ */ b({\n  __name: \"ScrollAreaThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = me(), a = Lt();\n    function s(f) {\n      const g = f.target.getBoundingClientRect(), w = f.clientX - g.left, E = f.clientY - g.top;\n      a.handleThumbDown(f, { x: w, y: E });\n    }\n    function r(f) {\n      a.handleThumbUp(f);\n    }\n    const { forwardRef: l, currentElement: i } = $(), u = P(), d = S(() => e.viewport.value);\n    function p() {\n      if (!u.value) {\n        const f = Rl(\n          d.value,\n          a.onThumbPositionChange\n        );\n        u.value = f, a.onThumbPositionChange();\n      }\n    }\n    const c = S(() => a.sizes.value);\n    return is(c, () => {\n      a.onThumbChange(i.value), d.value && (a.onThumbPositionChange(), d.value.addEventListener(\"scroll\", p));\n    }), fe(() => {\n      var f;\n      d.value.removeEventListener(\"scroll\", p), (f = e.viewport.value) == null || f.removeEventListener(\"scroll\", p);\n    }), (f, v) => (h(), C(n(D), {\n      ref: n(l),\n      \"data-state\": n(a).hasThumb ? \"visible\" : \"hidden\",\n      style: re({\n        width: \"var(--radix-scroll-area-thumb-width)\",\n        height: \"var(--radix-scroll-area-thumb-height)\"\n      }),\n      \"as-child\": t.asChild,\n      as: f.as,\n      onPointerdown: s,\n      onPointerup: r\n    }, {\n      default: m(() => [\n        y(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-state\", \"style\", \"as-child\", \"as\"]));\n  }\n}), Hl = /* @__PURE__ */ b({\n  __name: \"ScrollAreaCornerImpl\",\n  setup(o2) {\n    const t = me(), e = P(0), a = P(0), s = S(() => !!e.value && !!a.value);\n    function r() {\n      var u;\n      const i = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;\n      t.onCornerHeightChange(i), a.value = i;\n    }\n    function l() {\n      var u;\n      const i = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;\n      t.onCornerWidthChange(i), e.value = i;\n    }\n    return be(t.scrollbarX.value, r), be(t.scrollbarY.value, l), U(() => t.scrollbarX.value, r), U(() => t.scrollbarY.value, l), (i, u) => {\n      var d;\n      return s.value ? (h(), C(n(D), T({\n        key: 0,\n        style: {\n          width: `${e.value}px`,\n          height: `${a.value}px`,\n          position: \"absolute\",\n          right: n(t).dir.value === \"ltr\" ? 0 : void 0,\n          left: n(t).dir.value === \"rtl\" ? 0 : void 0,\n          bottom: 0\n        }\n      }, (d = i.$parent) == null ? void 0 : d.$props), {\n        default: m(() => [\n          y(i.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])) : X(\"\", true);\n    };\n  }\n}), Cc = /* @__PURE__ */ b({\n  __name: \"ScrollAreaCorner\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $(), a = me(), s = S(\n      () => !!a.scrollbarX.value && !!a.scrollbarY.value\n    ), r = S(\n      () => a.type.value !== \"scroll\" && s.value\n    );\n    return (l, i) => r.value ? (h(), C(Hl, T({ key: 0 }, t, { ref: n(e) }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", true);\n  }\n}), jl = [\"default-value\"], Wl = /* @__PURE__ */ b({\n  __name: \"BubbleSelect\",\n  props: {\n    autocomplete: {},\n    autofocus: { type: Boolean },\n    disabled: { type: Boolean },\n    form: {},\n    multiple: { type: Boolean },\n    name: {},\n    required: { type: Boolean },\n    size: {},\n    value: {}\n  },\n  setup(o2) {\n    const t = o2, { value: e } = z(t);\n    ms(e);\n    const a = P();\n    return (s, r) => (h(), C(n(Qe), { \"as-child\": \"\" }, {\n      default: m(() => [\n        fo(ut(\"select\", T({\n          ref_key: \"selectElement\",\n          ref: a\n        }, t, {\n          \"onUpdate:modelValue\": r[0] || (r[0] = (l) => dt(e) ? e.value = l : null),\n          \"default-value\": n(e)\n        }), [\n          y(s.$slots, \"default\")\n        ], 16, jl), [\n          [Fa, n(e)]\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), zl = {\n  key: 0,\n  value: \"\"\n}, [Ie, la] = H(\"SelectRoot\"), [Ul, ql] = H(\"SelectRoot\"), wc = /* @__PURE__ */ b({\n  __name: \"SelectRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    defaultValue: { default: \"\" },\n    modelValue: { default: void 0 },\n    dir: {},\n    name: {},\n    autocomplete: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean }\n  },\n  emits: [\"update:modelValue\", \"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), r = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), l = P(), i = P(), u = P({\n      x: 0,\n      y: 0\n    }), d = P(false), { required: p, disabled: c, dir: f } = z(e), v = de(f);\n    la({\n      triggerElement: l,\n      onTriggerChange: (_) => {\n        l.value = _;\n      },\n      valueElement: i,\n      onValueElementChange: (_) => {\n        i.value = _;\n      },\n      valueElementHasChildren: d,\n      onValueElementHasChildrenChange: (_) => {\n        d.value = _;\n      },\n      contentId: te(),\n      modelValue: s,\n      onValueChange: (_) => {\n        s.value = _;\n      },\n      open: r,\n      required: p,\n      onOpenChange: (_) => {\n        r.value = _;\n      },\n      dir: v,\n      triggerPointerDownPosRef: u,\n      disabled: c\n    });\n    const g = Ne(l), w = P(/* @__PURE__ */ new Set()), E = S(() => Array.from(w.value).map((_) => {\n      var x;\n      return (x = _.props) == null ? void 0 : x.value;\n    }).join(\";\"));\n    return ql({\n      onNativeOptionAdd: (_) => {\n        w.value.add(_);\n      },\n      onNativeOptionRemove: (_) => {\n        w.value.delete(_);\n      }\n    }), (_, x) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(_.$slots, \"default\"),\n        n(g) ? (h(), C(Wl, T({ key: E.value }, _.$attrs, {\n          \"aria-hidden\": \"\",\n          tabindex: \"-1\",\n          required: n(p),\n          name: _.name,\n          autocomplete: _.autocomplete,\n          disabled: n(c),\n          value: n(s),\n          onChange: x[0] || (x[0] = (B) => s.value = B.target.value)\n        }), {\n          default: m(() => [\n            n(s) === void 0 ? (h(), Q(\"option\", zl)) : X(\"\", true),\n            (h(true), Q(le, null, po(Array.from(w.value), (B) => (h(), C(we(B), T(B.props, {\n              key: B.key ?? \"\"\n            }), null, 16))), 128))\n          ]),\n          _: 1\n        }, 16, [\"required\", \"name\", \"autocomplete\", \"disabled\", \"value\"])) : X(\"\", true)\n      ]),\n      _: 3\n    }));\n  }\n}), Gl = [\" \", \"Enter\", \"ArrowUp\", \"ArrowDown\"], Yl = [\" \", \"Enter\"], Ce = 10;\nfunction ia(o2) {\n  return o2 === \"\" || o2 === void 0;\n}\nconst _c = /* @__PURE__ */ b({\n  __name: \"SelectTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = Ie(), a = S(() => {\n      var f;\n      return ((f = e.disabled) == null ? void 0 : f.value) || t.disabled;\n    }), { forwardRef: s, currentElement: r } = $();\n    q(() => {\n      e.triggerElement = r;\n    });\n    const { injectCollection: l } = ve(), i = l(), { search: u, handleTypeaheadSearch: d, resetTypeahead: p } = bo(i);\n    function c() {\n      a.value || (e.onOpenChange(true), p());\n    }\n    return (f, v) => (h(), C(n(We), { \"as-child\": \"\" }, {\n      default: m(() => {\n        var g, w, E, _;\n        return [\n          k(n(D), {\n            ref: n(s),\n            role: \"combobox\",\n            type: f.as === \"button\" ? \"button\" : void 0,\n            \"aria-controls\": n(e).contentId,\n            \"aria-expanded\": n(e).open.value || false,\n            \"aria-required\": (g = n(e).required) == null ? void 0 : g.value,\n            \"aria-autocomplete\": \"none\",\n            disabled: a.value,\n            dir: (w = n(e)) == null ? void 0 : w.dir.value,\n            \"data-state\": (E = n(e)) != null && E.open.value ? \"open\" : \"closed\",\n            \"data-disabled\": a.value ? \"\" : void 0,\n            \"data-placeholder\": n(ia)((_ = n(e).modelValue) == null ? void 0 : _.value) ? \"\" : void 0,\n            \"as-child\": f.asChild,\n            as: f.as,\n            onClick: v[0] || (v[0] = (x) => {\n              var B;\n              (B = x == null ? void 0 : x.currentTarget) == null || B.focus();\n            }),\n            onPointerdown: v[1] || (v[1] = (x) => {\n              const B = x.target;\n              B.hasPointerCapture(x.pointerId) && B.releasePointerCapture(x.pointerId), x.button === 0 && x.ctrlKey === false && (c(), n(e).triggerPointerDownPosRef.value = {\n                x: Math.round(x.pageX),\n                y: Math.round(x.pageY)\n              }, x.preventDefault());\n            }),\n            onPointerup: v[2] || (v[2] = oe(() => {\n            }, [\"prevent\"])),\n            onKeydown: v[3] || (v[3] = (x) => {\n              const B = n(u) !== \"\";\n              !(x.ctrlKey || x.altKey || x.metaKey) && x.key.length === 1 && B && x.key === \" \" || (n(d)(x.key), n(Gl).includes(x.key) && (c(), x.preventDefault()));\n            })\n          }, {\n            default: m(() => [\n              y(f.$slots, \"default\")\n            ]),\n            _: 3\n          }, 8, [\"type\", \"aria-controls\", \"aria-expanded\", \"aria-required\", \"disabled\", \"dir\", \"data-state\", \"data-disabled\", \"data-placeholder\", \"as-child\", \"as\"])\n        ];\n      }),\n      _: 3\n    }));\n  }\n}), $c = /* @__PURE__ */ b({\n  __name: \"SelectPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Jo, Xl] = H(\"SelectItemAlignedPosition\"), Jl = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"SelectItemAlignedPosition\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"placed\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { injectCollection: s } = ve(), r = Ie(), l = Ae(), i = s(), u = P(false), d = P(true), p = P(), { forwardRef: c, currentElement: f } = $(), { viewport: v, selectedItem: g, selectedItemText: w, focusSelectedItem: E } = l;\n    function _() {\n      if (r.triggerElement.value && r.valueElement.value && p.value && f.value && (v != null && v.value) && (g != null && g.value) && (w != null && w.value)) {\n        const O = r.triggerElement.value.getBoundingClientRect(), A = f.value.getBoundingClientRect(), M = r.valueElement.value.getBoundingClientRect(), R = w.value.getBoundingClientRect();\n        if (r.dir.value !== \"rtl\") {\n          const Re = R.left - A.left, xe = M.left - Re, Me = O.left - xe, ke = O.width + Me, Gt = Math.max(ke, A.width), Yt = window.innerWidth - Ce, Xt = on(xe, Ce, Yt - Gt);\n          p.value.style.minWidth = `${ke}px`, p.value.style.left = `${Xt}px`;\n        } else {\n          const Re = A.right - R.right, xe = window.innerWidth - M.right - Re, Me = window.innerWidth - O.right - xe, ke = O.width + Me, Gt = Math.max(ke, A.width), Yt = window.innerWidth - Ce, Xt = on(\n            xe,\n            Ce,\n            Yt - Gt\n          );\n          p.value.style.minWidth = `${ke}px`, p.value.style.right = `${Xt}px`;\n        }\n        const V = i.value, j = window.innerHeight - Ce * 2, I = v.value.scrollHeight, F = window.getComputedStyle(f.value), W = Number.parseInt(\n          F.borderTopWidth,\n          10\n        ), J = Number.parseInt(F.paddingTop, 10), K = Number.parseInt(\n          F.borderBottomWidth,\n          10\n        ), Z = Number.parseInt(\n          F.paddingBottom,\n          10\n        ), ne = W + J + I + Z + K, Ut = Math.min(\n          g.value.offsetHeight * 5,\n          ne\n        ), at = window.getComputedStyle(v.value), mt = Number.parseInt(at.paddingTop, 10), Sa = Number.parseInt(\n          at.paddingBottom,\n          10\n        ), ht = O.top + O.height / 2 - Ce, Ta = j - ht, qt = g.value.offsetHeight / 2, Da = g.value.offsetTop + qt, gt = W + J + Da, Oa = ne - gt;\n        if (gt <= ht) {\n          const Re = g.value === V[V.length - 1];\n          p.value.style.bottom = \"0px\";\n          const xe = f.value.clientHeight - v.value.offsetTop - v.value.offsetHeight, Me = Math.max(\n            Ta,\n            qt + (Re ? Sa : 0) + xe + K\n          ), ke = gt + Me;\n          p.value.style.height = `${ke}px`;\n        } else {\n          const Re = g.value === V[0];\n          p.value.style.top = \"0px\";\n          const Me = Math.max(\n            ht,\n            W + v.value.offsetTop + (Re ? mt : 0) + qt\n          ) + Oa;\n          p.value.style.height = `${Me}px`, v.value.scrollTop = gt - ht + v.value.offsetTop;\n        }\n        p.value.style.margin = `${Ce}px 0`, p.value.style.minHeight = `${Ut}px`, p.value.style.maxHeight = `${j}px`, a(\"placed\"), requestAnimationFrame(() => u.value = true);\n      }\n    }\n    const x = P(\"\");\n    q(async () => {\n      await G(), _(), f.value && (x.value = window.getComputedStyle(f.value).zIndex);\n    });\n    function B(O) {\n      O && d.value === true && (_(), E == null || E(), d.value = false);\n    }\n    return Xl({\n      contentWrapper: p,\n      shouldExpandOnScrollRef: u,\n      onScrollButtonChange: B\n    }), (O, A) => (h(), Q(\"div\", {\n      ref_key: \"contentWrapperElement\",\n      ref: p,\n      style: re({\n        display: \"flex\",\n        flexDirection: \"column\",\n        position: \"fixed\",\n        zIndex: x.value\n      })\n    }, [\n      k(n(D), T({\n        ref: n(c),\n        style: {\n          // When we get the height of the content, it includes borders. If we were to set\n          // the height without having `boxSizing: 'border-box'` it would be too big.\n          boxSizing: \"border-box\",\n          // We need to ensure the content doesn't get taller than the wrapper\n          maxHeight: \"100%\"\n        }\n      }, { ...O.$attrs, ...e }), {\n        default: m(() => [\n          y(O.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])\n    ], 4));\n  }\n}), Zl = /* @__PURE__ */ b({\n  __name: \"SelectPopperPosition\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: { default: Ce },\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const e = He(o2);\n    return (a, s) => (h(), C(n(Fe), T(n(e), { style: {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-select-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-select-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-select-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-select-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-select-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"]));\n  }\n}), nt = {\n  onViewportChange: () => {\n  },\n  itemTextRefCallback: () => {\n  },\n  itemRefCallback: () => {\n  }\n}, [Ae, Ql] = H(\"SelectContent\"), ei = /* @__PURE__ */ b({\n  __name: \"SelectContentImpl\",\n  props: {\n    position: { default: \"item-aligned\" },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = Ie();\n    yo(), ct(true);\n    const { createCollection: r } = ve(), l = P();\n    pt(l);\n    const i = r(l), { search: u, handleTypeaheadSearch: d } = bo(i), p = P(), c = P(), f = P(), v = P(false), g = P(false);\n    function w() {\n      c.value && l.value && ao([c.value, l.value]);\n    }\n    U(v, () => {\n      w();\n    });\n    const { onOpenChange: E, triggerPointerDownPosRef: _ } = s;\n    ee((A) => {\n      if (!l.value)\n        return;\n      let M = { x: 0, y: 0 };\n      const R = (j) => {\n        var I, F;\n        M = {\n          x: Math.abs(\n            Math.round(j.pageX) - (((I = _.value) == null ? void 0 : I.x) ?? 0)\n          ),\n          y: Math.abs(\n            Math.round(j.pageY) - (((F = _.value) == null ? void 0 : F.y) ?? 0)\n          )\n        };\n      }, V = (j) => {\n        var I;\n        M.x <= 10 && M.y <= 10 ? j.preventDefault() : (I = l.value) != null && I.contains(j.target) || E(false), document.removeEventListener(\"pointermove\", R), _.value = null;\n      };\n      _.value !== null && (document.addEventListener(\"pointermove\", R), document.addEventListener(\"pointerup\", V, {\n        capture: true,\n        once: true\n      })), A(() => {\n        document.removeEventListener(\"pointermove\", R), document.removeEventListener(\"pointerup\", V, {\n          capture: true\n        });\n      });\n    });\n    function x(A) {\n      const M = A.ctrlKey || A.altKey || A.metaKey;\n      if (A.key === \"Tab\" && A.preventDefault(), !M && A.key.length === 1 && d(A.key), [\"ArrowUp\", \"ArrowDown\", \"Home\", \"End\"].includes(A.key)) {\n        let R = i.value;\n        if ([\"ArrowUp\", \"End\"].includes(A.key) && (R = R.slice().reverse()), [\"ArrowUp\", \"ArrowDown\"].includes(A.key)) {\n          const V = A.target, j = R.indexOf(V);\n          R = R.slice(j + 1);\n        }\n        setTimeout(() => ao(R)), A.preventDefault();\n      }\n    }\n    const B = S(() => e.position === \"popper\" ? e : {}), O = He(B.value);\n    return Ql({\n      content: l,\n      viewport: p,\n      onViewportChange: (A) => {\n        p.value = A;\n      },\n      itemRefCallback: (A, M, R) => {\n        var I, F;\n        const V = !g.value && !R;\n        (((I = s.modelValue) == null ? void 0 : I.value) !== void 0 && ((F = s.modelValue) == null ? void 0 : F.value) === M || V) && (c.value = A, V && (g.value = true));\n      },\n      selectedItem: c,\n      selectedItemText: f,\n      onItemLeave: () => {\n        var A;\n        (A = l.value) == null || A.focus();\n      },\n      itemTextRefCallback: (A, M, R) => {\n        var I, F;\n        const V = !g.value && !R;\n        (((I = s.modelValue) == null ? void 0 : I.value) !== void 0 && ((F = s.modelValue) == null ? void 0 : F.value) === M || V) && (f.value = A);\n      },\n      focusSelectedItem: w,\n      position: e.position,\n      isPositioned: v,\n      searchRef: u\n    }), (A, M) => (h(), C(n(At), {\n      \"as-child\": \"\",\n      onMountAutoFocus: M[6] || (M[6] = oe(() => {\n      }, [\"prevent\"])),\n      onUnmountAutoFocus: M[7] || (M[7] = (R) => {\n        var V;\n        a(\"closeAutoFocus\", R), !R.defaultPrevented && ((V = n(s).triggerElement.value) == null || V.focus({ preventScroll: true }), R.preventDefault());\n      })\n    }, {\n      default: m(() => [\n        k(n(De), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": \"\",\n          onFocusOutside: M[2] || (M[2] = oe(() => {\n          }, [\"prevent\"])),\n          onDismiss: M[3] || (M[3] = (R) => n(s).onOpenChange(false)),\n          onEscapeKeyDown: M[4] || (M[4] = (R) => a(\"escapeKeyDown\", R)),\n          onPointerDownOutside: M[5] || (M[5] = (R) => a(\"pointerDownOutside\", R))\n        }, {\n          default: m(() => [\n            (h(), C(we(\n              A.position === \"popper\" ? Zl : Jl\n            ), T({ ...A.$attrs, ...n(O) }, {\n              id: n(s).contentId,\n              ref: (R) => {\n                l.value = n(pe)(R);\n              },\n              role: \"listbox\",\n              \"data-state\": n(s).open.value ? \"open\" : \"closed\",\n              dir: n(s).dir.value,\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\"\n              },\n              onContextmenu: M[0] || (M[0] = oe(() => {\n              }, [\"prevent\"])),\n              onPlaced: M[1] || (M[1] = (R) => v.value = true),\n              onKeydown: x\n            }), {\n              default: m(() => [\n                y(A.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"dir\", \"onKeydown\"]))\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }));\n  }\n}), ti = /* @__PURE__ */ b({\n  __name: \"SelectProvider\",\n  props: {\n    context: {}\n  },\n  setup(o2) {\n    return la(o2.context), (e, a) => y(e.$slots, \"default\");\n  }\n}), xc = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"SelectContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o2, { emit: t }) {\n    const s = ae(o2, t), r = Ie(), l = P();\n    q(() => {\n      l.value = new DocumentFragment();\n    });\n    const i = P();\n    return (u, d) => {\n      var p;\n      return h(), Q(le, null, [\n        k(n(se), {\n          ref_key: \"presenceRef\",\n          ref: i,\n          present: u.forceMount || n(r).open.value\n        }, {\n          default: m(() => [\n            k(ei, L(N({ ...n(s), ...u.$attrs })), {\n              default: m(() => [\n                y(u.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16)\n          ]),\n          _: 3\n        }, 8, [\"present\"]),\n        !((p = i.value) != null && p.present) && l.value ? (h(), C(Ye, {\n          key: 0,\n          to: l.value\n        }, [\n          k(ti, { context: n(r) }, {\n            default: m(() => [\n              ut(\"div\", null, [\n                y(u.$slots, \"default\")\n              ])\n            ]),\n            _: 3\n          }, 8, [\"context\"])\n        ], 8, [\"to\"])) : X(\"\", true)\n      ], 64);\n    };\n  }\n}), Ec = /* @__PURE__ */ b({\n  __name: \"SelectArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const t = o2, e = Ie(), a = Ae();\n    return (s, r) => n(e).open.value && n(a).position === \"popper\" ? (h(), C(n(Ze), L(T({ key: 0 }, t)), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", true);\n  }\n}), Pc = /* @__PURE__ */ b({\n  __name: \"SelectSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(D), T({ \"aria-hidden\": \"\" }, t), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [ua, oi] = H(\"SelectItem\"), Bc = /* @__PURE__ */ b({\n  __name: \"SelectItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { disabled: e } = z(t), a = Ie(), s = Ae(nt), { forwardRef: r, currentElement: l } = $(), i = S(() => {\n      var w;\n      return ((w = a.modelValue) == null ? void 0 : w.value) === t.value;\n    }), u = P(false), d = P(t.textValue ?? \"\"), p = te();\n    async function c(w) {\n      await G(), !(w != null && w.defaultPrevented) && (e.value || (a.onValueChange(t.value), a.onOpenChange(false)));\n    }\n    async function f(w) {\n      var E;\n      await G(), !w.defaultPrevented && (e.value ? (E = s.onItemLeave) == null || E.call(s) : w.currentTarget.focus({ preventScroll: true }));\n    }\n    async function v(w) {\n      var E;\n      await G(), !w.defaultPrevented && w.currentTarget === document.activeElement && ((E = s.onItemLeave) == null || E.call(s));\n    }\n    async function g(w) {\n      var _;\n      await G(), !(w.defaultPrevented || ((_ = s.searchRef) == null ? void 0 : _.value) !== \"\" && w.key === \" \") && (Yl.includes(w.key) && c(), w.key === \" \" && w.preventDefault());\n    }\n    if (t.value === \"\")\n      throw new Error(\n        \"A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return q(() => {\n      l.value && s.itemRefCallback(\n        l.value,\n        t.value,\n        t.disabled\n      );\n    }), oi({\n      value: t.value,\n      disabled: e,\n      textId: p,\n      isSelected: i,\n      onItemTextChange: (w) => {\n        d.value = ((d.value || (w == null ? void 0 : w.textContent)) ?? \"\").trim();\n      }\n    }), (w, E) => (h(), C(n(D), {\n      ref: n(r),\n      role: \"option\",\n      \"data-radix-vue-collection-item\": \"\",\n      \"aria-labelledby\": n(p),\n      \"data-highlighted\": u.value ? \"\" : void 0,\n      \"aria-selected\": i.value && u.value,\n      \"data-state\": i.value ? \"checked\" : \"unchecked\",\n      \"aria-disabled\": n(e) || void 0,\n      \"data-disabled\": n(e) ? \"\" : void 0,\n      tabindex: n(e) ? void 0 : -1,\n      as: w.as,\n      \"as-child\": w.asChild,\n      onFocus: E[0] || (E[0] = (_) => u.value = true),\n      onBlur: E[1] || (E[1] = (_) => u.value = false),\n      onPointerup: c,\n      onTouchend: E[2] || (E[2] = oe(() => {\n      }, [\"prevent\", \"stop\"])),\n      onPointermove: f,\n      onPointerleave: v,\n      onKeydown: g\n    }, {\n      default: m(() => [\n        y(w.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"tabindex\", \"as\", \"as-child\"]));\n  }\n}), Sc = /* @__PURE__ */ b({\n  __name: \"SelectItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = o2, e = ua();\n    return (a, s) => n(e).isSelected.value ? (h(), C(n(D), T({\n      key: 0,\n      \"aria-hidden\": \"\"\n    }, t), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", true);\n  }\n}), [ni, ai] = H(\"SelectGroup\"), Tc = /* @__PURE__ */ b({\n  __name: \"SelectGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = te();\n    return ai({ id: e }), (a, s) => (h(), C(n(D), T({ role: \"group\" }, t, { \"aria-labelledby\": n(e) }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"]));\n  }\n}), Dc = /* @__PURE__ */ b({\n  __name: \"SelectLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(o2) {\n    const t = o2, e = ni({ id: \"\" });\n    return (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).id\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Oc = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"SelectItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = o2, e = Ie(), a = Ae(nt), s = Ul(), r = ua(), { forwardRef: l, currentElement: i } = $(), u = S(() => {\n      var d;\n      return Ve(\"option\", {\n        key: r.value,\n        value: r.value,\n        disabled: r.disabled.value,\n        innerHTML: (d = i.value) == null ? void 0 : d.textContent\n      });\n    });\n    return q(() => {\n      i.value && (r.onItemTextChange(i.value), a.itemTextRefCallback(\n        i.value,\n        r.value,\n        r.disabled.value\n      ), s.onNativeOptionAdd(u.value));\n    }), co(() => {\n      s.onNativeOptionRemove(u.value);\n    }), (d, p) => (h(), Q(le, null, [\n      k(n(D), T({\n        id: n(r).textId,\n        ref: n(l)\n      }, { ...t, ...d.$attrs }), {\n        default: m(() => [\n          y(d.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\"]),\n      n(r).isSelected.value && n(e).valueElement.value && !n(e).valueElementHasChildren.value ? (h(), C(Ye, {\n        key: 0,\n        to: n(e).valueElement.value\n      }, [\n        y(d.$slots, \"default\")\n      ], 8, [\"to\"])) : X(\"\", true)\n    ], 64));\n  }\n}), Ic = /* @__PURE__ */ b({\n  __name: \"SelectViewport\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = Ae(nt), a = e.position === \"item-aligned\" ? Jo() : void 0, { forwardRef: s, currentElement: r } = $();\n    q(() => {\n      e == null || e.onViewportChange(r.value);\n    });\n    const l = P(0);\n    function i(u) {\n      const d = u.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: c } = a ?? {};\n      if (p != null && p.value && (c != null && c.value)) {\n        const f = Math.abs(l.value - d.scrollTop);\n        if (f > 0) {\n          const v = window.innerHeight - Ce * 2, g = Number.parseFloat(\n            c.value.style.minHeight\n          ), w = Number.parseFloat(c.value.style.height), E = Math.max(g, w);\n          if (E < v) {\n            const _ = E + f, x = Math.min(v, _), B = _ - x;\n            c.value.style.height = `${x}px`, c.value.style.bottom === \"0px\" && (d.scrollTop = B > 0 ? B : 0, c.value.style.justifyContent = \"flex-end\");\n          }\n        }\n      }\n      l.value = d.scrollTop;\n    }\n    return (u, d) => (h(), Q(le, null, [\n      k(n(D), T({\n        ref: n(s),\n        \"data-radix-select-viewport\": \"\",\n        role: \"presentation\"\n      }, { ...u.$attrs, ...t }, {\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        },\n        onScroll: i\n      }), {\n        default: m(() => [\n          y(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"]),\n      k(n(D), { as: \"style\" }, {\n        default: m(() => [\n          ue(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      })\n    ], 64));\n  }\n}), da = /* @__PURE__ */ b({\n  __name: \"SelectScrollButtonImpl\",\n  emits: [\"autoScroll\"],\n  setup(o2, { emit: t }) {\n    const e = t, { injectCollection: a } = ve(), s = a(), r = Ae(nt), l = P(null);\n    function i() {\n      l.value !== null && (window.clearInterval(l.value), l.value = null);\n    }\n    ee(() => {\n      const p = s.value.find(\n        (c) => c === document.activeElement\n      );\n      p == null || p.scrollIntoView({ block: \"nearest\" });\n    });\n    function u() {\n      l.value === null && (l.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    function d() {\n      var p;\n      (p = r.onItemLeave) == null || p.call(r), l.value === null && (l.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    return co(() => i()), (p, c) => {\n      var f;\n      return h(), C(n(D), T({\n        \"aria-hidden\": \"\",\n        style: {\n          flexShrink: 0\n        }\n      }, (f = p.$parent) == null ? void 0 : f.$props, {\n        onPointerdown: u,\n        onPointermove: d,\n        onPointerleave: c[0] || (c[0] = () => {\n          i();\n        })\n      }), {\n        default: m(() => [\n          y(p.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16);\n    };\n  }\n}), Ac = /* @__PURE__ */ b({\n  __name: \"SelectScrollUpButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = Ae(nt), e = t.position === \"item-aligned\" ? Jo() : void 0, { forwardRef: a, currentElement: s } = $(), r = P(false);\n    return ee((l) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          r.value = p.scrollTop > 0;\n        };\n        const p = t.viewport.value;\n        d(), p.addEventListener(\"scroll\", d), l(() => p.removeEventListener(\"scroll\", d));\n      }\n    }), U(s, () => {\n      s.value && (e == null || e.onScrollButtonChange(s.value));\n    }), (l, i) => r.value ? (h(), C(da, {\n      key: 0,\n      ref: n(a),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = n(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);\n      })\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : X(\"\", true);\n  }\n}), Rc = /* @__PURE__ */ b({\n  __name: \"SelectScrollDownButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = Ae(nt), e = t.position === \"item-aligned\" ? Jo() : void 0, { forwardRef: a, currentElement: s } = $(), r = P(false);\n    return ee((l) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          const c = p.scrollHeight - p.clientHeight;\n          r.value = Math.ceil(p.scrollTop) < c;\n        };\n        const p = t.viewport.value;\n        d(), p.addEventListener(\"scroll\", d), l(() => p.removeEventListener(\"scroll\", d));\n      }\n    }), U(s, () => {\n      s.value && (e == null || e.onScrollButtonChange(s.value));\n    }), (l, i) => r.value ? (h(), C(da, {\n      key: 0,\n      ref: n(a),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = n(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);\n      })\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : X(\"\", true);\n  }\n}), Mc = /* @__PURE__ */ b({\n  __name: \"SelectValue\",\n  props: {\n    placeholder: { default: \"\" },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const { forwardRef: t, currentElement: e } = $(), a = Ie(), s = xn();\n    return $n(() => {\n      var l;\n      const r = !!Ot((l = s == null ? void 0 : s.default) == null ? void 0 : l.call(s)).length;\n      a.onValueElementHasChildrenChange(r);\n    }), q(() => {\n      a.valueElement = e;\n    }), (r, l) => (h(), C(n(D), {\n      ref: n(t),\n      as: r.as,\n      \"as-child\": r.asChild,\n      style: { pointerEvents: \"none\" }\n    }, {\n      default: m(() => {\n        var i;\n        return [\n          n(ia)((i = n(a).modelValue) == null ? void 0 : i.value) ? (h(), Q(le, { key: 0 }, [\n            ue(Le(r.placeholder), 1)\n          ], 64)) : y(r.$slots, \"default\", { key: 1 })\n        ];\n      }),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), kc = /* @__PURE__ */ b({\n  __name: \"SelectIcon\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    return (t, e) => (h(), C(n(D), {\n      \"aria-hidden\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild\n    }, {\n      default: m(() => [\n        y(t.$slots, \"default\", {}, () => [\n          ue(\"\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), ca = /* @__PURE__ */ b({\n  __name: \"BaseSeparator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = [\"horizontal\", \"vertical\"];\n    function a(i) {\n      return e.includes(i);\n    }\n    const s = S(\n      () => a(t.orientation) ? t.orientation : \"horizontal\"\n    ), r = S(\n      () => s.value === \"vertical\" ? t.orientation : void 0\n    ), l = S(\n      () => t.decorative ? { role: \"none\" } : { \"aria-orientation\": r.value, role: \"separator\" }\n    );\n    return (i, u) => (h(), C(n(D), T({\n      as: i.as,\n      \"as-child\": i.asChild,\n      \"data-orientation\": s.value\n    }, l.value), {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"data-orientation\"]));\n  }\n}), Vc = /* @__PURE__ */ b({\n  __name: \"Separator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(ca, L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction pa(o2, [t, e]) {\n  return Math.min(e, Math.max(t, o2));\n}\nfunction si(o2 = [], t, e) {\n  const a = [...o2];\n  return a[e] = t, a.sort((s, r) => s - r);\n}\nfunction fa(o2, t, e) {\n  const r = 100 / (e - t) * (o2 - t);\n  return pa(r, [0, 100]);\n}\nfunction ri(o2, t) {\n  return t > 2 ? `Value ${o2 + 1} of ${t}` : t === 2 ? [\"Minimum\", \"Maximum\"][o2] : void 0;\n}\nfunction li(o2, t) {\n  if (o2.length === 1)\n    return 0;\n  const e = o2.map((s) => Math.abs(s - t)), a = Math.min(...e);\n  return e.indexOf(a);\n}\nfunction ii(o2, t, e) {\n  const a = o2 / 2, r = Zo([0, 50], [0, a]);\n  return (a - r(t) * e) * e;\n}\nfunction ui(o2) {\n  return o2.slice(0, -1).map((t, e) => o2[e + 1] - t);\n}\nfunction di(o2, t) {\n  if (t > 0) {\n    const e = ui(o2);\n    return Math.min(...e) >= t;\n  }\n  return true;\n}\nfunction Zo(o2, t) {\n  return (e) => {\n    if (o2[0] === o2[1] || t[0] === t[1])\n      return t[0];\n    const a = (t[1] - t[0]) / (o2[1] - o2[0]);\n    return t[0] + a * (e - o2[0]);\n  };\n}\nfunction ci(o2) {\n  return (String(o2).split(\".\")[1] || \"\").length;\n}\nfunction pi(o2, t) {\n  const e = 10 ** t;\n  return Math.round(o2 * e) / e;\n}\nconst va = [\"PageUp\", \"PageDown\"], ma = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"], ha = {\n  \"from-left\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-right\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowRight\"],\n  \"from-bottom\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-top\": [\"Home\", \"PageDown\", \"ArrowUp\", \"ArrowLeft\"]\n}, [ga, ya] = H([\"SliderVertical\", \"SliderHorizontal\"]), ba = /* @__PURE__ */ b({\n  __name: \"SliderImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  emits: [\"slideStart\", \"slideMove\", \"slideEnd\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = Nt();\n    return (r, l) => (h(), C(n(D), T({ \"data-slider-impl\": \"\" }, e, {\n      onKeydown: l[0] || (l[0] = (i) => {\n        i.key === \"Home\" ? (a(\"homeKeyDown\", i), i.preventDefault()) : i.key === \"End\" ? (a(\"endKeyDown\", i), i.preventDefault()) : n(va).concat(n(ma)).includes(i.key) && (a(\"stepKeyDown\", i), i.preventDefault());\n      }),\n      onPointerdown: l[1] || (l[1] = (i) => {\n        const u = i.target;\n        u.setPointerCapture(i.pointerId), i.preventDefault(), n(s).thumbElements.value.includes(u) ? u.focus() : a(\"slideStart\", i);\n      }),\n      onPointermove: l[2] || (l[2] = (i) => {\n        i.target.hasPointerCapture(i.pointerId) && a(\"slideMove\", i);\n      }),\n      onPointerup: l[3] || (l[3] = (i) => {\n        const u = i.target;\n        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), a(\"slideEnd\", i));\n      })\n    }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fi = /* @__PURE__ */ b({\n  __name: \"SliderHorizontal\",\n  props: {\n    dir: {},\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { max: s, min: r, dir: l, inverted: i } = z(e), { forwardRef: u, currentElement: d } = $(), p = P(), c = S(() => (l == null ? void 0 : l.value) === \"ltr\" && !i.value || (l == null ? void 0 : l.value) !== \"ltr\" && i.value);\n    function f(v) {\n      const g = p.value || d.value.getBoundingClientRect(), w = [0, g.width], E = c.value ? [r.value, s.value] : [s.value, r.value], _ = Zo(w, E);\n      return p.value = g, _(v - g.left);\n    }\n    return ya({\n      startEdge: c.value ? \"left\" : \"right\",\n      endEdge: c.value ? \"right\" : \"left\",\n      direction: c.value ? 1 : -1,\n      size: \"width\"\n    }), (v, g) => (h(), C(ba, {\n      ref: n(u),\n      dir: n(l),\n      \"data-orientation\": \"horizontal\",\n      style: re({\n        \"--radix-slider-thumb-transform\": \"translateX(-50%)\"\n      }),\n      onSlideStart: g[0] || (g[0] = (w) => {\n        const E = f(w.clientX);\n        a(\"slideStart\", E);\n      }),\n      onSlideMove: g[1] || (g[1] = (w) => {\n        const E = f(w.clientX);\n        a(\"slideMove\", E);\n      }),\n      onSlideEnd: g[2] || (g[2] = () => {\n        p.value = void 0, a(\"slideEnd\");\n      }),\n      onStepKeyDown: g[3] || (g[3] = (w) => {\n        const E = c.value ? \"from-left\" : \"from-right\", _ = n(ha)[E].includes(w.key);\n        a(\"stepKeyDown\", w, _ ? -1 : 1);\n      }),\n      onEndKeyDown: g[4] || (g[4] = (w) => a(\"endKeyDown\", w)),\n      onHomeKeyDown: g[5] || (g[5] = (w) => a(\"homeKeyDown\", w))\n    }, {\n      default: m(() => [\n        y(v.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"dir\", \"style\"]));\n  }\n}), vi = /* @__PURE__ */ b({\n  __name: \"SliderVertical\",\n  props: {\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { max: s, min: r, inverted: l } = z(e), { forwardRef: i, currentElement: u } = $(), d = P(), p = S(() => !l.value);\n    function c(f) {\n      const v = d.value || u.value.getBoundingClientRect(), g = [0, v.height], w = p.value ? [s.value, r.value] : [r.value, s.value], E = Zo(g, w);\n      return d.value = v, E(f - v.top);\n    }\n    return ya({\n      startEdge: p.value ? \"bottom\" : \"top\",\n      endEdge: p.value ? \"top\" : \"bottom\",\n      size: \"height\",\n      direction: p.value ? 1 : -1\n    }), (f, v) => (h(), C(ba, {\n      ref: n(i),\n      \"data-orientation\": \"vertical\",\n      style: re({\n        \"--radix-slider-thumb-transform\": \"translateY(50%)\"\n      }),\n      onSlideStart: v[0] || (v[0] = (g) => {\n        const w = c(g.clientY);\n        a(\"slideStart\", w);\n      }),\n      onSlideMove: v[1] || (v[1] = (g) => {\n        const w = c(g.clientY);\n        a(\"slideMove\", w);\n      }),\n      onSlideEnd: v[2] || (v[2] = () => {\n        d.value = void 0, a(\"slideEnd\");\n      }),\n      onStepKeyDown: v[3] || (v[3] = (g) => {\n        const w = p.value ? \"from-bottom\" : \"from-top\", E = n(ha)[w].includes(g.key);\n        a(\"stepKeyDown\", g, E ? -1 : 1);\n      }),\n      onEndKeyDown: v[4] || (v[4] = (g) => a(\"endKeyDown\", g)),\n      onHomeKeyDown: v[5] || (v[5] = (g) => a(\"homeKeyDown\", g))\n    }, {\n      default: m(() => [\n        y(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), mi = [\"value\", \"name\", \"disabled\", \"step\"], [Nt, hi] = H(\"SliderRoot\"), Fc = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"SliderRoot\",\n  props: {\n    name: {},\n    defaultValue: { default: () => [0] },\n    modelValue: {},\n    disabled: { type: Boolean, default: false },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    inverted: { type: Boolean, default: false },\n    min: { default: 0 },\n    max: { default: 100 },\n    step: { default: 1 },\n    minStepsBetweenThumbs: { default: 0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"valueCommit\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { min: s, max: r, step: l, minStepsBetweenThumbs: i, orientation: u, disabled: d, dir: p } = z(e), c = de(p), { forwardRef: f, currentElement: v } = $(), g = Ne(v);\n    Bo();\n    const w = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), E = P(0), _ = P(w.value);\n    function x(R) {\n      const V = li(w.value, R);\n      A(R, V);\n    }\n    function B(R) {\n      A(R, E.value);\n    }\n    function O() {\n      const R = _.value[E.value];\n      w.value[E.value] !== R && a(\"valueCommit\", La(w.value));\n    }\n    function A(R, V, { commit: j } = { commit: false }) {\n      var K;\n      const I = ci(l.value), F = pi(Math.round((R - s.value) / l.value) * l.value + s.value, I), W = pa(F, [s.value, r.value]), J = si(w.value, W, V);\n      if (di(J, i.value * l.value)) {\n        E.value = J.indexOf(W);\n        const Z = String(J) !== String(w.value);\n        Z && j && a(\"valueCommit\", J), Z && ((K = M.value[E.value]) == null || K.focus(), w.value = J);\n      }\n    }\n    const M = P([]);\n    return hi({\n      modelValue: w,\n      valueIndexToChangeRef: E,\n      thumbElements: M,\n      orientation: u,\n      min: s,\n      max: r,\n      disabled: d\n    }), (R, V) => (h(), Q(le, null, [\n      k(n(So), null, {\n        default: m(() => [\n          (h(), C(we(n(u) === \"horizontal\" ? fi : vi), T(R.$attrs, {\n            ref: n(f),\n            \"as-child\": R.asChild,\n            as: R.as,\n            min: n(s),\n            max: n(r),\n            dir: n(c),\n            inverted: R.inverted,\n            \"aria-disabled\": n(d),\n            \"data-disabled\": n(d) ? \"\" : void 0,\n            onPointerdown: V[0] || (V[0] = () => {\n              n(d) || (_.value = n(w));\n            }),\n            onSlideStart: V[1] || (V[1] = (j) => !n(d) && x(j)),\n            onSlideMove: V[2] || (V[2] = (j) => !n(d) && B(j)),\n            onSlideEnd: V[3] || (V[3] = (j) => !n(d) && O()),\n            onHomeKeyDown: V[4] || (V[4] = (j) => !n(d) && A(n(s), 0, { commit: true })),\n            onEndKeyDown: V[5] || (V[5] = (j) => !n(d) && A(n(r), n(w).length - 1, { commit: true })),\n            onStepKeyDown: V[6] || (V[6] = (j, I) => {\n              if (!n(d)) {\n                const J = n(va).includes(j.key) || j.shiftKey && n(ma).includes(j.key) ? 10 : 1, K = E.value, Z = n(w)[K], ne = n(l) * J * I;\n                A(Z + ne, K, { commit: true });\n              }\n            })\n          }), {\n            default: m(() => [\n              y(R.$slots, \"default\", { modelValue: n(w) })\n            ]),\n            _: 3\n          }, 16, [\"as-child\", \"as\", \"min\", \"max\", \"dir\", \"inverted\", \"aria-disabled\", \"data-disabled\"]))\n        ]),\n        _: 3\n      }),\n      n(g) ? (h(true), Q(le, { key: 0 }, po(n(w), (j, I) => (h(), Q(\"input\", {\n        key: I,\n        value: j,\n        type: \"number\",\n        style: { display: \"none\" },\n        name: R.name ? R.name + (n(w).length > 1 ? \"[]\" : \"\") : void 0,\n        disabled: n(d),\n        step: n(l)\n      }, null, 8, mi))), 128)) : X(\"\", true)\n    ], 64));\n  }\n}), gi = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"SliderThumbImpl\",\n  props: {\n    index: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = Nt(), a = ga(), { forwardRef: s, currentElement: r } = $(), l = S(() => {\n      var v, g;\n      return (g = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : g[t.index];\n    }), i = S(() => l.value === void 0 ? 0 : fa(l.value, e.min.value ?? 0, e.max.value ?? 100)), u = S(() => {\n      var v, g;\n      return ri(t.index, ((g = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : g.length) ?? 0);\n    }), d = Dn(r), p = S(() => d[a.size].value), c = S(() => p.value ? ii(p.value, i.value, a.direction) : 0), f = Dt();\n    return q(() => {\n      e.thumbElements.value.push(r.value);\n    }), fe(() => {\n      const v = e.thumbElements.value.findIndex((g) => g === r.value) ?? -1;\n      e.thumbElements.value.splice(v, 1);\n    }), (v, g) => (h(), C(n(To), null, {\n      default: m(() => [\n        k(n(D), T(v.$attrs, {\n          ref: n(s),\n          role: \"slider\",\n          \"data-radix-vue-collection-item\": \"\",\n          tabindex: n(e).disabled.value ? void 0 : 0,\n          \"aria-label\": v.$attrs[\"aria-label\"] || u.value,\n          \"data-disabled\": n(e).disabled.value ? \"\" : void 0,\n          \"data-orientation\": n(e).orientation.value,\n          \"aria-valuenow\": l.value,\n          \"aria-valuemin\": n(e).min.value,\n          \"aria-valuemax\": n(e).max.value,\n          \"aria-orientation\": n(e).orientation.value,\n          \"as-child\": v.asChild,\n          as: v.as,\n          style: {\n            transform: \"var(--radix-slider-thumb-transform)\",\n            position: \"absolute\",\n            [n(a).startEdge]: `calc(${i.value}% + ${c.value}px)`,\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            display: !n(f) && l.value === void 0 ? \"none\" : void 0\n          },\n          onFocus: g[0] || (g[0] = () => {\n            n(e).valueIndexToChangeRef.value = v.index;\n          })\n        }), {\n          default: m(() => [\n            y(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"tabindex\", \"aria-label\", \"data-disabled\", \"data-orientation\", \"aria-valuenow\", \"aria-valuemin\", \"aria-valuemax\", \"aria-orientation\", \"as-child\", \"as\", \"style\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Lc = /* @__PURE__ */ b({\n  __name: \"SliderThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { getItems: e } = Wn(), { forwardRef: a, currentElement: s } = $(), r = S(() => s.value ? e().findIndex((l) => l.ref === s.value) : -1);\n    return (l, i) => (h(), C(gi, T({ ref: n(a) }, t, { index: r.value }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"index\"]));\n  }\n}), Kc = /* @__PURE__ */ b({\n  __name: \"SliderTrack\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = Nt();\n    return $(), (e, a) => (h(), C(n(D), {\n      \"as-child\": e.asChild,\n      as: e.as,\n      \"data-disabled\": n(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": n(t).orientation.value\n    }, {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), Nc = /* @__PURE__ */ b({\n  __name: \"SliderRange\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = Nt(), e = ga();\n    $();\n    const a = S(() => {\n      var l, i;\n      return (i = (l = t.modelValue) == null ? void 0 : l.value) == null ? void 0 : i.map(\n        (u) => fa(u, t.min.value, t.max.value)\n      );\n    }), s = S(() => t.modelValue.value.length > 1 ? Math.min(...a.value) : 0), r = S(() => 100 - Math.max(...a.value));\n    return (l, i) => (h(), C(n(D), {\n      \"data-disabled\": n(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": n(t).orientation.value,\n      \"as-child\": l.asChild,\n      as: l.as,\n      style: re({\n        [n(e).startEdge]: `${s.value}%`,\n        [n(e).endEdge]: `${r.value}%`\n      })\n    }, {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-disabled\", \"data-orientation\", \"as-child\", \"as\", \"style\"]));\n  }\n}), yi = [\"name\", \"disabled\", \"required\", \"value\", \"checked\", \"data-state\", \"data-disabled\"], [bi, Ci] = H(\"SwitchRoot\"), Hc = /* @__PURE__ */ b({\n  __name: \"SwitchRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    value: { default: \"on\" },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { disabled: s } = z(e), r = Y(e, \"checked\", a, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    });\n    function l() {\n      s.value || (r.value = !r.value);\n    }\n    const { forwardRef: i, currentElement: u } = $(), d = Ne(u), p = S(() => {\n      var c;\n      return e.id && u.value ? (c = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : c.innerText : void 0;\n    });\n    return Ci({\n      checked: r,\n      toggleCheck: l,\n      disabled: s\n    }), (c, f) => (h(), Q(le, null, [\n      k(n(D), T(c.$attrs, {\n        id: c.id,\n        ref: n(i),\n        role: \"switch\",\n        type: c.as === \"button\" ? \"button\" : void 0,\n        value: c.value,\n        \"aria-label\": c.$attrs[\"aria-label\"] || p.value,\n        \"aria-checked\": n(r),\n        \"aria-required\": c.required,\n        \"data-state\": n(r) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": n(s) ? \"\" : void 0,\n        \"as-child\": c.asChild,\n        as: c.as,\n        disabled: n(s),\n        onClick: l,\n        onKeydown: ie(oe(l, [\"prevent\"]), [\"enter\"])\n      }), {\n        default: m(() => [\n          y(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"type\", \"value\", \"aria-label\", \"aria-checked\", \"aria-required\", \"data-state\", \"data-disabled\", \"as-child\", \"as\", \"disabled\", \"onKeydown\"]),\n      n(d) ? (h(), Q(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        name: c.name,\n        tabindex: \"-1\",\n        \"aria-hidden\": \"\",\n        disabled: n(s),\n        required: c.required,\n        value: c.value,\n        checked: !!n(r),\n        \"data-state\": n(r) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": n(s) ? \"\" : void 0,\n        style: re({\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        })\n      }, null, 12, yi)) : X(\"\", true)\n    ], 64));\n  }\n}), jc = /* @__PURE__ */ b({\n  __name: \"SwitchThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = bi();\n    return $(), (e, a) => {\n      var s;\n      return h(), C(n(D), {\n        \"data-state\": (s = n(t).checked) != null && s.value ? \"checked\" : \"unchecked\",\n        \"data-disabled\": n(t).disabled.value ? \"\" : void 0,\n        \"as-child\": e.asChild,\n        as: e.as\n      }, {\n        default: m(() => [\n          y(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"]);\n    };\n  }\n}), [Ht, wi] = H(\"TabsRoot\"), Wc = /* @__PURE__ */ b({\n  __name: \"TabsRoot\",\n  props: {\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    activationMode: { default: \"automatic\" },\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { orientation: s, dir: r } = z(e), l = de(r);\n    $();\n    const i = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), u = P();\n    return wi({\n      modelValue: i,\n      changeModelValue: (d) => {\n        i.value = d;\n      },\n      orientation: s,\n      dir: l,\n      activationMode: e.activationMode,\n      baseId: te(),\n      tabsList: u\n    }), (d, p) => (h(), C(n(D), {\n      dir: n(l),\n      \"data-orientation\": n(s),\n      \"as-child\": d.asChild,\n      as: d.as\n    }, {\n      default: m(() => [\n        y(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"dir\", \"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), zc = /* @__PURE__ */ b({\n  __name: \"TabsList\",\n  props: {\n    loop: { type: Boolean, default: true },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { loop: e } = z(t), { forwardRef: a, currentElement: s } = $(), r = Ht();\n    return r.tabsList = s, (l, i) => (h(), C(n(et), {\n      \"as-child\": \"\",\n      orientation: n(r).orientation.value,\n      dir: n(r).dir.value,\n      loop: n(e)\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(a),\n          role: \"tablist\",\n          \"as-child\": l.asChild,\n          as: l.as,\n          \"aria-orientation\": n(r).orientation.value\n        }, {\n          default: m(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"aria-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n});\nfunction Ca(o2, t) {\n  return `${o2}-trigger-${t}`;\n}\nfunction wa(o2, t) {\n  return `${o2}-content-${t}`;\n}\nconst Uc = /* @__PURE__ */ b({\n  __name: \"TabsContent\",\n  props: {\n    value: {},\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $(), a = Ht(), s = S(() => Ca(a.baseId, t.value)), r = S(() => wa(a.baseId, t.value)), l = S(() => t.value === a.modelValue.value), i = P(l.value);\n    return q(() => {\n      requestAnimationFrame(() => {\n        i.value = false;\n      });\n    }), (u, d) => (h(), C(n(se), {\n      present: l.value,\n      \"force-mount\": \"\"\n    }, {\n      default: m(({ present: p }) => [\n        k(n(D), {\n          id: r.value,\n          ref: n(e),\n          \"as-child\": u.asChild,\n          as: u.as,\n          role: \"tabpanel\",\n          \"data-state\": l.value ? \"active\" : \"inactive\",\n          \"data-orientation\": n(a).orientation.value,\n          \"aria-labelledby\": s.value,\n          hidden: !p.value,\n          tabindex: \"0\",\n          style: re({\n            animationDuration: i.value ? \"0s\" : void 0\n          })\n        }, {\n          default: m(() => [\n            u.forceMount || l.value ? y(u.$slots, \"default\", { key: 0 }) : X(\"\", true)\n          ]),\n          _: 2\n        }, 1032, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-orientation\", \"aria-labelledby\", \"hidden\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), qc = /* @__PURE__ */ b({\n  __name: \"TabsTrigger\",\n  props: {\n    value: {},\n    disabled: { type: Boolean, default: false },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $(), a = Ht(), s = S(() => Ca(a.baseId, t.value)), r = S(() => wa(a.baseId, t.value)), l = S(() => t.value === a.modelValue.value);\n    return (i, u) => (h(), C(n(tt), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      active: l.value\n    }, {\n      default: m(() => [\n        k(n(D), {\n          id: s.value,\n          ref: n(e),\n          role: \"tab\",\n          type: i.as === \"button\" ? \"button\" : void 0,\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"aria-selected\": l.value ? \"true\" : \"false\",\n          \"aria-controls\": r.value,\n          \"data-state\": l.value ? \"active\" : \"inactive\",\n          disabled: i.disabled,\n          \"data-disabled\": i.disabled ? \"\" : void 0,\n          \"data-orientation\": n(a).orientation.value,\n          onMousedown: u[0] || (u[0] = oe((d) => {\n            !i.disabled && d.ctrlKey === false ? n(a).changeModelValue(i.value) : d.preventDefault();\n          }, [\"left\"])),\n          onKeydown: u[1] || (u[1] = ie((d) => n(a).changeModelValue(i.value), [\"enter\", \"space\"])),\n          onFocus: u[2] || (u[2] = () => {\n            const d = n(a).activationMode !== \"manual\";\n            !l.value && !i.disabled && d && n(a).changeModelValue(i.value);\n          })\n        }, {\n          default: m(() => [\n            y(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as\", \"as-child\", \"aria-selected\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), Gc = /* @__PURE__ */ b({\n  __name: \"TabsIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = Ht();\n    $();\n    const a = P({\n      size: null,\n      position: null\n    });\n    U(() => e.modelValue.value, async (r) => {\n      await G(), s();\n    }, { immediate: true }), be(e.tabsList, s);\n    function s() {\n      var l;\n      const r = (l = e.tabsList.value) == null ? void 0 : l.querySelector('[role=\"tab\"][data-state=\"active\"]');\n      r && (e.orientation.value === \"horizontal\" ? a.value = {\n        size: r.offsetWidth,\n        position: r.offsetLeft\n      } : a.value = {\n        size: r.offsetHeight,\n        position: r.offsetTop\n      });\n    }\n    return (r, l) => typeof a.value.size == \"number\" ? (h(), C(n(D), T({ key: 0 }, t, {\n      style: {\n        \"--radix-tabs-indicator-size\": `${a.value.size}px`,\n        \"--radix-tabs-indicator-position\": `${a.value.position}px`\n      }\n    }), {\n      default: m(() => [\n        y(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"])) : X(\"\", true);\n  }\n}), [jt, _i] = H(\"TagsInputRoot\"), Yc = /* @__PURE__ */ b({\n  __name: \"TagsInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: { default: () => [] },\n    addOnPaste: { type: Boolean },\n    duplicate: { type: Boolean },\n    disabled: { type: Boolean },\n    delimiter: { default: \",\" },\n    dir: {},\n    max: { default: 0 },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"invalid\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { addOnPaste: s, disabled: r, delimiter: l, max: i, id: u, dir: d } = z(e), p = de(d), c = Y(e, \"modelValue\", a, {\n      defaultValue: e.defaultValue,\n      passive: true,\n      deep: true\n    }), { forwardRef: f, currentElement: v } = $(), { focused: g } = vs(v), w = Ne(v), { getItems: E } = Bo(), _ = P(), x = P(false);\n    return _i({\n      modelValue: c,\n      onAddValue: (B) => {\n        if (c.value.length >= i.value && i.value)\n          return a(\"invalid\", B), false;\n        if (e.duplicate)\n          return c.value.push(B), true;\n        if (c.value.includes(B))\n          x.value = true;\n        else\n          return c.value.push(B), true;\n        return a(\"invalid\", B), false;\n      },\n      onRemoveValue: (B) => {\n        B !== -1 && c.value.splice(B, 1);\n      },\n      onInputKeydown: (B) => {\n        const O = B.target, A = E().map((R) => R.ref).filter((R) => R.dataset.disabled !== \"\");\n        if (!A.length)\n          return;\n        const M = A.at(-1);\n        switch (B.key) {\n          case \"Delete\":\n          case \"Backspace\": {\n            if (O.selectionStart !== 0 || O.selectionEnd !== 0)\n              break;\n            if (_.value) {\n              const R = A.findIndex((V) => V === _.value);\n              c.value.splice(R, 1), _.value = _.value === M ? A.at(R - 1) : A.at(R + 1), B.preventDefault();\n            } else\n              B.key === \"Backspace\" && (_.value = M, B.preventDefault());\n            break;\n          }\n          case \"Home\":\n          case \"End\":\n          case \"ArrowRight\":\n          case \"ArrowLeft\": {\n            const R = B.key === \"ArrowRight\" && p.value === \"ltr\" || B.key === \"ArrowLeft\" && p.value === \"rtl\", V = !R;\n            if (O.selectionStart !== 0 || O.selectionEnd !== 0)\n              break;\n            if (V && !_.value)\n              _.value = M, B.preventDefault();\n            else if (R && M && _.value === M)\n              _.value = void 0, B.preventDefault();\n            else if (_.value) {\n              const j = Je(B, _.value, void 0, {\n                itemsArray: A,\n                loop: false,\n                dir: p.value\n              });\n              j && (_.value = j), B.preventDefault();\n            }\n            break;\n          }\n          case \"ArrowUp\":\n          case \"ArrowDown\": {\n            _.value && B.preventDefault();\n            break;\n          }\n          default:\n            _.value = void 0;\n        }\n      },\n      selectedElement: _,\n      isInvalidInput: x,\n      addOnPaste: s,\n      dir: p,\n      disabled: r,\n      delimiter: l,\n      max: i,\n      id: u\n    }), (B, O) => (h(), C(n(So), null, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(f),\n          dir: n(p),\n          as: B.as,\n          \"as-child\": B.asChild,\n          \"data-invalid\": x.value ? \"\" : void 0,\n          \"data-disabled\": n(r) ? \"\" : void 0,\n          \"data-focused\": n(g) ? \"\" : void 0\n        }, {\n          default: m(() => [\n            y(B.$slots, \"default\", { modelValue: n(c) }),\n            n(w) && B.name ? (h(), C(n(jn), {\n              key: 0,\n              name: B.name,\n              value: n(c),\n              required: B.required,\n              disabled: n(r)\n            }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"])) : X(\"\", true)\n          ]),\n          _: 3\n        }, 8, [\"dir\", \"as\", \"as-child\", \"data-invalid\", \"data-disabled\", \"data-focused\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Xc = /* @__PURE__ */ b({\n  __name: \"TagsInputInput\",\n  props: {\n    placeholder: {},\n    autoFocus: { type: Boolean },\n    maxLength: {},\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(o2) {\n    const t = o2, e = jt(), { forwardRef: a, currentElement: s } = $();\n    async function r(u) {\n      if (await G(), u.defaultPrevented)\n        return;\n      const d = u.target;\n      if (!d.value)\n        return;\n      e.onAddValue(d.value) && (d.value = \"\"), u.preventDefault();\n    }\n    function l(u) {\n      e.isInvalidInput.value = false;\n      const d = e.delimiter.value;\n      if (d === u.data) {\n        const p = u.target;\n        p.value = p.value.replaceAll(d, \"\"), e.onAddValue(p.value) && (p.value = \"\");\n      }\n    }\n    function i(u) {\n      if (e.addOnPaste.value) {\n        u.preventDefault();\n        const d = u.clipboardData;\n        if (!d)\n          return;\n        const p = d.getData(\"text\");\n        e.delimiter.value ? p.split(e.delimiter.value).forEach((f) => {\n          e.onAddValue(f);\n        }) : e.onAddValue(p);\n      }\n    }\n    return q(() => {\n      const u = s.value.nodeName === \"INPUT\" ? s.value : s.value.querySelector(\"input\");\n      u && setTimeout(() => {\n        t.autoFocus && (u == null || u.focus());\n      }, 1);\n    }), (u, d) => {\n      var p;\n      return h(), C(n(D), {\n        id: (p = n(e).id) == null ? void 0 : p.value,\n        ref: n(a),\n        type: \"text\",\n        autocomplete: \"off\",\n        autocorrect: \"off\",\n        autocapitalize: \"off\",\n        as: u.as,\n        \"as-child\": u.asChild,\n        maxlength: u.maxLength,\n        placeholder: u.placeholder,\n        disabled: n(e).disabled.value,\n        \"data-invalid\": n(e).isInvalidInput.value ? \"\" : void 0,\n        onInput: l,\n        onKeydown: [\n          ie(r, [\"enter\"]),\n          n(e).onInputKeydown\n        ],\n        onPaste: i\n      }, {\n        default: m(() => [\n          y(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"id\", \"as\", \"as-child\", \"maxlength\", \"placeholder\", \"disabled\", \"data-invalid\", \"onKeydown\"]);\n    };\n  }\n}), [_a, $i] = H(\"TagsInputItem\"), Jc = /* @__PURE__ */ b({\n  __name: \"TagsInputItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { value: e } = z(t), a = jt(), { forwardRef: s, currentElement: r } = $(), l = S(() => a.selectedElement.value === r.value), i = te(), u = S(() => t.disabled || a.disabled.value);\n    return $i({\n      value: e,\n      isSelected: l,\n      disabled: u,\n      textId: i\n    }), (d, p) => (h(), C(n(To), null, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(s),\n          as: d.as,\n          \"as-child\": d.asChild,\n          \"aria-labelledby\": n(i),\n          \"aria-current\": l.value,\n          \"data-disabled\": u.value ? \"\" : void 0,\n          \"data-state\": l.value ? \"active\" : \"inactive\"\n        }, {\n          default: m(() => [\n            y(d.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"aria-labelledby\", \"aria-current\", \"data-disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Zc = /* @__PURE__ */ b({\n  __name: \"TagsInputItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(o2) {\n    const t = o2, e = _a();\n    return $(), (a, s) => (h(), C(n(D), T(t, {\n      id: n(e).textId\n    }), {\n      default: m(() => [\n        y(a.$slots, \"default\", {}, () => [\n          ue(Le(n(e).value.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Qc = /* @__PURE__ */ b({\n  __name: \"TagsInputItemDelete\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = jt(), a = _a(), s = S(() => {\n      var l;\n      return ((l = a.disabled) == null ? void 0 : l.value) || e.disabled.value;\n    });\n    function r() {\n      if (s.value)\n        return;\n      const l = e.modelValue.value.findIndex((i) => i === a.value.value);\n      e.onRemoveValue(l);\n    }\n    return (l, i) => (h(), C(n(D), T({ tabindex: \"-1\" }, t, {\n      \"aria-labelledby\": n(a).textId,\n      \"aria-current\": n(a).isSelected.value,\n      \"data-state\": n(a).isSelected.value ? \"active\" : \"inactive\",\n      \"data-disabled\": s.value ? \"\" : void 0,\n      type: l.as === \"button\" ? \"button\" : void 0,\n      onClick: r\n    }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\", \"aria-current\", \"data-state\", \"data-disabled\", \"type\"]));\n  }\n}), ep = /* @__PURE__ */ b({\n  __name: \"TagsInputClear\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2;\n    $();\n    const e = jt();\n    function a() {\n      e.disabled.value || (e.modelValue.value = []);\n    }\n    return (s, r) => (h(), C(n(D), T(t, {\n      type: s.as === \"button\" ? \"button\" : void 0,\n      \"data-disabled\": n(e).disabled.value ? \"\" : void 0,\n      onClick: a\n    }), {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"data-disabled\"]));\n  }\n}), [Wt, xi] = H(\"ToastProvider\"), tp = /* @__PURE__ */ b({\n  __name: \"ToastProvider\",\n  props: {\n    label: { default: \"Notification\" },\n    duration: { default: 5e3 },\n    swipeDirection: { default: \"right\" },\n    swipeThreshold: { default: 50 }\n  },\n  setup(o2) {\n    const t = o2, { label: e, duration: a, swipeDirection: s, swipeThreshold: r } = z(t), l = P(), i = P(0), u = P(false), d = P(false);\n    if (t.label && typeof t.label == \"string\" && !t.label.trim()) {\n      const p = \"Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.\";\n      throw new Error(p);\n    }\n    return xi({\n      label: e,\n      duration: a,\n      swipeDirection: s,\n      swipeThreshold: r,\n      toastCount: i,\n      viewport: l,\n      onViewportChange(p) {\n        l.value = p;\n      },\n      onToastAdd() {\n        i.value++;\n      },\n      onToastRemove() {\n        i.value--;\n      },\n      isFocusedToastEscapeKeyDownRef: u,\n      isClosePausedRef: d\n    }), (p, c) => y(p.$slots, \"default\");\n  }\n}), Ei = \"toast.swipeStart\", Pi = \"toast.swipeMove\", Bi = \"toast.swipeCancel\", Si = \"toast.swipeEnd\", lo = \"toast.viewportPause\", io = \"toast.viewportResume\";\nfunction $t(o2, t, e) {\n  const a = e.originalEvent.currentTarget, s = new CustomEvent(o2, {\n    bubbles: false,\n    cancelable: true,\n    detail: e\n  });\n  t && a.addEventListener(o2, t, { once: true }), a.dispatchEvent(s);\n}\nfunction pn(o2, t, e = 0) {\n  const a = Math.abs(o2.x), s = Math.abs(o2.y), r = a > s;\n  return t === \"left\" || t === \"right\" ? r && a > e : !r && s > e;\n}\nfunction Ti(o2) {\n  return o2.nodeType === o2.ELEMENT_NODE;\n}\nfunction $a(o2) {\n  const t = [];\n  return Array.from(o2.childNodes).forEach((a) => {\n    if (a.nodeType === a.TEXT_NODE && a.textContent && t.push(a.textContent), Ti(a)) {\n      const s = a.ariaHidden || a.hidden || a.style.display === \"none\", r = a.dataset.radixToastAnnounceExclude === \"\";\n      if (!s)\n        if (r) {\n          const l = a.dataset.radixToastAnnounceAlt;\n          l && t.push(l);\n        } else\n          t.push(...$a(a));\n    }\n  }), t;\n}\nconst Di = /* @__PURE__ */ b({\n  __name: \"ToastAnnounce\",\n  setup(o2) {\n    const t = Wt(), e = ls(1e3), a = P(false);\n    return cs(() => {\n      a.value = true;\n    }), (s, r) => n(e) || a.value ? (h(), C(n(Qe), { key: 0 }, {\n      default: m(() => [\n        ue(Le(n(t).label.value) + \" \", 1),\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    })) : X(\"\", true);\n  }\n}), [Oi, Ii] = H(\"ToastRoot\"), Ai = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"ToastRootImpl\",\n  props: {\n    type: {},\n    open: { type: Boolean, default: false },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"close\", \"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { forwardRef: s, currentElement: r } = $(), l = Wt(), i = P(null), u = P(null), d = S(() => e.duration || l.duration.value), p = P(0), c = P(d.value), f = P(0);\n    function v(E) {\n      !E || E === Number.POSITIVE_INFINITY || (window.clearTimeout(f.value), p.value = (/* @__PURE__ */ new Date()).getTime(), f.value = window.setTimeout(g, E));\n    }\n    function g() {\n      var _, x;\n      ((_ = r.value) == null ? void 0 : _.contains(document.activeElement)) && ((x = l.viewport.value) == null || x.focus()), a(\"close\");\n    }\n    const w = S(() => r.value ? $a(r.value) : null);\n    if (e.type && ![\"foreground\", \"background\"].includes(e.type)) {\n      const E = \"Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.\";\n      throw new Error(E);\n    }\n    return ee((E) => {\n      const _ = l.viewport.value;\n      if (_) {\n        const x = () => {\n          v(c.value), a(\"resume\");\n        }, B = () => {\n          const O = (/* @__PURE__ */ new Date()).getTime() - p.value;\n          c.value = c.value - O, window.clearTimeout(f.value), a(\"pause\");\n        };\n        return _.addEventListener(lo, B), _.addEventListener(io, x), () => {\n          _.removeEventListener(lo, B), _.removeEventListener(io, x);\n        };\n      }\n    }), ee(() => {\n      e.open && !l.isClosePausedRef.value && v(d.value);\n    }), go(\"Escape\", (E) => {\n      a(\"escapeKeyDown\", E), E.defaultPrevented || (l.isFocusedToastEscapeKeyDownRef.value = true, g());\n    }), q(() => {\n      l.onToastAdd();\n    }), fe(() => {\n      l.onToastRemove();\n    }), Ii({ onClose: g }), (E, _) => (h(), Q(le, null, [\n      w.value ? (h(), C(Di, {\n        key: 0,\n        role: \"status\",\n        \"aria-live\": E.type === \"foreground\" ? \"assertive\" : \"polite\",\n        \"aria-atomic\": \"\"\n      }, {\n        default: m(() => [\n          ue(Le(w.value), 1)\n        ]),\n        _: 1\n      }, 8, [\"aria-live\"])) : X(\"\", true),\n      (h(), C(Ye, {\n        to: n(l).viewport.value\n      }, [\n        k(n(D), T({\n          ref: n(s),\n          role: \"status\",\n          \"aria-live\": \"off\",\n          \"aria-atomic\": \"\",\n          tabindex: \"0\",\n          \"data-radix-vue-collection-item\": \"\"\n        }, E.$attrs, {\n          as: E.as,\n          \"as-child\": E.asChild,\n          \"data-state\": E.open ? \"open\" : \"closed\",\n          \"data-swipe-direction\": n(l).swipeDirection.value,\n          style: { userSelect: \"none\", touchAction: \"none\" },\n          onPointerdown: _[0] || (_[0] = oe((x) => {\n            i.value = { x: x.clientX, y: x.clientY };\n          }, [\"left\"])),\n          onPointermove: _[1] || (_[1] = (x) => {\n            if (!i.value)\n              return;\n            const B = x.clientX - i.value.x, O = x.clientY - i.value.y, A = !!u.value, M = [\"left\", \"right\"].includes(n(l).swipeDirection.value), R = [\"left\", \"up\"].includes(n(l).swipeDirection.value) ? Math.min : Math.max, V = M ? R(0, B) : 0, j = M ? 0 : R(0, O), I = x.pointerType === \"touch\" ? 10 : 2, F = { x: V, y: j }, W = { originalEvent: x, delta: F };\n            A ? (u.value = F, n($t)(n(Pi), (J) => a(\"swipeMove\", J), W)) : n(pn)(F, n(l).swipeDirection.value, I) ? (u.value = F, n($t)(n(Ei), (J) => a(\"swipeStart\", J), W), x.target.setPointerCapture(x.pointerId)) : (Math.abs(B) > I || Math.abs(O) > I) && (i.value = null);\n          }),\n          onPointerup: _[2] || (_[2] = (x) => {\n            const B = u.value, O = x.target;\n            if (O.hasPointerCapture(x.pointerId) && O.releasePointerCapture(x.pointerId), u.value = null, i.value = null, B) {\n              const A = x.currentTarget, M = { originalEvent: x, delta: B };\n              n(pn)(B, n(l).swipeDirection.value, n(l).swipeThreshold.value) ? n($t)(n(Si), (R) => a(\"swipeEnd\", R), M) : n($t)(n(Bi), (R) => a(\"swipeCancel\", R), M), A == null || A.addEventListener(\"click\", (R) => R.preventDefault(), {\n                once: true\n              });\n            }\n          })\n        }), {\n          default: m(() => [\n            y(E.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"data-state\", \"data-swipe-direction\"])\n      ], 8, [\"to\"]))\n    ], 64));\n  }\n}), op = /* @__PURE__ */ b({\n  __name: \"ToastRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: true },\n    forceMount: { type: Boolean },\n    type: { default: \"foreground\" },\n    open: { type: Boolean, default: void 0 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\", \"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { forwardRef: s } = $(), r = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (l, i) => (h(), C(n(se), {\n      present: l.forceMount || n(r)\n    }, {\n      default: m(() => [\n        k(Ai, T({\n          ref: n(s),\n          open: n(r),\n          type: l.type,\n          as: l.as,\n          \"as-child\": l.asChild,\n          duration: l.duration\n        }, l.$attrs, {\n          onClose: i[0] || (i[0] = (u) => r.value = false),\n          onPause: i[1] || (i[1] = (u) => a(\"pause\")),\n          onResume: i[2] || (i[2] = (u) => a(\"resume\")),\n          onEscapeKeyDown: i[3] || (i[3] = (u) => a(\"escapeKeyDown\", u)),\n          onSwipeStart: i[4] || (i[4] = (u) => {\n            a(\"swipeStart\", u), u.currentTarget.setAttribute(\"data-swipe\", \"start\");\n          }),\n          onSwipeMove: i[5] || (i[5] = (u) => {\n            const { x: d, y: p } = u.detail.delta, c = u.currentTarget;\n            c.setAttribute(\"data-swipe\", \"move\"), c.style.setProperty(\"--radix-toast-swipe-move-x\", `${d}px`), c.style.setProperty(\"--radix-toast-swipe-move-y\", `${p}px`);\n          }),\n          onSwipeCancel: i[6] || (i[6] = (u) => {\n            const d = u.currentTarget;\n            d.setAttribute(\"data-swipe\", \"cancel\"), d.style.removeProperty(\"--radix-toast-swipe-move-x\"), d.style.removeProperty(\"--radix-toast-swipe-move-y\"), d.style.removeProperty(\"--radix-toast-swipe-end-x\"), d.style.removeProperty(\"--radix-toast-swipe-end-y\");\n          }),\n          onSwipeEnd: i[7] || (i[7] = (u) => {\n            const { x: d, y: p } = u.detail.delta, c = u.currentTarget;\n            c.setAttribute(\"data-swipe\", \"end\"), c.style.removeProperty(\"--radix-toast-swipe-move-x\"), c.style.removeProperty(\"--radix-toast-swipe-move-y\"), c.style.setProperty(\"--radix-toast-swipe-end-x\", `${d}px`), c.style.setProperty(\"--radix-toast-swipe-end-y\", `${p}px`), r.value = false;\n          })\n        }), {\n          default: m(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"open\", \"type\", \"as\", \"as-child\", \"duration\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), xa = /* @__PURE__ */ b({\n  __name: \"ToastAnnounceExclude\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    return (t, e) => (h(), C(n(D), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-radix-toast-announce-exclude\": \"\",\n      \"data-radix-toast-announce-alt\": t.altText || void 0\n    }, {\n      default: m(() => [\n        y(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-radix-toast-announce-alt\"]));\n  }\n}), Ri = /* @__PURE__ */ b({\n  __name: \"ToastClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = Oi(), { forwardRef: a } = $();\n    return (s, r) => (h(), C(xa, { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), T(t, {\n          ref: n(a),\n          type: s.as === \"button\" ? \"button\" : void 0,\n          onClick: r[0] || (r[0] = (l) => n(e).onClose())\n        }), {\n          default: m(() => [\n            y(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }));\n  }\n}), np = /* @__PURE__ */ b({\n  __name: \"ToastAction\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    if (!o2.altText)\n      throw new Error(\"Missing prop `altText` expected on `ToastAction`\");\n    const { forwardRef: e } = $();\n    return (a, s) => a.altText ? (h(), C(xa, {\n      key: 0,\n      \"alt-text\": a.altText,\n      \"as-child\": \"\"\n    }, {\n      default: m(() => [\n        k(Ri, {\n          ref: n(e),\n          as: a.as,\n          \"as-child\": a.asChild\n        }, {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\"])\n      ]),\n      _: 3\n    }, 8, [\"alt-text\"])) : X(\"\", true);\n  }\n}), fn = /* @__PURE__ */ b({\n  __name: \"FocusProxy\",\n  emits: [\"focusFromOutsideViewport\"],\n  setup(o2, { emit: t }) {\n    const e = t, a = Wt();\n    return (s, r) => (h(), C(n(Qe), {\n      \"aria-hidden\": \"\",\n      tabindex: \"0\",\n      style: { position: \"fixed\" },\n      onFocus: r[0] || (r[0] = (l) => {\n        var d;\n        const i = l.relatedTarget;\n        !((d = n(a).viewport.value) != null && d.contains(i)) && e(\"focusFromOutsideViewport\");\n      })\n    }, {\n      default: m(() => [\n        y(s.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), ap = /* @__PURE__ */ b({\n  inheritAttrs: false,\n  __name: \"ToastViewport\",\n  props: {\n    hotkey: { default: () => [\"F8\"] },\n    label: { default: \"Notifications ({hotkey})\" },\n    asChild: { type: Boolean },\n    as: { default: \"ol\" }\n  },\n  setup(o2) {\n    const t = o2, { hotkey: e, label: a } = z(t), { forwardRef: s, currentElement: r } = $(), { createCollection: l } = ve(), i = l(r), u = Wt(), d = S(() => u.toastCount.value > 0), p = P(), c = P();\n    go(e.value, () => {\n      r.value.focus();\n    }), q(() => {\n      u.onViewportChange(r.value);\n    }), ee((v) => {\n      const g = r.value;\n      if (d.value && g) {\n        const w = () => {\n          if (!u.isClosePausedRef.value) {\n            const O = new CustomEvent(lo);\n            g.dispatchEvent(O), u.isClosePausedRef.value = true;\n          }\n        }, E = () => {\n          if (u.isClosePausedRef.value) {\n            const O = new CustomEvent(io);\n            g.dispatchEvent(O), u.isClosePausedRef.value = false;\n          }\n        }, _ = (O) => {\n          !g.contains(O.relatedTarget) && E();\n        }, x = () => {\n          g.contains(document.activeElement) || E();\n        }, B = (O) => {\n          var R, V, j;\n          const A = O.altKey || O.ctrlKey || O.metaKey;\n          if (O.key === \"Tab\" && !A) {\n            const I = document.activeElement, F = O.shiftKey;\n            if (O.target === g && F) {\n              (R = p.value) == null || R.focus();\n              return;\n            }\n            const K = f({ tabbingDirection: F ? \"backwards\" : \"forwards\" }), Z = K.findIndex((ne) => ne === I);\n            xt(K.slice(Z + 1)) ? O.preventDefault() : F ? (V = p.value) == null || V.focus() : (j = c.value) == null || j.focus();\n          }\n        };\n        g.addEventListener(\"focusin\", w), g.addEventListener(\"focusout\", _), g.addEventListener(\"pointermove\", w), g.addEventListener(\"pointerleave\", x), g.addEventListener(\"keydown\", B), window.addEventListener(\"blur\", w), window.addEventListener(\"focus\", E), v(() => {\n          g.removeEventListener(\"focusin\", w), g.removeEventListener(\"focusout\", _), g.removeEventListener(\"pointermove\", w), g.removeEventListener(\"pointerleave\", x), g.removeEventListener(\"keydown\", B), window.removeEventListener(\"blur\", w), window.removeEventListener(\"focus\", E);\n        });\n      }\n    });\n    function f({ tabbingDirection: v }) {\n      const w = i.value.map((E) => {\n        const _ = [E, ...$o(E)];\n        return v === \"forwards\" ? _ : _.reverse();\n      });\n      return (v === \"forwards\" ? w.reverse() : w).flat();\n    }\n    return (v, g) => (h(), C(n(Ws), {\n      role: \"region\",\n      \"aria-label\": n(a).replace(\"{hotkey}\", n(e).join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\")),\n      tabindex: \"-1\",\n      style: re({\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        pointerEvents: d.value ? void 0 : \"none\"\n      })\n    }, {\n      default: m(() => [\n        d.value ? (h(), C(fn, {\n          key: 0,\n          ref: (w) => {\n            p.value = n(pe)(w);\n          },\n          onFocusFromOutsideViewport: g[0] || (g[0] = () => {\n            const w = f({\n              tabbingDirection: \"forwards\"\n            });\n            n(xt)(w);\n          })\n        }, null, 512)) : X(\"\", true),\n        k(n(D), T({\n          ref: n(s),\n          tabindex: \"-1\",\n          as: v.as,\n          \"as-child\": v.asChild\n        }, v.$attrs), {\n          default: m(() => [\n            y(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\"]),\n        d.value ? (h(), C(fn, {\n          key: 1,\n          ref: (w) => {\n            c.value = n(pe)(w);\n          },\n          onFocusFromOutsideViewport: g[1] || (g[1] = () => {\n            const w = f({\n              tabbingDirection: \"backwards\"\n            });\n            n(xt)(w);\n          })\n        }, null, 512)) : X(\"\", true)\n      ]),\n      _: 3\n    }, 8, [\"aria-label\", \"style\"]));\n  }\n}), sp = /* @__PURE__ */ b({\n  __name: \"ToastTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(D), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rp = /* @__PURE__ */ b({\n  __name: \"ToastDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(D), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Mi = /* @__PURE__ */ b({\n  __name: \"Toggle\",\n  props: {\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean, default: false },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:pressed\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t;\n    $();\n    const s = Y(e, \"pressed\", a, {\n      defaultValue: e.defaultValue,\n      passive: e.pressed === void 0\n    });\n    function r() {\n      s.value = !s.value;\n    }\n    const l = S(() => s.value ? \"on\" : \"off\");\n    return (i, u) => (h(), C(n(D), {\n      type: i.as === \"button\" ? \"button\" : void 0,\n      \"as-child\": e.asChild,\n      as: i.as,\n      \"aria-pressed\": n(s),\n      \"data-state\": l.value,\n      \"data-disabled\": i.disabled ? \"\" : void 0,\n      disabled: i.disabled,\n      onClick: r\n    }, {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as-child\", \"as\", \"aria-pressed\", \"data-state\", \"data-disabled\", \"disabled\"]));\n  }\n}), [ki, Vi] = H(\"ToggleGroupRoot\"), Fi = /* @__PURE__ */ b({\n  __name: \"ToggleGroupRoot\",\n  props: {\n    type: { default: \"single\" },\n    defaultValue: {},\n    modelValue: {},\n    rovingFocus: { type: Boolean, default: true },\n    disabled: { type: Boolean, default: false },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean, default: true },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, { loop: s, rovingFocus: r, disabled: l, dir: i } = z(e), u = de(i), { forwardRef: d } = $(), { modelValue: p, changeModelValue: c } = Rn(e, a);\n    return Vi({\n      type: e.type,\n      modelValue: p,\n      changeModelValue: c,\n      dir: u,\n      orientation: e.orientation,\n      loop: s,\n      rovingFocus: r,\n      disabled: l\n    }), (f, v) => (h(), C(we(n(r) ? n(et) : n(D)), {\n      \"as-child\": \"\",\n      orientation: n(r) ? f.orientation : void 0,\n      dir: n(u),\n      loop: n(r) ? n(s) : void 0\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(d),\n          role: \"group\",\n          \"as-child\": f.asChild,\n          as: f.as\n        }, {\n          default: m(() => [\n            y(f.$slots, \"default\", { modelValue: n(p) })\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Li = /* @__PURE__ */ b({\n  __name: \"ToggleGroupItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = ki(), a = S(() => {\n      var l;\n      return ((l = e.disabled) == null ? void 0 : l.value) || t.disabled;\n    }), s = S(() => {\n      var l;\n      return (l = e.modelValue.value) == null ? void 0 : l.includes(t.value);\n    }), { forwardRef: r } = $();\n    return (l, i) => (h(), C(we(n(e).rovingFocus.value ? n(tt) : n(D)), {\n      \"as-child\": \"\",\n      focusable: !a.value,\n      active: s.value\n    }, {\n      default: m(() => {\n        var u;\n        return [\n          k(n(Mi), T(t, {\n            ref: n(r),\n            disabled: a.value,\n            pressed: n(e).type === \"single\" ? n(e).modelValue.value === l.value : (u = n(e).modelValue.value) == null ? void 0 : u.includes(l.value),\n            \"onUpdate:pressed\": i[0] || (i[0] = (d) => n(e).changeModelValue(l.value))\n          }), {\n            default: m(() => [\n              y(l.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"disabled\", \"pressed\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), [Ea, Ki] = H(\"ToolbarRoot\"), lp = /* @__PURE__ */ b({\n  __name: \"ToolbarRoot\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { orientation: e, dir: a } = z(t), s = de(a), { forwardRef: r } = $();\n    return Ki({ orientation: e, dir: s }), (l, i) => (h(), C(n(et), {\n      \"as-child\": \"\",\n      orientation: n(e),\n      dir: n(s),\n      loop: l.loop\n    }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(r),\n          role: \"toolbar\",\n          \"aria-orientation\": n(e),\n          \"as-child\": l.asChild,\n          as: l.as\n        }, {\n          default: m(() => [\n            y(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"aria-orientation\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), Ni = /* @__PURE__ */ b({\n  __name: \"ToolbarButton\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $();\n    return (a, s) => (h(), C(n(tt), {\n      \"as-child\": \"\",\n      focusable: !a.disabled\n    }, {\n      default: m(() => [\n        k(n(D), T({\n          ref: n(e),\n          type: a.as === \"button\" ? \"button\" : void 0\n        }, t), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\"]));\n  }\n}), ip = /* @__PURE__ */ b({\n  __name: \"ToolbarLink\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $();\n    return (a, s) => (h(), C(n(tt), {\n      \"as-child\": \"\",\n      focusable: \"\"\n    }, {\n      default: m(() => [\n        k(n(D), T(t, {\n          ref: n(e),\n          onKeydown: s[0] || (s[0] = (r) => {\n            var l;\n            r.key === \" \" && ((l = r.currentTarget) == null || l.click());\n          })\n        }), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), up = /* @__PURE__ */ b({\n  __name: \"ToolbarToggleGroup\",\n  props: {\n    type: {},\n    defaultValue: {},\n    modelValue: {},\n    rovingFocus: { type: Boolean },\n    disabled: { type: Boolean },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = Ea(), r = ce(a);\n    return $(), (l, i) => (h(), C(n(Fi), T({ ...e, ...n(r) }, {\n      \"data-orientation\": n(s).orientation.value,\n      dir: n(s).dir.value,\n      \"roving-focus\": false\n    }), {\n      default: m(() => [\n        y(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"data-orientation\", \"dir\"]));\n  }\n}), dp = /* @__PURE__ */ b({\n  __name: \"ToolbarToggleItem\",\n  props: {\n    value: {},\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, { forwardRef: e } = $();\n    return (a, s) => (h(), C(Ni, { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(Li), T(t, { ref: n(e) }), {\n          default: m(() => [\n            y(a.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), cp = /* @__PURE__ */ b({\n  __name: \"ToolbarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(o2) {\n    const t = o2, e = Ea();\n    return $(), (a, s) => (h(), C(ca, {\n      orientation: n(e).orientation.value,\n      \"as-child\": t.asChild,\n      as: a.as\n    }, {\n      default: m(() => [\n        y(a.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"as-child\", \"as\"]));\n  }\n}), Pa = \"tooltip.open\";\nfunction Hi(o2, t) {\n  const e = Math.abs(t.top - o2.y), a = Math.abs(t.bottom - o2.y), s = Math.abs(t.right - o2.x), r = Math.abs(t.left - o2.x);\n  switch (Math.min(e, a, s, r)) {\n    case r:\n      return \"left\";\n    case s:\n      return \"right\";\n    case e:\n      return \"top\";\n    case a:\n      return \"bottom\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction ji(o2, t, e = 5) {\n  const a = [];\n  switch (t) {\n    case \"top\":\n      a.push(\n        { x: o2.x - e, y: o2.y + e },\n        { x: o2.x + e, y: o2.y + e }\n      );\n      break;\n    case \"bottom\":\n      a.push(\n        { x: o2.x - e, y: o2.y - e },\n        { x: o2.x + e, y: o2.y - e }\n      );\n      break;\n    case \"left\":\n      a.push(\n        { x: o2.x + e, y: o2.y - e },\n        { x: o2.x + e, y: o2.y + e }\n      );\n      break;\n    case \"right\":\n      a.push(\n        { x: o2.x - e, y: o2.y - e },\n        { x: o2.x - e, y: o2.y + e }\n      );\n      break;\n  }\n  return a;\n}\nfunction Wi(o2) {\n  const { top: t, right: e, bottom: a, left: s } = o2;\n  return [\n    { x: s, y: t },\n    { x: e, y: t },\n    { x: e, y: a },\n    { x: s, y: a }\n  ];\n}\nfunction zi(o2, t) {\n  const { x: e, y: a } = o2;\n  let s = false;\n  for (let r = 0, l = t.length - 1; r < t.length; l = r++) {\n    const i = t[r].x, u = t[r].y, d = t[l].x, p = t[l].y;\n    u > a != p > a && e < (d - i) * (a - u) / (p - u) + i && (s = !s);\n  }\n  return s;\n}\nfunction Ui(o2) {\n  const t = o2.slice();\n  return t.sort((e, a) => e.x < a.x ? -1 : e.x > a.x ? 1 : e.y < a.y ? -1 : e.y > a.y ? 1 : 0), qi(t);\n}\nfunction qi(o2) {\n  if (o2.length <= 1)\n    return o2.slice();\n  const t = [];\n  for (let a = 0; a < o2.length; a++) {\n    const s = o2[a];\n    for (; t.length >= 2; ) {\n      const r = t[t.length - 1], l = t[t.length - 2];\n      if ((r.x - l.x) * (s.y - l.y) >= (r.y - l.y) * (s.x - l.x))\n        t.pop();\n      else\n        break;\n    }\n    t.push(s);\n  }\n  t.pop();\n  const e = [];\n  for (let a = o2.length - 1; a >= 0; a--) {\n    const s = o2[a];\n    for (; e.length >= 2; ) {\n      const r = e[e.length - 1], l = e[e.length - 2];\n      if ((r.x - l.x) * (s.y - l.y) >= (r.y - l.y) * (s.x - l.x))\n        e.pop();\n      else\n        break;\n    }\n    e.push(s);\n  }\n  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);\n}\nconst [Qo, Gi] = H(\"TooltipProvider\"), pp = /* @__PURE__ */ b({\n  __name: \"TooltipProvider\",\n  props: {\n    delayDuration: { default: 700 },\n    skipDelayDuration: { default: 300 },\n    disableHoverableContent: { type: Boolean, default: false },\n    disableClosingTrigger: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2, { delayDuration: e, skipDelayDuration: a, disableHoverableContent: s, disableClosingTrigger: r } = z(t);\n    $();\n    const l = P(true), i = Tt(false, 300), { start: u, stop: d } = ho(() => {\n      l.value = true;\n    }, a, { immediate: false });\n    return Gi({\n      isOpenDelayed: l,\n      delayDuration: e,\n      onOpen() {\n        d(), l.value = false;\n      },\n      onClose() {\n        u();\n      },\n      isPointerInTransitRef: i,\n      onPointerInTransitChange(p) {\n        i.value = p;\n      },\n      disableHoverableContent: s,\n      disableClosingTrigger: r\n    }), (p, c) => y(p.$slots, \"default\");\n  }\n}), [zt, Yi] = H(\"TooltipRoot\"), fp = /* @__PURE__ */ b({\n  __name: \"TooltipRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: false },\n    open: { type: Boolean, default: void 0 },\n    delayDuration: { default: void 0 },\n    disableHoverableContent: { type: Boolean, default: void 0 },\n    disableClosingTrigger: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t;\n    $();\n    const s = Qo(), r = S(() => e.disableHoverableContent ?? s.disableHoverableContent.value), l = S(() => e.disableClosingTrigger ?? s.disableClosingTrigger.value), i = S(() => e.delayDuration ?? s.delayDuration.value), u = Y(e, \"open\", a, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    U(u, (_) => {\n      s.onClose && (_ ? (s.onOpen(), document.dispatchEvent(new CustomEvent(Pa))) : s.onClose());\n    });\n    const d = P(false), p = P(), c = S(() => u.value ? d.value ? \"delayed-open\" : \"instant-open\" : \"closed\"), { start: f, stop: v } = ho(() => {\n      d.value = true, u.value = true;\n    }, i, { immediate: false });\n    function g() {\n      v(), d.value = false, u.value = true;\n    }\n    function w() {\n      v(), u.value = false;\n    }\n    function E() {\n      f();\n    }\n    return Yi({\n      contentId: te(),\n      open: u,\n      stateAttribute: c,\n      trigger: p,\n      onTriggerChange(_) {\n        p.value = _;\n      },\n      onTriggerEnter() {\n        s.isOpenDelayed.value ? E() : g();\n      },\n      onTriggerLeave() {\n        r.value ? w() : v();\n      },\n      onOpen: g,\n      onClose: w,\n      disableHoverableContent: r,\n      disableClosingTrigger: l\n    }), (_, x) => (h(), C(n(je), null, {\n      default: m(() => [\n        y(_.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), vp = /* @__PURE__ */ b({\n  __name: \"TooltipTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(o2) {\n    const t = o2, e = zt(), a = Qo(), { forwardRef: s, currentElement: r } = $(), l = P(false), i = P(false);\n    function u() {\n      l.value = false;\n    }\n    function d() {\n      l.value = true, document.addEventListener(\"pointerup\", u, { once: true });\n    }\n    return q(() => {\n      e.onTriggerChange(r.value);\n    }), (p, c) => (h(), C(n(We), { \"as-child\": \"\" }, {\n      default: m(() => [\n        k(n(D), {\n          ref: n(s),\n          \"aria-describedby\": n(e).open.value ? n(e).contentId : void 0,\n          \"data-state\": n(e).stateAttribute.value,\n          as: p.as,\n          \"as-child\": t.asChild,\n          onPointermove: c[0] || (c[0] = (f) => {\n            f.pointerType !== \"touch\" && !i.value && !n(a).isPointerInTransitRef.value && (n(e).onTriggerEnter(), i.value = true);\n          }),\n          onPointerleave: c[1] || (c[1] = (f) => {\n            n(e).onTriggerLeave(), i.value = false;\n          }),\n          onPointerdown: d,\n          onFocus: c[2] || (c[2] = () => {\n            l.value || n(e).onOpen();\n          }),\n          onBlur: c[3] || (c[3] = (f) => n(e).onClose()),\n          onClick: c[4] || (c[4] = () => {\n            n(e).disableClosingTrigger.value || n(e).onClose();\n          })\n        }, {\n          default: m(() => [\n            y(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"aria-describedby\", \"data-state\", \"as\", \"as-child\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Ba = /* @__PURE__ */ b({\n  __name: \"TooltipContentImpl\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: { default: 0 },\n    align: { default: \"center\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean, default: true },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    arrowPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: false }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = zt(), { forwardRef: r } = $(), l = xn(), i = S(() => {\n      var p;\n      return (p = l.default) == null ? void 0 : p.call(l);\n    }), u = S(() => {\n      var f;\n      if (e.ariaLabel)\n        return e.ariaLabel;\n      let p = \"\";\n      function c(v) {\n        typeof v.children == \"string\" ? p += v.children : Array.isArray(v.children) && v.children.forEach((g) => c(g));\n      }\n      return (f = i.value) == null || f.forEach((v) => c(v)), p;\n    }), d = S(() => {\n      const { ariaLabel: p, ...c } = e;\n      return c;\n    });\n    return q(() => {\n      Be(window, \"scroll\", (p) => {\n        const c = p.target;\n        c != null && c.contains(s.trigger.value) && s.onClose();\n      }), Be(window, Pa, s.onClose);\n    }), (p, c) => (h(), C(n(De), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": false,\n      onEscapeKeyDown: c[0] || (c[0] = (f) => a(\"escapeKeyDown\", f)),\n      onPointerDownOutside: c[1] || (c[1] = (f) => {\n        var v;\n        n(s).disableClosingTrigger.value && ((v = n(s).trigger.value) != null && v.contains(f.target)) && f.preventDefault(), a(\"pointerDownOutside\", f);\n      }),\n      onFocusOutside: c[2] || (c[2] = oe(() => {\n      }, [\"prevent\"])),\n      onDismiss: c[3] || (c[3] = (f) => n(s).onClose())\n    }, {\n      default: m(() => [\n        k(n(Fe), T({\n          ref: n(r),\n          \"data-state\": n(s).stateAttribute.value\n        }, { ...p.$attrs, ...d.value }, { style: {\n          \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        } }), {\n          default: m(() => [\n            y(p.$slots, \"default\"),\n            k(n(Qe), {\n              id: n(s).contentId,\n              role: \"tooltip\"\n            }, {\n              default: m(() => [\n                ue(Le(u.value), 1)\n              ]),\n              _: 1\n            }, 8, [\"id\"])\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"style\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Xi = /* @__PURE__ */ b({\n  __name: \"TooltipContentHoverable\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  setup(o2) {\n    const e = He(o2), { forwardRef: a, currentElement: s } = $(), { trigger: r, onClose: l } = zt(), i = Qo(), u = P(null);\n    function d() {\n      u.value = null, i.onPointerInTransitChange(false);\n    }\n    function p(c, f) {\n      const v = c.currentTarget, g = { x: c.clientX, y: c.clientY }, w = Hi(g, v.getBoundingClientRect()), E = ji(g, w), _ = Wi(f.getBoundingClientRect()), x = Ui([...E, ..._]);\n      u.value = x, i.onPointerInTransitChange(true);\n    }\n    return ee((c) => {\n      if (r.value && s.value) {\n        const f = (g) => p(g, s.value), v = (g) => p(g, r.value);\n        r.value.addEventListener(\"pointerleave\", f), s.value.addEventListener(\"pointerleave\", v), c(() => {\n          var g, w;\n          (g = r.value) == null || g.removeEventListener(\"pointerleave\", f), (w = s.value) == null || w.removeEventListener(\"pointerleave\", v);\n        });\n      }\n    }), ee((c) => {\n      if (u.value) {\n        const f = (v) => {\n          var x, B;\n          if (!u.value)\n            return;\n          const g = v.target, w = { x: v.clientX, y: v.clientY }, E = ((x = r.value) == null ? void 0 : x.contains(g)) || ((B = s.value) == null ? void 0 : B.contains(g)), _ = !zi(w, u.value);\n          E ? d() : _ && (d(), l());\n        };\n        document.addEventListener(\"pointermove\", f), c(() => document.removeEventListener(\"pointermove\", f));\n      }\n    }), (c, f) => (h(), C(Ba, T({ ref: n(a) }, n(e)), {\n      default: m(() => [\n        y(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), mp = /* @__PURE__ */ b({\n  __name: \"TooltipContent\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(o2, { emit: t }) {\n    const e = o2, a = t, s = zt(), r = ae(e, a), { forwardRef: l } = $();\n    return (i, u) => n(s).open.value ? (h(), C(we(n(s).disableHoverableContent.value ? Ba : Xi), T({\n      key: 0,\n      ref: n(l)\n    }, n(r)), {\n      default: m(() => [\n        y(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : X(\"\", true);\n  }\n}), hp = /* @__PURE__ */ b({\n  __name: \"TooltipArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(o2) {\n    const t = o2;\n    return $(), (e, a) => (h(), C(n(Ze), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gp = /* @__PURE__ */ b({\n  __name: \"TooltipPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(o2) {\n    const t = o2;\n    return (e, a) => (h(), C(n(Te), L(N(t)), {\n      default: m(() => [\n        y(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nexport {\n  au as AccordionContent,\n  su as AccordionHeader,\n  nu as AccordionItem,\n  ou as AccordionRoot,\n  ru as AccordionTrigger,\n  hu as AlertDialogAction,\n  fu as AlertDialogCancel,\n  cu as AlertDialogContent,\n  mu as AlertDialogDescription,\n  pu as AlertDialogOverlay,\n  du as AlertDialogPortal,\n  iu as AlertDialogRoot,\n  vu as AlertDialogTitle,\n  uu as AlertDialogTrigger,\n  gu as AspectRatio,\n  Cu as AvatarFallback,\n  bu as AvatarImage,\n  yu as AvatarRoot,\n  _u as CheckboxIndicator,\n  wu as CheckboxRoot,\n  Is as CollapsibleContent,\n  Ts as CollapsibleRoot,\n  Ds as CollapsibleTrigger,\n  Eu as ComboboxAnchor,\n  ku as ComboboxArrow,\n  Bu as ComboboxCancel,\n  Du as ComboboxContent,\n  Ou as ComboboxEmpty,\n  Su as ComboboxGroup,\n  xu as ComboboxInput,\n  Au as ComboboxItem,\n  Ru as ComboboxItemIndicator,\n  Tu as ComboboxLabel,\n  Vu as ComboboxPortal,\n  $u as ComboboxRoot,\n  Mu as ComboboxSeparator,\n  Pu as ComboboxTrigger,\n  Iu as ComboboxViewport,\n  eu as ConfigProvider,\n  Hu as ContextMenuArrow,\n  Uu as ContextMenuCheckboxItem,\n  Nu as ContextMenuContent,\n  Wu as ContextMenuGroup,\n  ju as ContextMenuItem,\n  qu as ContextMenuItemIndicator,\n  Gu as ContextMenuLabel,\n  Ku as ContextMenuPortal,\n  Yu as ContextMenuRadioGroup,\n  Xu as ContextMenuRadioItem,\n  Fu as ContextMenuRoot,\n  zu as ContextMenuSeparator,\n  Ju as ContextMenuSub,\n  Zu as ContextMenuSubContent,\n  Qu as ContextMenuSubTrigger,\n  Lu as ContextMenuTrigger,\n  Fn as DialogClose,\n  lr as DialogContent,\n  cr as DialogDescription,\n  ur as DialogOverlay,\n  lu as DialogPortal,\n  Fs as DialogRoot,\n  dr as DialogTitle,\n  Ls as DialogTrigger,\n  ad as DropdownMenuArrow,\n  id as DropdownMenuCheckboxItem,\n  nd as DropdownMenuContent,\n  rd as DropdownMenuGroup,\n  sd as DropdownMenuItem,\n  ud as DropdownMenuItemIndicator,\n  dd as DropdownMenuLabel,\n  od as DropdownMenuPortal,\n  cd as DropdownMenuRadioGroup,\n  pd as DropdownMenuRadioItem,\n  ed as DropdownMenuRoot,\n  ld as DropdownMenuSeparator,\n  fd as DropdownMenuSub,\n  vd as DropdownMenuSubContent,\n  md as DropdownMenuSubTrigger,\n  td as DropdownMenuTrigger,\n  Cd as HoverCardArrow,\n  bd as HoverCardContent,\n  yd as HoverCardPortal,\n  hd as HoverCardRoot,\n  gd as HoverCardTrigger,\n  wd as Label,\n  Bd as MenubarArrow,\n  Od as MenubarCheckboxItem,\n  Pd as MenubarContent,\n  Td as MenubarGroup,\n  Sd as MenubarItem,\n  Id as MenubarItemIndicator,\n  Ad as MenubarLabel,\n  $d as MenubarMenu,\n  Ed as MenubarPortal,\n  Rd as MenubarRadioGroup,\n  Md as MenubarRadioItem,\n  _d as MenubarRoot,\n  Dd as MenubarSeparator,\n  kd as MenubarSub,\n  Vd as MenubarSubContent,\n  Fd as MenubarSubTrigger,\n  xd as MenubarTrigger,\n  Nd as NavigationMenuContent,\n  Hd as NavigationMenuIndicator,\n  Kd as NavigationMenuItem,\n  jd as NavigationMenuLink,\n  Wd as NavigationMenuList,\n  Ld as NavigationMenuRoot,\n  zd as NavigationMenuSub,\n  Ud as NavigationMenuTrigger,\n  qd as NavigationMenuViewport,\n  Yd as PaginationEllipsis,\n  Xd as PaginationFirst,\n  Jd as PaginationLast,\n  Zd as PaginationList,\n  Qd as PaginationListItem,\n  ec as PaginationNext,\n  tc as PaginationPrev,\n  Gd as PaginationRoot,\n  nc as PinInputInput,\n  oc as PinInputRoot,\n  dc as PopoverAnchor,\n  ic as PopoverArrow,\n  uc as PopoverClose,\n  lc as PopoverContent,\n  rc as PopoverPortal,\n  ac as PopoverRoot,\n  sc as PopoverTrigger,\n  D as Primitive,\n  pc as ProgressIndicator,\n  cc as ProgressRoot,\n  mc as RadioGroupIndicator,\n  vc as RadioGroupItem,\n  fc as RadioGroupRoot,\n  Cc as ScrollAreaCorner,\n  hc as ScrollAreaRoot,\n  yc as ScrollAreaScrollbar,\n  bc as ScrollAreaThumb,\n  gc as ScrollAreaViewport,\n  Ec as SelectArrow,\n  xc as SelectContent,\n  Tc as SelectGroup,\n  kc as SelectIcon,\n  Bc as SelectItem,\n  Sc as SelectItemIndicator,\n  Oc as SelectItemText,\n  Dc as SelectLabel,\n  $c as SelectPortal,\n  wc as SelectRoot,\n  Rc as SelectScrollDownButton,\n  Ac as SelectScrollUpButton,\n  Pc as SelectSeparator,\n  _c as SelectTrigger,\n  Mc as SelectValue,\n  Ic as SelectViewport,\n  Vc as Separator,\n  Nc as SliderRange,\n  Fc as SliderRoot,\n  Lc as SliderThumb,\n  Kc as SliderTrack,\n  wo as Slot,\n  Hc as SwitchRoot,\n  jc as SwitchThumb,\n  Uc as TabsContent,\n  Gc as TabsIndicator,\n  zc as TabsList,\n  Wc as TabsRoot,\n  qc as TabsTrigger,\n  ep as TagsInputClear,\n  Xc as TagsInputInput,\n  Jc as TagsInputItem,\n  Qc as TagsInputItemDelete,\n  Zc as TagsInputItemText,\n  Yc as TagsInputRoot,\n  np as ToastAction,\n  Ri as ToastClose,\n  rp as ToastDescription,\n  tp as ToastProvider,\n  op as ToastRoot,\n  sp as ToastTitle,\n  ap as ToastViewport,\n  Mi as Toggle,\n  Li as ToggleGroupItem,\n  Fi as ToggleGroupRoot,\n  Ni as ToolbarButton,\n  ip as ToolbarLink,\n  lp as ToolbarRoot,\n  cp as ToolbarSeparator,\n  up as ToolbarToggleGroup,\n  dp as ToolbarToggleItem,\n  hp as TooltipArrow,\n  mp as TooltipContent,\n  gp as TooltipPortal,\n  pp as TooltipProvider,\n  fp as TooltipRoot,\n  vp as TooltipTrigger,\n  Qe as VisuallyHidden,\n  H as createContext,\n  ct as useBodyScrollLock,\n  ce as useEmitAsProps,\n  $ as useForwardExpose,\n  He as useForwardProps,\n  ae as useForwardPropsEmits,\n  te as useId,\n  On as useStateMachine,\n  tu as withDefault\n};\n",
      "start": 1709267491796,
      "end": 1709267492022,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1709267492022,
      "end": 1709267492022,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1709267492022,
      "end": 1709267492022,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1709267492022,
      "end": 1709267492022,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1709267492022,
      "end": 1709267492022,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1709267492022,
      "end": 1709267492076,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1709267492076,
      "end": 1709267492076,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1709267492076,
      "end": 1709267492076,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1709267492076,
      "end": 1709267492157,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1709267492157,
      "end": 1709267492157,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1709267492157,
      "end": 1709267492158,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1709267492158,
      "end": 1709267492158,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1709267492158,
      "end": 1709267492158,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1709267492158,
      "end": 1709267492158,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1709267492158,
      "end": 1709267492158,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1709267492158,
      "end": 1709267492158,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1709267492158,
      "end": 1709267492158,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1709267492159,
      "end": 1709267492159,
      "order": "normal"
    }
  ]
}
